@INPROCEEDINGS{Le95_91,
  AUTHOR = {Leuschel, Michael},
  PUBLISHER = {Springer-Verlag},
  BOOKTITLE = {LOPSTR},
  DATE = {1994},
  ISBN = {3-540-58792-6},
  PAGES = {122--137},
  SERIES = {Lecture Notes in Computer Science},
  TITLE = {Partial Evaluation of the "Real Thing"},
  VOLUME = {883},
}

@INPROCEEDINGS{LeDe95_92,
  AUTHOR = {Leuschel, Michael and Schreye, Danny De},
  PUBLISHER = {ACM Press},
  BOOKTITLE = {PEPM},
  DATE = {1995},
  PAGES = {253--263},
  TITLE = {Towards Creating Specialised Integrity Checks Through Partial Evaluation of Meta-Interpreters},
}

@INPROCEEDINGS{LeDeMa95_93,
  AUTHOR = {Leuschel, Michael and Schreye, Danny De and Martens, Bern},
  PUBLISHER = {MIT Press},
  BOOKTITLE = {ILPS},
  DATE = {1995},
  PAGES = {615--616},
  TITLE = {Tutorial on Program Specialisation (abstract)},
}

@INPROCEEDINGS{LeMa95_94,
  AUTHOR = {Leuschel, Michael and Martens, Bern},
  PUBLISHER = {GMD-Studien Nr. 266},
  BOOKTITLE = {Proc. Joint Workshop on Deductive Databases and Logic Programming and Abduction in Deductive Databases and Knowledge Based Systems},
  DATE = {1995},
  PAGES = {81--95},
  TITLE = {Obtaining Specialised Update Procedures through Partial Deduction of the Ground Representation},
}

@INPROCEEDINGS{LeMa95_95,
  AUTHOR = {Leuschel, Michael and Martens, Bern},
  PUBLISHER = {MIT Press},
  BOOKTITLE = {ILPS},
  DATE = {1995},
  PAGES = {495--509},
  TITLE = {Partial Deduction of the Ground Representation and its Application to Integrity Checking},
}

@INPROCEEDINGS{JoLe96_82,
  AUTHOR = {J{ø}rgensen, Jesper and Leuschel, Michael},
  EDITOR = {Danvy, O. and Glueck, R. and Thiemann, P.},
  PUBLISHER = {Springer-Verlag},
  BOOKTITLE = {Dagstuhl Seminar on Partial Evaluation},
  DATE = {1996},
  ISBN = {3-540-61580-6},
  PAGES = {238--262},
  SERIES = {Lecture Notes in Computer Science},
  TITLE = {Efficiently Generating Efficient Generating Extensions in {Prolog}},
  VOLUME = {1110},
}

@INPROCEEDINGS{JoLeMa96_84,
  AUTHOR = {J{ø}rgensen, Jesper and Leuschel, Michael and Martens, Bern},
  EDITOR = {Gallagher, J.},
  PUBLISHER = {Springer-Verlag},
  BOOKTITLE = {LOPSTR},
  DATE = {1996-08},
  ISBN = {3-540-62718-9},
  PAGES = {59--82},
  SERIES = {Lecture Notes in Computer Science},
  TITLE = {Conjunctive Partial Deduction in Practice},
  VOLUME = {1207},
}

@INPROCEEDINGS{Le96_85,
  AUTHOR = {Leuschel, Michael},
  EDITOR = {Bocca, J. and Decker, H. and Voronkov, A.},
  PUBLISHER = {IBFI GmbH, Schloss Dagstuhl},
  BOOKTITLE = {Proc. Logic Databases and the Meaning of Change: Dagstuhl-Seminar-Report 157},
  DATE = {1996},
  PAGES = {18--19},
  TITLE = {Specialised Integrity Checking by Combining Conjunctive Partial Deduction and Abstract Interpretation},
}

@INPROCEEDINGS{LeDe96_86,
  AUTHOR = {Leuschel, Michael and Schreye, Danny De},
  EDITOR = {Kuchen, H. and Swierstra, S. D.},
  PUBLISHER = {Springer-Verlag},
  BOOKTITLE = {Proceedings PLILP'96},
  DATE = {1996-09},
  ISBN = {3-540-61756-6},
  PAGES = {137--151},
  SERIES = {Lecture Notes in Computer Science},
  TITLE = {Logic Program Specialisation: How To Be More Specific},
  VOLUME = {1140},
}

@INPROCEEDINGS{LeDe96_87,
  AUTHOR = {Leuschel, Michael and Schreye, Danny De},
  EDITOR = {Gallagher, J.},
  PUBLISHER = {Springer-Verlag},
  BOOKTITLE = {LOPSTR},
  DATE = {1996-08},
  ISBN = {3-540-62718-9},
  PAGES = {58},
  SERIES = {Lecture Notes in Computer Science},
  TITLE = {Logic Program Specialisation: How To Be More Specific (abstract)},
  VOLUME = {1207},
}

@INPROCEEDINGS{LeDede96_88,
  AUTHOR = {Leuschel, Michael and Schreye, Danny De and de Waal, D. Andre},
  EDITOR = {Maher, M.},
  PUBLISHER = {MIT Press},
  BOOKTITLE = {JICSLP},
  DATE = {1996-09},
  PAGES = {319--332},
  TITLE = {A Conceptual Embedding of Folding into Partial Deduction: Towards a Maximal Integration},
}

@INPROCEEDINGS{LeMa96_89,
  AUTHOR = {Leuschel, Michael and Martens, Bern},
  EDITOR = {Danvy, O. and Glueck, R. and Thiemann, P.},
  PUBLISHER = {Springer-Verlag},
  BOOKTITLE = {Dagstuhl Seminar on Partial Evaluation},
  DATE = {1996},
  ISBN = {3-540-61580-6},
  PAGES = {263--283},
  SERIES = {Lecture Notes in Computer Science},
  TITLE = {Global Control for Partial Deduction through Characteristic Atoms and Global Trees},
  VOLUME = {1110},
}

@INPROCEEDINGS{LeSo96_90,
  AUTHOR = {Leuschel, Michael and S{ø}rensen, Morten Heine},
  EDITOR = {Gallagher, J.},
  PUBLISHER = {Springer-Verlag},
  BOOKTITLE = {LOPSTR},
  DATE = {1996-08},
  ISBN = {3-540-62718-9},
  PAGES = {83--103},
  SERIES = {Lecture Notes in Computer Science},
  TITLE = {Redundant Argument Filtering of Logic Programs},
  VOLUME = {1207},
}

@THESIS{Jastram_thesis_1997,
  ABSTRACT = {<b>Localization</b> Localization is the process of determining the rigid-body translations and rotations that must be performed on a set of points measured on a manufactured surface (like a propeller blade) to move those points into the closest correspondence with the ideal design surface. An additional parameter is an offset distance, such that the Euclidean motion brings the measured points as close as possible to an offset of the design surface. An algorithm to determine the seven parameters (three rotations, three translations, one offset) was developed in 1991 by R. A. Jinkerson. But that algorithm makes some assumptions about the surface and the measured points, which are sometimes not fulfilled. Specifically, it assumes, that a measured point has always an orthogonal projection on the offset surface, regardless of the translation and rotation parameters. This thesis extends Jinkerson's algorithm, so that these assumptions are not necessary any longer. This involves the development of a new objective function and its gradient.<br><br> <b>Feature extraction</b> During the manufacturing process, a propeller blade surface is subject to manufacturing inaccuracies, that result in small changes to the data describing its features. It is therefore desirable to recompute these features for comparison with the original design data. Most of the characteristics of a propeller blade are embedded in the camber lines of its hydrofoil sections. The objective of this part of the thesis is to recompute the camber line from a hydrofoil shape curve. An algorithm for this task has already been developed, but it makes the assumption that the blade thickness has a single maximum, which is often not fulfilled, especially, if the hydrofoil has been generated from measured data. In this thesis, a new algorithm has been developed. It generates a highly accurate camber line by using a two pass iteration method: The first pass generates an approximation of the camber line, and the second pass refines this approximation to the desired accuracy.},
  AUTHOR = {Jastram, Michael},
  INSTITUTION = {Massachusetts Institute of Technology},
  DATE = {1996-12},
  TITLE = {Inspection and Feature Extraction of Marine Propellers},
  TYPE = {mathesis},
}

@ARTICLE{Le97_79,
  AUTHOR = {Leuschel, Michael},
  DATE = {1997},
  JOURNALTITLE = {AI Communications},
  NUMBER = {2},
  PAGES = {127--128},
  TITLE = {Advanced Techniques for Logic Program Specialisation},
  VOLUME = {10},
}

@INPROCEEDINGS{Le97_80,
  AUTHOR = {Leuschel, Michael},
  PUBLISHER = {MIT Press},
  BOOKTITLE = {ILPS},
  DATE = {1997-10},
  PAGES = {413--414},
  TITLE = {Specialization of Declarative Programs and its Application (workshop overview)},
}

@INPROCEEDINGS{Le97_81,
  AUTHOR = {Leuschel, Michael},
  EDITOR = {Puebla, German},
  BOOKTITLE = {Proceedings of the ILPS'97 Workshop on Tools and Environments for (Constraint) Logic Programming},
  DATE = {1997-10},
  SERIES = {Universidad Politécnica de Madrid Tech. Rep. CLIP7/97.1},
  TITLE = {The {Ecce} Partial Deduction System},
}

@PROCEEDINGS{Leuschel:SP97,
  EDITOR = {Leuschel, Michael},
  PUBLISHER = {K. U. Leuven, Tech. Rep. CW 255, also as DIKU Report 97/30, University of Copenhagen},
  DATE = {1997-10},
  TITLE = {Proceedings of the ILPS'97 Workshop on Specialisation of Declarative Programs and its Application},
}

@THESIS{Le97_216,
  AUTHOR = {Leuschel, Michael},
  INSTITUTION = {K.U. Leuven},
  DATE = {1997-05},
  TITLE = {Advanced Techniques for Logic Program Specialisation},
  TYPE = {phdthesis},
}

@THESIS{Ha97_302,
  ABSTRACT = {CSP-Z ist eine Sprache zur Spezifikation zustandsbasierter kommunizierender Systeme, welche die Prozeßalgebra CSP und die Z-Notation zusammenführt. Die Semantik von CSP-Z-Spezifikationen wird durch das Failures/Divergences-Modell von CSP beschrieben, das von Roscoe angepaßt wurde, um unbeschränkten Nichtdetermismus besser behandeln zu können. Für CSP gibt es eine Verfeinerungstheorie, die auf dem Failures/Divergences-Modell basiert. Diese Theorie lässt sich in einfacher Weise auf CSP-Z übertragen. Ziel dieser Arbeit ist es die existierende Verfeinerungstheorie von Z für CSP-Z nutzbar zu machen. Mit Z können Datentypen prädikativ beschrieben werden, die nicht oder nur mit großem Aufwand zu implementieren sind. Doch bieten diese Datentypen den Vorteil, daß sie zu leichter verständlichen Spezifikationen führen, da bei starker Abstraktion viele für die Funktionalität des zu entwickelnden Programms unwesentliche Details wegfallen. Zu einem späteren Zeitpunkt werden jedoch besser implementierbare Datentypen benötigt. Es ist in Z möglich, einen (abstrakten) Datentypen durch einen anderen (konkreten) Datentypen zu ersetzen, so daß Programme, die bei Verwendung des abstrakten Datentypen korrekt waren, es auch bei Verwendung des konkreten Datentypen bleiben. Dieses Verfahren heißt Datenverfeinerung. Als Beweismethode zum Nachweis einer Datenverfeinerung dient die Simulation. Bis zu einem gewissen Grade lässt sich die Datenverfeinerungstheorie auch im Zusammenhang mit unsichtbaren Operationen verwenden, die durch Hiding entstehen. Es werden einige Regeln entwickelt, die auf den Regeln zur Datenverfeinerung in Z basieren und benutzt werden können, um Simulationsbeziehungen zwischen CSP-Z-Spezifikationen zu beweisen. Die Anwendung der entwickelten Regeln wird anhand kleinerer Fallstudien veranschaulicht.},
  AUTHOR = {Hallerstede, Stefan},
  INSTITUTION = {Carl von Ossietzky Universität Oldenburg},
  DATE = {1997-01},
  TITLE = {Semantische Fundierung von CSP-Z},
  TYPE = {mathesis},
}

@INPROCEEDINGS{BrLeSa98_68,
  AUTHOR = {Bruynooghe, Maurice and Leuschel, Michael and Sagonas, Konstantinos},
  EDITOR = {Hankin, C.},
  PUBLISHER = {Springer-Verlag},
  BOOKTITLE = {ESOP},
  DATE = {1998-04},
  ISBN = {3-540-64302-8},
  PAGES = {27--41},
  SERIES = {Lecture Notes in Computer Science},
  TITLE = {A Polyvariant Binding-Time Analysis for Off-line Partial Deduction},
  VOLUME = {1381},
}

@INPROCEEDINGS{DeDeLeMaSa98_69,
  AUTHOR = {Decorte, Stefaan and Schreye, Danny De and Leuschel, Michael and Martens, Bern and Sagonas, Konstantinos},
  EDITOR = {Fuchs, N.},
  PUBLISHER = {Springer-Verlag},
  BOOKTITLE = {LOPSTR '97},
  DATE = {1998-07},
  ISBN = {3-540-65074-1},
  PAGES = {111--127},
  SERIES = {Lecture Notes in Computer Science},
  TITLE = {Termination Analysis for Tabled Logic Programming},
  VOLUME = {1463},
}

@INPROCEEDINGS{Le98_70,
  AUTHOR = {Leuschel, Michael},
  EDITOR = {Flener, P.},
  PUBLISHER = {Springer-Verlag},
  BOOKTITLE = {LOPSTR '98},
  DATE = {1998-06},
  ISBN = {3-540-65765-7},
  PAGES = {199--218},
  SERIES = {Lecture Notes in Computer Science},
  TITLE = {Improving Homeomorphic Embedding for Online Termination},
  VOLUME = {1559},
}

@INPROCEEDINGS{Le98_71,
  AUTHOR = {Leuschel, Michael},
  EDITOR = {Levi, Giorgio},
  PUBLISHER = {Springer-Verlag},
  BOOKTITLE = {Proceedings SAS},
  DATE = {1998-09},
  ISBN = {3-540-65014-8},
  PAGES = {230--245},
  SERIES = {Lecture Notes in Computer Science},
  TITLE = {On the Power of Homeomorphic Embedding for Online Termination},
  VOLUME = {1503},
}

@INPROCEEDINGS{Le98_72,
  AUTHOR = {Leuschel, Michael},
  EDITOR = {Jaffar, J.},
  PUBLISHER = {MIT Press},
  BOOKTITLE = {IJCSLP},
  DATE = {1998},
  PAGES = {220--234},
  TITLE = {Program Specialisation and Abstract Interpretation Reconciled},
}

@ARTICLE{LeDe98_73,
  AUTHOR = {Leuschel, Michael and Schreye, Danny De},
  DATE = {1998},
  JOURNALTITLE = {New Generation Computing},
  NUMBER = {3},
  PAGES = {283--342},
  TITLE = {Constrained Partial Deduction and the Preservation of Characteristic Trees},
  VOLUME = {16},
}

@ARTICLE{LeDe98_74,
  AUTHOR = {Leuschel, Michael and Schreye, Danny De},
  DATE = {1998},
  JOURNALTITLE = {Journal of Logic Programming},
  NUMBER = {2},
  PAGES = {149--193},
  TITLE = {Creating Specialised Integrity Checks Through Partial Evaluation of Meta-interpreters},
  VOLUME = {36},
}

@ARTICLE{LeMaDe98_75,
  AUTHOR = {Leuschel, Michael and Martens, Bern and Schreye, Danny De},
  DATE = {1998-01},
  JOURNALTITLE = {ACM Transactions on Programming Languages and Systems},
  NUMBER = {1},
  PAGES = {208--258},
  TITLE = {Controlling Generalisation and Polyvariance in Partial Deduction of Normal Logic Programs},
  VOLUME = {20},
}

@ARTICLE{LeMaDe98_76,
  AUTHOR = {Leuschel, Michael and Martens, Bern and Schreye, Danny De},
  DATE = {1998-09},
  JOURNALTITLE = {ACM Computing Surveys},
  NUMBER = {3es},
  TITLE = {Some Achievements and Prospects in Partial Deduction},
  VOLUME = {30},
}

@INPROCEEDINGS{LeMaSa98_77,
  AUTHOR = {Leuschel, Michael and Martens, Bern and Sagonas, Konstantinos},
  EDITOR = {Fuchs, N.},
  PUBLISHER = {Springer-Verlag},
  BOOKTITLE = {LOPSTR '97},
  DATE = {1998-07},
  ISBN = {3-540-65074-1},
  PAGES = {189--205},
  SERIES = {Lecture Notes in Computer Science},
  TITLE = {Preserving Termination of Tabled Logic Programs While Unfolding},
  VOLUME = {1463},
}

@ARTICLE{SaLe98_78,
  AUTHOR = {Sagonas, Konstantinos and Leuschel, Michael},
  DATE = {1998-09},
  JOURNALTITLE = {ACM Computing Surveys},
  NUMBER = {3es},
  TITLE = {Extending Partial Deduction to Tabled Execution: Some Results and Open Issues},
  VOLUME = {30},
}

@ARTICLE{DeGlJoLeMaSo99_57,
  AUTHOR = {Schreye, Danny De and Glueck, Robert and J{ø}rgensen, Jesper and Leuschel, Michael and Martens, Bern and S{ø}rensen, Morten H.},
  DATE = {1999-11},
  JOURNALTITLE = {Journal of Logic Programming},
  NUMBER = {2--3},
  PAGES = {231--277},
  TITLE = {Conjunctive Partial Deduction: Foundations, Control, Algorithms, and Experiments},
  VOLUME = {41},
}

@INPROCEEDINGS{GlLe99_58,
  AUTHOR = {Glueck, Robert and Leuschel, Michael},
  PUBLISHER = {Springer-Verlag},
  BOOKTITLE = {Ershov Memorial Conference},
  DATE = {1999},
  ISBN = {3-540-67102-1},
  PAGES = {93--100},
  SERIES = {Lecture Notes in Computer Science},
  TITLE = {Abstraction-Based Partial Deduction for Solving Inverse Problems -- A Transformational Approach to Software Verification},
  VOLUME = {1755},
}

@INPROCEEDINGS{HaBuCuHeLeMaSmUlWa99_59,
  ABSTRACT = {An abstract model of an industrial distributed data base application has been studied using process based, state based, and queueing theory based methods. The methods supported by graphical notations and/or integrated development environments were found to be easiest to work with. The methods supported by model checkers were the most successful in obtaining relevant information about the application. Applying a number of different methods to study one particular model encourages a problem to be viewed from different angles. This gives complementary information about the model. We report on a variety of problems of the model found through various routes. Our main conclusion is that asking experts to apply different methods and tools at a sufficiently abstract level can be done effectively revealing a broad range of information about the considered application.},
  AUTHOR = {Hartel, P. and Butler, Michael and Currie, Andrew and Henderson, P. and Leuschel, Michael and Martin, A. and Smith, A. and Ultes-Nitsche, Ulrich and Walters, R.J.},
  EDITOR = {Gnesi, S. and Latella, D.},
  PUBLISHER = {STAR/CNR, Pisa, Italy},
  BOOKTITLE = {Proc. 4th Int. Workshop on Formal Methods for Industrial Critical Systems},
  DATE = {1999-07},
  ISBN = {88-7958-009-4},
  PAGES = {179--203},
  TITLE = {Questions and Answers About Ten Formal Methods},
}

@INPROCEEDINGS{Le99_60,
  AUTHOR = {Leuschel, Michael},
  PUBLISHER = {Springer-Verlag},
  BOOKTITLE = {Partial Evaluation - Practice and Theory, DIKU 1998 International Summer School},
  DATE = {1999},
  ISBN = {3-540-66710-5},
  PAGES = {271--292},
  TITLE = {Advanced Logic Program Specialisation},
}

@PROCEEDINGS{Le99_61,
  EDITOR = {Leuschel, Michael},
  DATE = {1999-12},
  JOURNALTITLE = {Electronic Notes in Theoretical Computer Science},
  NUMBER = {2},
  PAGES = {94--},
  TITLE = {Int. Workshop on Optimization and Implementation of Declarative Programs},
  VOLUME = {30},
}

@INPROCEEDINGS{Le99_62,
  AUTHOR = {Leuschel, Michael},
  EDITOR = {Hatcliff, John and Mogensen, Torben AE and Thiemann, Peter},
  PUBLISHER = {Springer-Verlag},
  BOOKTITLE = {Partial Evaluation: Practice and Theory},
  DATE = {1999},
  ISBN = {3-540-66710-5},
  PAGES = {155--188},
  SERIES = {Lecture Notes in Computer Science},
  TITLE = {Logic Program Specialisation},
  VOLUME = {1706},
}

@ARTICLE{LeJo99_63,
  AUTHOR = {Leuschel, Michael and J{ø}rgensen, Jesper},
  DATE = {1999},
  JOURNALTITLE = {Electronic Notes in Theoretical Computer Science},
  NUMBER = {2},
  PAGES = {157--162},
  TITLE = {Efficient Specialisation in {Prolog} Using the Hand-Written Compiler Generator {LOGEN}},
  VOLUME = {30},
}

@REPORT{LeJo99_64,
  AUTHOR = {Leuschel, Michael and J{ø}rgensen, Jesper},
  INSTITUTION = {University of Southampton},
  DATE = {1999-09},
  NUMBER = {DSSE-TR-99-6},
  TITLE = {Efficient Specialisation in {Prolog} Using a Hand-Written Compiler Generator},
  TYPE = {techreport},
}

@INPROCEEDINGS{LeLiTh99_65,
  AUTHOR = {Leuschel, Michael and Linnenbruegger, Nick and Thoma, Jerome},
  EDITOR = {Kruijff, G-J. M. and Oerle, R. T.},
  PUBLISHER = {University of Utrecht},
  BOOKTITLE = {Proceedings of the Formal Grammar Conference FG'99},
  DATE = {1999-08},
  PAGES = {93--101},
  TITLE = {Analyzing Context-Free and Context-Sensitive Grammars by Abstract Interpretation},
}

@INPROCEEDINGS{LeMa99_66,
  ABSTRACT = {We illustrate the use of logic programming techniques for finite model checking of CTL formulae. We present a technique for infinite state model checking of safety properties based upon logic program specialisation and analysis techniques. The power of the approach is illustrated on several examples. For that, the efficient tools logen and ecce are used. We discuss how this approach has to be extended to handle more complicated infinite state systems and to handle arbitrary CTL formulae.},
  AUTHOR = {Leuschel, Michael and Massart, Thierry},
  EDITOR = {Bossi, A.},
  PUBLISHER = {Springer-Verlag},
  BOOKTITLE = {LOPSTR '99},
  DATE = {1999-09},
  ISBN = {3-540-67628-7},
  PAGES = {63--82},
  SERIES = {Lecture Notes in Computer Science},
  TITLE = {Infinite State Model Checking by Abstract Interpretation and Program Specialisation},
  VOLUME = {1817},
}

@INPROCEEDINGS{MaLe99_67,
  AUTHOR = {Martin, Jonathan C. and Leuschel, Michael},
  PUBLISHER = {Springer-Verlag},
  BOOKTITLE = {Ershov Memorial Conference},
  DATE = {1999},
  ISBN = {3-540-67102-1},
  PAGES = {101--112},
  SERIES = {Lecture Notes in Computer Science},
  TITLE = {Sonic Partial Deduction},
  VOLUME = {1755},
}

@REPORT{HaBu99_300,
  ABSTRACT = {Existing refinement frameworks such as B allow a developer to specify a system on an abstract level. Subsequently, this abstract specification is refined into an implementation that performs the specified task. In this paper a conventional refinement approach is extended with a means for performance analysis. This new approach guides a developer towards well-performing implementations throughout the refinement process. The main achievement of this work is an elaboration of a connection between performance and trace refinement.},
  AUTHOR = {Hallerstede, Stefan and Butler, Michael},
  INSTITUTION = {Electronics and Computer Science, University of Southampton},
  DATE = {1999},
  TITLE = {Refinement of Dynamic Systems},
  TYPE = {techreport},
}

@INPROCEEDINGS{CuLeMa00_49,
  ABSTRACT = {We show how to (and how not to) perform LTL model checking of CSP processes using refinement checking in general and the FDR tool in particular. We show how one can handle (potentially) deadlocking systems, discuss the validity of our approach for infinite state systems, and shed light on the relationship between ``classical'' model checking and refinement checking.},
  AUTHOR = {Currie, Andrew and Leuschel, Michael and Massart, Thierry},
  LOCATION = {London, UK},
  BOOKTITLE = {Proceedings VCL'2000},
  DATE = {2000-07},
  TITLE = {{LTL} Model Checking of {CSP} by Refinement: How to Make {FDR} Spin},
}

@INPROCEEDINGS{LeLe00_50,
  AUTHOR = {Lehmann, Helko and Leuschel, Michael},
  EDITOR = {LLoyd, John},
  PUBLISHER = {Springer-Verlag},
  BOOKTITLE = {Computational Logic},
  DATE = {2000-07},
  ISBN = {3-540-67797-6},
  PAGES = {762--776},
  SERIES = {Lecture Notes in Computer Science},
  TITLE = {Decidability Results for the Propositional Fluent Calculus},
  VOLUME = {1861},
}

@INPROCEEDINGS{LeLe00_51,
  AUTHOR = {Lehmann, Helko and Leuschel, Michael},
  EDITOR = {Parigot, Michel and Voronkov, Andrei},
  PUBLISHER = {Springer-Verlag},
  BOOKTITLE = {LPAR},
  DATE = {2000},
  SERIES = {Lecture Notes in Computer Science},
  TITLE = {Solving Planning Problems by Partial Deduction},
  VOLUME = {1955},
}

@REPORT{LeBr00_52,
  ABSTRACT = {Partial deduction is a source-to-source technique for specialising logic programs. This is (mostly) done by a well-automated application of parts of the Burstall and Darlington unfold/fold transformation framework. One of the main challenges of partial deduction is automatic control, which has to ensure correctness, efficiency, and termination. In this survey and tutorial, we present the essential developments over the past 10 years, and discuss their respective merits and shortcomings. We also present the current state of the art and discuss areas where further research is needed to enable more widespread practical use of partial deduction and realise its potential as a tool for systematic program development.},
  AUTHOR = {Leuschel, Michael and Bruynooghe, Maurice},
  INSTITUTION = {University of Southampton},
  DATE = {2000-10},
  PAGES = {45--},
  TITLE = {Control Issues in Partial Deduction: The Ever Ending Story},
  TYPE = {techreport},
}

@INPROCEEDINGS{LeLe00_53,
  ABSTRACT = {In recent work it has been shown that infinite state model checking can be performed by a combination of partial deduction of logic programs and abstract interpretation. It has also been shown that partial deduction is powerful enough to mimic certain algorithms to decide coverability properties of Petri nets. These algorithms are forward algorithms and hard to scale up to deal with more complicated systems. Recently, it has been proposed to use a backward algorithm scheme instead. This scheme is applicable to so--called well--structured transition systems and was successfully used, e.g., to solve coverability problems for reset Petri nets. In this paper, we discuss how partial deduction can mimic many of these backward algorithms as well. We prove this link in particular for reset Petri nets and Petri nets with transfer and doubling arcs. We thus establish a surprising link between algorithms in Petri net theory and program specialisation, and also shed light on the power of using logic program specialisation for infinite state model checking.},
  AUTHOR = {Leuschel, Michael and Lehmann, Helko},
  EDITOR = {Lloyd, John and Dahl, Verónica and Furbach, Ulrich and Kerber, Manfred and Lau, Kung-Kiu and Palamidessi, Catuscia and Pereira, Luı́s Moniz and Sagiv, Yehoshua and Stuckey, Peter J.},
  PUBLISHER = {Springer-Verlag},
  BOOKTITLE = {Computational Logic},
  DATE = {2000-07},
  ISBN = {3-540-67797-6},
  PAGES = {101--115},
  SERIES = {Lecture Notes in Computer Science},
  TITLE = {Coverability of Reset Petri Nets and other Well-Structured Transition Systems by Partial Deduction},
  VOLUME = {1861},
}

@INPROCEEDINGS{LeLe00_54,
  ABSTRACT = {In recent work it has been shown that infinite state model checking can be performed by a combination of partial deduction of logic programs and abstract interpretation. This paper focuses on one particular class of problem--coverability for (infinite state) Petri nets--and shows how existing techniques and tools for declarative programs can be successfully applied. In particular, we show that a restricted form of partial deduction is already powerful enough to decide all coverability properties of Petri Nets. We also prove that two particular instances of partial deduction exactly compute the Karp-Miller tree as well as Finkel's minimal coverability set. We thus establish an interesting link between algorithms for Petri nets and logic program specialisation.},
  AUTHOR = {Leuschel, Michael and Lehmann, Helko},
  EDITOR = {Gabbrielli, Maurizio and Pfenning, Frank},
  PUBLISHER = {ACM Press},
  BOOKTITLE = {PPDP},
  DATE = {2000-09},
  PAGES = {268--279},
  TITLE = {Solving Coverability Problems of Petri Nets by Partial Deduction},
}

@PROCEEDINGS{PoRaUl00_55,
  ABSTRACT = {The aim of this workshop is to bring together researchers working on the interplay between verification techniques (e.g., model checking, reduction, and abstraction) and logic programming techniques (e.g., constraints, abstract interpretation, program transformation).},
  EDITOR = {Leuschel, Michael and Podelski, Andreas and Ramakrishnan, C.R. and Ultes-Nitsche, Ulrich},
  DATE = {2000-07},
  PAGES = {150--},
  TITLE = {Proceedings of the Workshop on Verification and Computational Logic VCL'2000},
}

@INPROCEEDINGS{AdLe01_42,
  ABSTRACT = {In recent years, methods for analyzing and parallelizing sequential code using data analysis and loop transformations have been developed. These techniques have proved remarkably successful, and have been used to move from sequential to parallel codes, or to improve efficiency of existing parallel codes. Our research focuses on Fortran code optimisation for parallelisation in Shared Memory architectures by using data analysis and loop source-to-source transformations. Our optimisation strategy, although designed for OpenMP directives, is sufficiently general to be used for pure Fortran code. Our algorithm has been implemented as a tool called Automatic Guidance Module (AGM), and have received high evaluation scores from our industrial partners},
  AUTHOR = {Adhianto, Laksono and Leuschel, Michael},
  BOOKTITLE = {Proceedings of ISSM},
  DATE = {2001-08},
  TITLE = {Strategy for Improving Memory Locality Reuse and Exploiting Hidden Parallelism},
}

@ARTICLE{GlHaLeMa01_43,
  AUTHOR = {Glaser, Hugh and Hartel, Pieter H. and Leuschel, Michael and Martin, Andrew},
  EDITOR = {Kent, Allen and Williams, James G},
  PUBLISHER = {Marcel Dekker Inc},
  DATE = {2001},
  ISBN = {0-8247-2726-6},
  JOURNALTITLE = {Encyclopaedia of Microcomputers},
  PAGES = {79--102},
  TITLE = {Declarative Languages in Education},
  VOLUME = {27},
}

@INPROCEEDINGS{Le01_44,
  ABSTRACT = {We describe practical experiences of using a logic programming based approach to model and reason about concurrent systems. We argue that logic programming is a good foundation for developing, prototyping, animating new specification languages. In particular, we present the new high-level specification language CSP(LP), unifying CSP with concurrent (constraint) logic programming, and which can be used to formally reason both about logical and concurrent aspects of critical systems.},
  AUTHOR = {Leuschel, Michael},
  PUBLISHER = {Springer},
  BOOKTITLE = {PADL},
  DATE = {2001-10},
  ISBN = {3-540-41768-0},
  ISSN = {0302-9743},
  PAGES = {14--28},
  SERIES = {Lecture Notes in Computer Science},
  TITLE = {Design and Implementation of the High-Level Specification Language {CSP(LP)}},
  VOLUME = {1990},
}

@INPROCEEDINGS{LeAdBuFeMi01_45,
  ABSTRACT = {We describe practical experiences of using a logic programming based approach to model and reason about critical systems. We argue that logic programming with co-routining, constraints, and tabling is a good foundation for developing, animating, and model checking new specification languages. We present animators and model checkers currently being developed for two different extensions of CSP and for the B method.},
  AUTHOR = {Leuschel, Michael and Adhianto, Laksono and Butler, Michael and Ferreira, Carla and Mikhailov, Leonid},
  EDITOR = {Leuschel, Michael and Podelski, Andreas and Ramakrishnan, C.R. and Ultes-Nitsche, Ulrich},
  BOOKTITLE = {Proceedings of the ACM Sigplan Workshop on Verification and Computational Logic},
  DATE = {2001-09},
  PAGES = {97--109},
  TITLE = {Animation and Model Checking of {CSP} and {B} using {Prolog} Technology},
}

@INPROCEEDINGS{LeMaCu01_46,
  ABSTRACT = {We study the possibility of doing LTL model checking on CSP specifications in the context of refinement. We present evidence that the refinement-based approach to verification does not seem to be very well suited for verifying certain temporal properties. To remedy this problem, we show how to (and how not to) perform LTL model checking of CSP processes using refinement checking in general and the FDR tool in particular. We show how one can handle (potentially) deadlocking systems, discuss the validity of our approach for infinite state systems, and shed light on the relationship between ``classical'' model checking and refinement checking.},
  AUTHOR = {Leuschel, Michael and Massart, Thierry and Currie, Andrew},
  EDITOR = {J.N. Oliviera, P. Zave},
  PUBLISHER = {Springer-Verlag},
  BOOKTITLE = {Proceedings FME'2001},
  DATE = {2001-03},
  PAGES = {99--118},
  TITLE = {How to make FDR Spin: LTL model checking of CSP using Refinement},
}

@PROCEEDINGS{LePoRaUl01_47,
  EDITOR = {Leuschel, Michael and Podelski, Andreas and Ramakrishnan, C.R. and Ultes-Nitsche, Ulrich},
  DATE = {2001-09},
  TITLE = {Proceedings of the ACM Sigplan Workshop on Verification and Computational Logic VCL'2001},
}

@INPROCEEDINGS{LeWoMaAd01_48,
  ABSTRACT = {We study the possibility of doing LTL model checking on CSP specifications in the context of refinement. We present a technique to perform LTL model checking of CSP processes using refinement checking in general and the FDR tool in particular. We present a tool which automates the translation process from LTL model checking to CSP refinement. Also, if time permits, we will present another tool which uses latest generation Prolog technology to symbolically animate, compile, and model check CSP specifications.},
  AUTHOR = {Leuschel, Michael and Wolton, Ivan and Massart, Thierry and Adhianto, Laksono},
  EDITOR = {Nowak, David},
  PUBLISHER = {Oxford University Computing Laboratory},
  BOOKTITLE = {AVoCS 2001},
  DATE = {2001-04},
  TITLE = {Temporal Logic Model Checking of {CSP}: Tools and Techniques},
}

@THESIS{Ha01_301,
  ABSTRACT = {We introduce the probabilistic action system formalism which combines refinement with performance. Performance is expressed by means of probability and expected costs. Probability is needed to express uncertainty present in physical environments. Expected costs express physical or abstract quantities that describe a system. They encode the performance objective. The behaviour of probabilistic action systems is described by traces of expected costs. Corresponding notions of refinement and simulation-based proof rules are introduced. Formal notations like B or action systems support a notion of refinement. Refinement relates an abstract specification AA to a more deterministic concrete specification CC. Knowing AA and CC one proves CC refines, or implements, specification AA. In this study we consider specification AA as given and concern ourselves with a way to find a good candidate for implementation CC. To this end we classify all implementations of an abstract specification according to their performance. The performance of a specification AA is a value val.AA associated with some optimal behaviour it may exhibit. We distinguish performance from correctness. Concrete systems that do not meet the abstract specification are excluded. Only the remaining correct implementations CC are considered with respect to their performance. A good implementation of a specification is identified by having some optimal behaviour in common with it. In other words, a good refinement corresponds to a reduction of non-optimal behaviour. This also means that the abstract specification sets a boundary val.AA for the performance of any implementation. An implementation may perform worse than its specification but never better. Probabilistic action systems are based on discrete-time Markov decision processes. Numerical methods solving the optimisation problems posed by Markov decision processes are well-known, and used in a software tool that we have developed. The tool computes an optimal behaviour of a specification AA, and the associated value val.AA, thus assisting in the search for a good implementation CC. We present examples and case studies to demonstrate the use of probabilistic action systems.},
  AUTHOR = {Hallerstede, Stefan},
  INSTITUTION = {Electronics and Computer Science, University of Southampton},
  DATE = {2001},
  TITLE = {Performance-Oriented Refinement},
  TYPE = {phdthesis},
}

@REPORT{LeLe02_36,
  ABSTRACT = {Ecce is a partial deduction system which can be used to automatically generate abstractions for the model checking of many infinite state systems. We show that to verify the abstractions generated by Ecce we may employ the proof assistant Isabelle. Thereby Ecce is used to generate the specification, hypotheses and proof script in Isabelle's theory format. Then, in many cases, Isabelle can automatically execute these proof scripts and thereby verify the soundness of Ecce's abstraction. In this work we focus on the specification and verification of Petri nets.},
  AUTHOR = {Lehmann, Helko and Leuschel, Michael},
  INSTITUTION = {ECS, University of Southampton},
  DATE = {2002-09},
  NUMBER = {DSSE-TR-2002-02},
  TITLE = {Generating inductive verification proofs for {Isabelle} using the partial evaluator {Ecce}},
  TYPE = {techreport},
}

@INPROCEEDINGS{Le02_37,
  ABSTRACT = {Well-quasi orders in general, and homeomorphic embedding in particular, have gained popularity to ensure the termination of techniques for program analysis, specialisation, transformation, and verification. In this paper we survey and discuss this use of homeomorphic embedding and clarify the advantages of such an approach over one using well-founded orders. We also discuss various extensions of the homeomorphic embedding relation. We conclude with a study of homeomorphic embedding in the context of metaprogramming, presenting some new (positive and negative) results and open problems.},
  AUTHOR = {Leuschel, Michael},
  EDITOR = {Torben Mogensen, David Schmidt, I. H. Sudborough},
  PUBLISHER = {Springer-Verlag},
  BOOKTITLE = {The Essence of Computation -- Essays dedicated to Neil Jones},
  DATE = {2002},
  ISBN = {3-540-00326-6},
  PAGES = {379--403},
  SERIES = {Lecture Notes in Computer Science},
  TITLE = {Homeomorphic Embedding for Online Termination of Symbolic Methods},
  VOLUME = {2566},
}

@ARTICLE{LeBr02_38,
  ABSTRACT = {Program specialisation aims at improving the overall performance of programs by performing source to source transformations. A common approach within functional and logic programming, known respectively as partial evaluation and partial deduction, is to exploit partial knowledge about the input. It is achieved through a well-automated application of parts of the Burstall-Darlington unfold/fold transformation framework. The main challenge in developing systems is to design automatic control that ensures correctness, efficiency, and termination. This survey and tutorial presents the main developments in controlling partial deduction over the past 10 years and analyses their respective merits and shortcomings. It ends with an assessment of current achievements and sketches some remaining research challenges.},
  AUTHOR = {Leuschel, Michael and Bruynooghe, Maurice},
  PUBLISHER = {Cambridge University Press},
  DATE = {2002-07},
  ISSN = {1471-0684},
  JOURNALTITLE = {Theory and Practice of Logic Programming},
  NUMBER = {4--5},
  PAGES = {461--515},
  TITLE = {Logic program specialisation through partial deduction: Control Issues},
  VOLUME = {2},
}

@INPROCEEDINGS{LeGr02_39,
  ABSTRACT = {We present an abstract partial deduction technique which uses regular types as its domain and which can handle conjunctions, and thus perform deforestation and tupling. We provide a detailed description of all the required operations and present an implementation within the Ecce system. We discuss the power of this new specialisation algorithm, especially in the light of verifying and specialising infinite state process algebras. Here, our new algorithm can provide a more precise treatment of synchronisation and can be used for refinement checking. Paper Available: http://link.springer.de/link/service/series/0558/tocs/t2372.htm#toc2372},
  AUTHOR = {Leuschel, Michael and Gruner, Stefan},
  EDITOR = {Pettorossi, Alberto},
  PUBLISHER = {Springer-Verlag},
  BOOKTITLE = {LOPSTR},
  DATE = {2002},
  ISBN = {3-540-43915-3},
  PAGES = {91--110},
  SERIES = {Lecture Notes in Computer Science},
  TITLE = {Abstract Conjunctive Partial Deduction using Regular Types and its Application to Model Checking},
  VOLUME = {2372},
}

@INPROCEEDINGS{LeMa02_40,
  ABSTRACT = {In earlier work it has been shown that finite state CTL model checking of reactive systems can be achieved by a relatively simple interpreter written in tabled logic programming.<br/> This approach is flexible in the sense that various specification formalisms can be easily targeted (e.g., Petri nets, CSP, ...). Moreover, infinite state CTL model checking can be performed by analysing this interpreter using a combination of partial deduction and abstract interpretation. It has also been shown that this approach is powerful enough to decide coverability properties of various kinds of Petri nets. <br/> In this ongoing work, we are empirically evaluating these approaches on various case studies of finite, parameterised and infinite systems. For finite state systems, we show how our approach and tool compares to standard tools for finite state model checking For parameterised or infinite state model checking, we are comparing our results with, e.g., XMC, Hytech.},
  AUTHOR = {Leuschel, Michael and Massart, Thierry},
  EDITOR = {Norman, Gethin and Kwiatkowska, Martha and Guelev, Dimitar},
  PUBLISHER = {University of Birmingham},
  BOOKTITLE = {AVoCS},
  DATE = {2002},
  PAGES = {143--149},
  TITLE = {Logic programming and partial deduction for the verification of reactive systems: An experimental evaluation},
}

@INPROCEEDINGS{VaAlLe02_41,
  AUTHOR = {Varea, Mauricio and Al-Hashimi, Bashir and Leuschel, Michael},
  BOOKTITLE = {AVoCS},
  DATE = {2002-04},
  PAGES = {265--269},
  TITLE = {Finite and Infinite Model Checking of Dual Transition Petri Net Models},
}

@PROCEEDINGS{02_100,
  EDITOR = {Leuschel, Michael},
  DATE = {2002},
  ISBN = {3-540-40438-4},
  ISSN = {0302-9743},
  SERIES = {Lecture Notes in Computer Science},
  TITLE = {Logic Based Program Synthesis and Transformation, Proceedings of LOPSTR'02, Revised Selected Papers},
  VOLUME = {2664},
}

@PROCEEDINGS{02_101,
  EDITOR = {Leuschel, Michael and Ultes-Nitsche, Ulrich},
  DATE = {2002},
  TITLE = {Proceedings of the ACM Sigplan International Workshop on Verification and Computational Logic (VCL'2002)},
}

@INPROCEEDINGS{Ha02_293,
  ABSTRACT = {Stepwise refinement transforms an abstract specification into a more deterministic concrete specification. Ultimately one arrives at a specification that is implementable. At the various stages in the refinement process decisions are made that determine how the final implementation operates. Different implementations can be compared with respect to their expected performance within their environment. In this sense refinement poses an optimisation problem. We present a B-based language and a tool that can assist in solving this optimisation problem.},
  AUTHOR = {Hallerstede, Stefan and Butler, Michael},
  BOOKTITLE = {RCS '02: International Workshop on Refinement of Critical Systems: Methods, Tools and Experience},
  DATE = {2002},
  TITLE = {A Performance-oriented Refinement Assistant},
}

@INPROCEEDINGS{AuFeGrLeNG03_24,
  AUTHOR = {Augusto, Juan Carlos and Ferreira, Carla and Gravell, Andy M. and Leuschel, Michael and Ng, Karen M.Y.},
  EDITOR = {Jeusfeld, Manfred A. and Pastor, Oscar},
  PUBLISHER = {Springer Verlag},
  BOOKTITLE = {ER (Workshops)},
  DATE = {2003},
  ISBN = {3-540-20257-9},
  PAGES = {17--28},
  SERIES = {Lecture Notes in Computer Science},
  TITLE = {The Benefits of Rapid Modelling for E-Business System Development},
  VOLUME = {2814},
}

@INPROCEEDINGS{AuLeBuFe03_25,
  AUTHOR = {Augusto, Juan Carlos and Leuschel, Michael and Butler, Michael and Ferreira, Carla},
  EDITOR = {Leuschel, Michael and Gruner, Stefan and Presti, Stephane Lo},
  BOOKTITLE = {AVoCS},
  DATE = {2003},
  PAGES = {253--266},
  TITLE = {Using the Extensible Model Checker {XTL} to Verify {StAC} Business Specifications},
}

@ARTICLE{BuLeLoAlBeBoCuKi03_26,
  ABSTRACT = {We present a scheme for highlighting the trust issues of merit within pervasive computing, based on an analysis of scenarios from the healthcare domain. The first scenario helps us define an analysis grid, where the human and technical aspects of trust are considered. The analysis is applied to a second scenario to examine its suitability. We then discuss the various categories of the analysis grid in the light of this examination and of the literature on the subject of trust. We believe that this approach could form the basis of a generalised trust analysis framework to support the design, procurement and use of pervasive computing. (The PDF is an extended version of the paper.)},
  AUTHOR = {Butler, Michael and Leuschel, Michael and Presti, Stephane Lo and Allsopp, David and Beautement, Patrick and Booth, Chris and Cusack, Mark and Kirton, Mike},
  DATE = {2003},
  JOURNALTITLE = {IEEE Computing},
  NUMBER = {3},
  TITLE = {Towards a Trust Analysis Framework for Pervasive Computing Scenarios},
  VOLUME = {2},
}

@INPROCEEDINGS{CrLe03_27,
  ABSTRACT = {The Cogen approach to program specialisation, writing a compiler generator instead of a specialiser, has been used with considerable success. This paper demonstrates that the Cogen approach is also applicable to the specialisation of constraint logic programs and leads to effective specialisers. We present the basic specialisation technique for CLP(Q) programs and show how we can handle non-declarative features as well. We present an implemented system along with experimental results.},
  AUTHOR = {Craig, Stephen and Leuschel, Michael},
  EDITOR = {Broy, M. and Zamulin, A.},
  PUBLISHER = {Springer-Verlag},
  BOOKTITLE = {Ershov Memorial Conference},
  DATE = {2003},
  SERIES = {Lecture Notes in Computer Science},
  TITLE = {A Compiler Generator for Constraint Logic Programs},
  VOLUME = {2890},
}

@INPROCEEDINGS{DBLP:conf/gpce/ElphickLC03,
  ABSTRACT = {We describe the problems associated with the creation of high performance code for mathematical computations. We discuss the advantages and disadvantages of using a high level language like MATLAB and then propose partial evaluation as a way of lessening the disadvantages at little cost. We then go on to describe the design of a partial evaluator for MATLAB and present results showing what performance increases can be achieved and the circumstances in which partial evaluation can provide these.},
  AUTHOR = {Elphick, Daniel and Leuschel, Michael and Cox, Simon J.},
  URL = {http://dx.doi.org/10.1007/978-3-540-39815-8_21},
  BOOKTITLE = {Generative Programming and Component Engineering, Second International Conference, {GPCE} 2003, Erfurt, Germany, September 22-25, 2003, Proceedings},
  CROSSREF = {DBLP:conf/gpce/2003},
  DATE = {2003},
  DOI = {10.1007/978-3-540-39815-8_21},
  PAGES = {344--363},
  TITLE = {Partial Evaluation of {MATLAB}},
}

@PROCEEDINGS{DBLP:conf/gpce/2003,
  EDITOR = {Pfenning, Frank and Smaragdakis, Yannis},
  PUBLISHER = {Springer},
  DATE = {2003},
  ISBN = {3-540-20102-5},
  SERIES = {Lecture Notes in Computer Science},
  TITLE = {Generative Programming and Component Engineering, Second International Conference, {GPCE} 2003, Erfurt, Germany, September 22-25, 2003, Proceedings},
  VOLUME = {2830},
}

@INPROCEEDINGS{LeLe03_30,
  ABSTRACT = {In this paper we discuss the similarities between program specialisation and inductive theorem proving, and then show how program specialisation can be used to perform inductive theorem proving. We then study this relationship in more detail for a particular class of problems (verifying infinite state Petri nets) in order to establish a clear link between program specialisation and inductive theorem proving. In particular, we use the program specialiser Ecce to generate specifications, hypotheses and proof scripts in the theory format of the proof assistant Isabelle. Then, in many cases, Isabelle can automatically execute these proof scripts and thereby verify the soundness of Ecce's verification process and of the correspondence between program specialisation and inductive theorem proving.},
  AUTHOR = {Lehmann, Helko and Leuschel, Michael},
  EDITOR = {Bruynooghe, Maurice},
  PUBLISHER = {Springer-Verlag},
  BOOKTITLE = {LOPSTR},
  DATE = {2003},
  ISBN = {3-540-22174-3},
  PAGES = {1--19},
  SERIES = {Lecture Notes in Computer Science},
  TITLE = {Inductive Theorem Proving by Program Specialisation: Generating proofs for {Isabelle} using {Ecce} (Invited talk)},
  VOLUME = {3018},
}

@INPROCEEDINGS{LeBu03_32,
  ABSTRACT = {We present ProB, an animation and model checking tool for the B method. ProB's animation facilities allow users to gain confidence in their specifications, and unlike the animator provided by the B-Toolkit, the user does not have to guess the right values for the operation arguments or choice variables. ProB contains a model checker and a constraint-based checker, both of which can be used to detect various errors in B specifications. We present our first experiences in using ProB on several case studies, highlighting that ProB enables users to uncover errors that are not easily discovered by existing tools.},
  AUTHOR = {Leuschel, Michael and Butler, Michael},
  EDITOR = {Keijiro, Araki and Gnesi, Stefania and Dino, Mandrio},
  PUBLISHER = {Springer-Verlag},
  BOOKTITLE = {FME},
  DATE = {2003},
  ISBN = {3-540-40828-2},
  PAGES = {855--874},
  SERIES = {Lecture Notes in Computer Science},
  TITLE = {{ProB}: A Model Checker for {B}},
  VOLUME = {2805},
}

@REPORT{LeCrBrVa03_33,
  ABSTRACT = {We present the latest version of the logen partial evaluation system for logic programs. In particular we present new binding-types, and show how they can be used to effectively specialise a wide variety of interpreters.We show how to achieve Jones-optimality in a systematic way for several interpreters. Finally, we present and specialise a non-trivial interpreter for a small functional programming language. Experimental results are also presented, highlighting that the logen system can be a good basis for generating compilers for high-level languages.},
  AUTHOR = {Leuschel, Michael and Craig, Stephen and Bruynooghe, Maurice and Vanhoof, Wim},
  INSTITUTION = {ECS, University of Southampton},
  DATE = {2003-11},
  NUMBER = {DSSE-TR-2003-5},
  TITLE = {Specializing Interpreters using Offline Partial Deduction},
  TYPE = {techreport},
}

@PROCEEDINGS{LeGrLo03_34,
  ABSTRACT = {The aim of this workshop is to foster a research community in verification in and beyond the United Kingdom of Great Britain through encouraging communication among researchers. Specific objectives include efforts at integration as well as the transfer of methods between different groups from academia and industry. The topics are to be interpreted broadly and inclusively, and in particular cover all aspects of verification (model checking, theorem proving, specification and refinement proofs, etc) pertaining to various types of critical systems, be it safety-critical, business-critical, or performance-critical.<br/> The first meeting, AVoCS'01, was held in Oxford (UK), continuing in the tradition of the annual DERA/OUCL series. The second meeting, AVoCS'02, was held in Birmingham (UK). <br/> Similarly to previous years, the meeting will be informal, and will combine invited lectures with accepted submissions. This year we also want to aim for wider, European and international attention.<br/> Available online at: http://www.ecs.soton.ac.uk/~mal/avocs03/},
  EDITOR = {Leuschel, Michael and Gruner, Stefan and Presti, Stephane Lo},
  DATE = {2003-04},
  TITLE = {Proceedings of the 3rd Workshop on Automated Verification of Critical Systems (AVoCS'03)},
}

@INPROCEEDINGS{VaLeAl03_35,
  ABSTRACT = {Compositional Verification is a viable way to tackle the state explosion problem. However, the decomposition of a system into smaller parts is not a trivial problem, and dividing the specification into modules can be regarded as one of the main issues that concerns a compositional approach. This paper concentrates on the application of compositional verification to state-based models, in order to reduce the number of nodes assigned to memory, thus avoiding state explosion and speeding up the verification. Furthermore, we investigate and propose an estimation method that improves the compositional verification process in modular designs, such that the amount of memory required by the process is minimised. This method has been applied to a real-life embedded system, producing meaningful results without the need of data abstraction.},
  AUTHOR = {Varea, Mauricio and Leuschel, Michael and Al-Hashimi, Bashir},
  LOCATION = {Turku, Finland},
  BOOKTITLE = {Refinement of Critical Systems},
  DATE = {2003},
  TITLE = {Improving Compositional Verification of State-based Models by Reducing Modular Unbalance},
}

@PROCEEDINGS{03_99,
  ABSTRACT = {This volume contains the papers presented at PEPM'03, the ACM SIGPLAN Workshop on Partial Evaluation and Semantics-Based Program Manipulation. PEPM'03 was held June 7th 2003 in San Diego, California in conjunction with the Programming Language Design and Implementation conference PLDI'03 as part of the Federated Computing Research Conference FCRC 2003. Due to organizational constraints, PEPM'03 had to be held on a single day, restricting the number of talks that could be presented.Papers were judged on their appropriateness for the workshop, their originality, technical strength and clarity. One submission was deemed outside the scope of PEPM, and all the other submissions were reviewed by at least 3 referees, with some help from the following outside reviewers: Elvira Albert, Stephen Craig, Santiago Escobar, and Carla Piazza. The PC meeting was electronic and resulted in 8 submissions being judged of conference quality' and selected for presentation at the workshop and inclusion in the proceedings.},
  EDITOR = {Leuschel, Michael},
  PUBLISHER = {ACM Press},
  DATE = {2003},
  ISBN = {1-58113-667-6},
  TITLE = {Proceedings of the 2003 ACM SIGPLAN Workshop on Partial Evaluation and Semantics-Based Program Manipulation (PEPM'03)},
}

@INPROCEEDINGS{Ha03_288,
  ABSTRACT = {We present the design of a parallel synchronous hardware component from a purely functional description of its behaviour. Starting from an abstract specification of a linear time-invariant (LTI) system in Event-B a pipelined implementation is developed. The presented approach is applicable to LTI systems that can be represented as linear constant-coefficient difference equations.},
  AUTHOR = {Hallerstede, Stefan},
  PUBLISHER = {Springer-Verlag},
  BOOKTITLE = {ZB 2003},
  DATE = {2003},
  PAGES = {101--102},
  TITLE = {Parallel Hardware Design in B},
}

@ARTICLE{Ha03_289,
  ABSTRACT = {We use the B formalism to derive functionally correct synchronous circuits. To represent the circuit we employ the hardware description language VHDL. This article outlines the development of a circuit design starting from an initial abstract functional specification of a system component. We discuss some topics involved in the translation to synthesisable VHDL and demonstrate the approach by way of an example.},
  AUTHOR = {Hallerstede, Stefan},
  EDITOR = {Villar, Eugenio and Mermet, Jean},
  PUBLISHER = {Kluwer},
  DATE = {2003},
  JOURNALTITLE = {System Specification & Design Languages - Best of FDL '02},
  PAGES = {315--325},
  TITLE = {Specification and Refinement of Hardware Components in B},
}

@INPROCEEDINGS{BaLeVa04_13,
  ABSTRACT = {We describe the use of a flexible meta-interpreter for performing access control checks on deductive databases. The meta-program is implemented in Prolog and takes as input a database and an access policy specification. We then proceed to specialise the meta-program for a given access policy and intensional database by using the Logen partial evaluation system. In addition to describing the programs involved in our approach, we give a number of performance measures for our implementation of an access control checker, and we discuss the implications of using this approach for access control on deductive databases. In particular, we show that by using our approach we get flexible access control with virtually zero overhead.},
  AUTHOR = {Barker, Steve and Leuschel, Michael and Varea, Mauricio},
  EDITOR = {Heintze, Nevin and Sestoft, Peter},
  PUBLISHER = {ACM Press},
  BOOKTITLE = {PEPM},
  DATE = {2004},
  ISBN = {1-58113-835-0},
  PAGES = {190--119},
  TITLE = {Efficient and Flexible Access Control via Logic Program Specialisation},
}

@INPROCEEDINGS{BuLeLoTu04_14,
  ABSTRACT = {Security and trust are two properties of modern computing systems that are thefocus of much recent interest. They play an increasingly significant role in the requirements for modern computing systems. Security has been studied thoroughly for many years, particularly the sub-domain of cryptography. The use of computing science formal methods has facilitated cryptanalysis of security protocols. At the moment, trust is intensively studied, but not well understood. Here we present our approach based on formal methods for modelling and validating the notion of trust in computing science.},
  AUTHOR = {Butler, Michael and Leuschel, Michael and Presti, Stephane Lo and Turner, Phillip},
  EDITOR = {Jensen, Christian and Poslad, Stefan and Dimitrakos, Theo},
  PUBLISHER = {Springer-Verlag},
  BOOKTITLE = {iTrust},
  DATE = {2004},
  ISBN = {3-540-21312-0},
  PAGES = {333--339},
  SERIES = {Lecture Notes in Computer Science},
  TITLE = {The Use of Formal Methods in the Analysis of Trust (Position Paper)},
  VOLUME = {2995},
}

@INPROCEEDINGS{CrGaLeHe04_15,
  ABSTRACT = {Offline partial evaluation techniques rely on an annotated version of the source program to control the specialisation process. These annotations guide the specialisation and have to ensure termination of the partial evaluation. We present an algorithm for generating these annotations automatically. The algorithm uses state-of-the-art termination analysis techniques, combined with a new type-based abstract interpretation for propagating the binding types. This algorithm has been implemented as part of the Logen partial evaluation system, and we report on performance of the algorithm on a series of benchmarks.},
  AUTHOR = {Craig, Stephen and Gallagher, John and Leuschel, Michael and Henriksen, Kim S.},
  EDITOR = {Etalle, Sandro},
  PUBLISHER = {Springer-Verlag},
  BOOKTITLE = {LOPSTR},
  DATE = {2004},
  ISBN = {3-540-26655-0},
  PAGES = {53--68},
  SERIES = {Lecture Notes in Computer Science},
  TITLE = {Fully Automatic Binding Time Analysis for {Prolog}},
  VOLUME = {3573},
}

@INPROCEEDINGS{CrLe04_16,
  ABSTRACT = {This paper presents a self-applicable partial evaluator for a considerable subset of full Prolog. The partial evaluator is shown to achieve non-trivial specialisation and be effectively self-applied. The attempts to self-apply partial evaluators for logic programs have, of yet, not been all that successful. Compared to earlier attempts, our LIX system is practically usable in terms of efficiency and can handle natural logic programming examples with partially static data structures, built-ins, side-effects, and some higher-order and meta-level features such as call and findall.<br/> The LIX system is derived from the development of the LOGEN compiler generator system. It achieves a similar kind of efficiency and specialisation, but can be used for other applications. Notably, we show first attempts at using the system for deforestation and tupling in an offline fashion. We will demonstrate that, contrary to earlier beliefs, declarativeness and the use of the ground representation is not the best way to achieve self-applicable partial evaluators.},
  AUTHOR = {Craig, Stephen and Leuschel, Michael},
  EDITOR = {Kameyama, Yukiyoshi and Stuckey, Peter J.},
  PUBLISHER = {Springer-Verlag},
  BOOKTITLE = {FLOPS},
  DATE = {2004},
  PAGES = {85--99},
  TITLE = {{Lix}: An Effective Self-applicable Partial Evaluator for {Prolog}},
}

@ARTICLE{Le04_17,
  ABSTRACT = {Recently the relationship between abstract interpretation and program specialization has received a lot of scrutiny, and the need has been identified to extend program specialization techniques so to make use of more refined abstract domains and operators. This paper clarifies this relationship in the context of logic programming, by expressing program specialization in terms of abstract interpretation. Based on this, a novel specialization framework, along with generic correctness results for computed answers and finite failure under SLD-resolution, is developed.<br/> This framework can be used to extend existing logic program specialization methods, such as partial deduction and conjunctive partial deduction, to make use of more refined abstract domains. It is also shown how this opens up the way for new optimizations. Finally, as shown in the paper, the framework also enables one to prove correctness of new or existing specialization techniques in a simpler manner.<br/> The framework has already been applied in the literature to develop and prove correct specialization algorithms using regular types, which in turn have been applied to the verification of infinite state process algebras.},
  AUTHOR = {Leuschel, Michael},
  PUBLISHER = {ACM},
  DATE = {2004-05},
  JOURNALTITLE = {ACM Transactions on Programming Languages and Systems (TOPLAS)},
  NUMBER = {3},
  PAGES = {413--463},
  TITLE = {A Framework for the Integration of Partial Evaluation and Abstract Interpretation of Logic Programs},
  VOLUME = {26},
}

@INPROCEEDINGS{Le04_18,
  ABSTRACT = {The development of formal models is often a key step when developing safety or mission critical software. In this setting it is vital to formally check and validate these formal models before translating them into code. I will present ProB, a toolset for the B method which was developed using constraint logic programming technology. ProB allows fully automatic animation of B models, and can be used to systematically check a B model for errors. ProB supports B features such as non-deterministic operations, ANY statements, operations with complex arguments, sets, sequences, functions, lambda abstractions, set comprehensions, constants and properties, and many more. ProB's animation facilities allow users to gain confidence in their specifications, and unlike other animators, the user does not have to guess the right values for the operation arguments or choice variables. This is achieved by using co-routining and finite domain constraint solving. On top of the animation features, ProB contains a temporal model checker and a constraint-based model checker, both of which can be used to detect various errors in B specifications.},
  AUTHOR = {Leuschel, Michael},
  EDITOR = {Mesnard, Fred},
  PUBLISHER = {Hermes Science Publications, Lavoisier},
  BOOKTITLE = {JFPLC},
  DATE = {2004},
  ISBN = {2-7462-0937-3},
  PAGES = {13--13},
  TITLE = {{ProB}: Un outil de modélisation formelle (Invited Talk)},
}

@INPROCEEDINGS{LeCrBrVa04_19,
  ABSTRACT = {We present the latest version of the Logen partial evaluation system for logic programs. In particular we present new binding-types, and show how they can be used to effectively specialise a wide variety of interpreters.We show how to achieve Jones-optimality in a systematic way for several interpreters. Finally, we present and specialise a non-trivial interpreter for a small functional programming language. Experimental results are also presented, highlighting that the Logen system can be a good basis for generating compilers for high-level languages.},
  AUTHOR = {Leuschel, Michael and Craig, Stephen and Bruynooghe, Maurice and Vanhoof, Wim},
  EDITOR = {Bruynooghe, Maurice and Lau, Kung-Kiu},
  PUBLISHER = {Springer-Verlag},
  BOOKTITLE = {Program Development in Computational Logic},
  DATE = {2004-11},
  PAGES = {341--376},
  SERIES = {Lecture Notes in Computer Science},
  TITLE = {Specializing Interpreters using Offline Partial Deduction},
  VOLUME = {3049},
}

@ARTICLE{LeJoVaBr04_20,
  ABSTRACT = {The so called "cogen" approach'' to program specialisation, writing a compiler generator instead of a specialiser, has been used with considerable success in partial evaluation of both functional and imperative languages. This paper demonstrates that the "cogen" approach is also applicable to the specialisation of logic programs (called partial deduction when applied to pure logic programs) and leads to effective specialisers. Moreover, using good binding-time annotations, the speed-ups of the specialised programs are comparable to the speed-ups obtained with online specialisers.<br/> The paper first develops a generic approach to offline partial deduction and then a specific offline partial deduction method, leading to the offline system LIX for pure logic programs. While this is a usable specialiser by itself, its specialisation strategy is used to develop the "cogen" system LOGEN. Given a program, a specification of what inputs will be static, and an annotation specifying which calls should be unfolded, LOGEN generates a specialised specialiser for the program at hand. Running this specialiser with particular values for the static inputs results in the specialised program. While this requires two steps instead of one, the efficiency of the specialisation process is improved in situations where the same program is specialised multiple times.<br/> The paper also presents and evaluates an automatic binding-time analysis that is able to derive the annotations. While the derived annotations are still suboptimal compared to hand-crafted ones, they enable non-expert users to use the LOGEN system in a fully automated way.<br/> Finally, LOGEN is extended so as to directly support a large part of Prolog's declarative and non-declarative features and so as to be able to perform so called mixline specialisations. In mixline specialisation some unfolding decisions depend on the outcome of tests performed at specialisation time instead of being hardwired into the specialiser.},
  AUTHOR = {Leuschel, Michael and J{ø}rgensen, Jesper and Vanhoof, Wim and Bruynooghe, Maurice},
  PUBLISHER = {Cambridge University Press},
  DATE = {2004},
  JOURNALTITLE = {TPLP},
  NUMBER = {1--2},
  PAGES = {139--191},
  TITLE = {Offline Specialisation in {Prolog} Using a Hand-Written Compiler Generator},
  VOLUME = {4},
}

@REPORT{LeTu04_21,
  ABSTRACT = {ProB is an animator and model checker for the B method. It also allows to visualise the state space of a B machine in graphical way. This is often very useful and allows users to quickly spot whether the machine behaves as expected. However, for larger state spaces the visualisation quickly becomes difficult to grasp by users (and the computation of the graph layout takes considerable time). In this paper we present two relatively simple algorithms to often considerably reduce the complexity of the graphs, while still keeping relevant information. This makes it possible to visualise much larger state spaces and gives the user immediate feedback about the overall behaviour of a machine. The algorithms have been implemented within the ProB toolset and we highlight their potential on several examples. We also conduct a thorough experimentation of the algorithm on 47 B machines and analyse the results.},
  AUTHOR = {Leuschel, Michael and Turner, Edd},
  INSTITUTION = {ECS, University of Southampton},
  DATE = {2004-11},
  TITLE = {Visualising Larger State Spaces in {ProB}},
  TYPE = {techreport},
}

@REPORT{LoBuLeSnTu04_22,
  ABSTRACT = {This report is deliverable WP4-01 of the project ??Trusted Software Agents and Services for Pervasive Information Environments.? The deliverable reports on the activities of formal modelling and verification of a pervasive application which follows from previous results in the project.<br/> The pervasive application is based on several pervasive scenarios already devised and is centred on the user location. This location-based system is first architecturally simplified, while trust requirements are derived from the Trust Analysis Framework presented in the deliverable WP2-01.<br/> This first abstraction is then completed by formal modelling of the system in the B formal method. These models enable us to clarify the decision decisions leading to fulfil the trust requirements. We show that the system policy structure is influenced by the priorities given to the system operations and that a sufficiently high level of abstraction is required to model trust properties.<br/> The modelling activity is completed by formal verification using the ProB model-checker to automate part of this process. Several models are checked successfully, while detection of errors in other models enables us to understand better the behaviour of the system. In particular, issues relative to the dynamicity of modelled elements are highlighted.<br/> The overall methodology followed during these activities proved useful at helping us specifying accurately the trust requirements, so that the pervasive application can be completed in consequence, and is as follows:<br/> 1) Model important features of the system First vaguely type the variables; then write a set of operations corresponding to complementary features while (possibly) modifying the variable types to ease this writing; consider the variables by group of similar dynamic properties;<br/> 2a) Model-check the model<br/> 2a.a) Property violation detected Examine the various aspects of the model (variables, enabled operations, history of operations) to see what part of the property is ??false?; Correct the model accordingly;<br/> 2a.b) No property violation detected Go back to 2a until coverage rate is enough; possible changes to the model include: modify the initialisation to test other situations (in B use ??choice by predicate?); add inconsistencies in the model;<br/> 2b) Animate the model<br/> 2b.a) Execute the desired sequence of operations (validation);<br/> 2b.b) Find an interesting state, then 2a.a or 2a.b applies;<br/> 2b.c) Backtrack from a state where the invariant is violated;<br/> 3) Go back to 1 (complete the model) or refine the model.},
  AUTHOR = {Presti, Stephane Lo and Butler, Michael and Leuschel, Michael and Snook, Colin and Turner, Phillip},
  INSTITUTION = {DSSE, University of Southampton},
  DATE = {2004-06},
  TITLE = {Formal Modelling and Verification of Trust in a Pervasive Application},
  TYPE = {techreport},
}

@INPROCEEDINGS{VaBrLe04_23,
  AUTHOR = {Vanhoof, Wim and Bruynooghe, Maurice and Leuschel, Michael},
  EDITOR = {Bruynooghe, Maurice and Lau, Kung-Kiu},
  PUBLISHER = {Springer-Verlag},
  BOOKTITLE = {Program Development in Computational Logic},
  DATE = {2004},
  ISBN = {3-540-22152-2},
  PAGES = {189--232},
  SERIES = {Lecture Notes in Computer Science},
  TITLE = {Binding-Time Analysis for {Mercury}},
  VOLUME = {3049},
}

@INPROCEEDINGS{FaLe04_29,
  ABSTRACT = {Object Petri nets (OPNs) provide a natural and modular method for the modelling of many real-world systems. We give a structure-preserving translation of OPNs to Prolog, avoiding the need for an unfolding to a flat Petri net. The translation provides support for reference and value semantics, and even allows different objects to be treated as copyable or non-copyable, respectively. The method is developed for OPNs with arbitrary nesting. <br/> We then apply logic programming tools to animate, compile and model check OPNs. In particular, we use the partial evaluation system LOGEN to produce an OPN compiler, and we use the model checker XTL to verify CTL formulas. We also use LOGEN to produce special purpose model checkers. <br/> We present two case studies, along with experimental results. A comparison to OPN translations to MAUDE specifications and model checking is given, showing that our approach is roughly twice as fast for larger systems. We also tackle infinite state model checking using the ECCE system.},
  AUTHOR = {Farwer, Berndt and Leuschel, Michael},
  EDITOR = {Moggi, Eugenio and Warren, David Scott},
  PUBLISHER = {ACM Press},
  BOOKTITLE = {PPDP},
  DATE = {2004-11},
  ISBN = {1-58113-819-9},
  PAGES = {20--31},
  TITLE = {Model Checking of {Object Petri Nets} in {Prolog}},
}

@ARTICLE{CaHaZi04_275,
  ABSTRACT = {Le développement de systèmes à l'aide du raffinement est une méthode formelle qui permet de gérer la complexité d'un système et de sa preuve de correction en permettant l'introduction des détails du système pas à pas. A partir d'un système abstrait, chaque pas de raffinement est prouvé correct jusqu'au niveau d'implantation. La méthode B est basée sur le raffinement, mais elle aide aussi à gérer les obligations de preuve qui se présentent à chaque pas. La méthode B est l'une des méthodes qui possdent le plus d'outils support pour être utilisée en pratique. Les systèmes électroniques deviennent de plus en plus complexes, l'approche traditionnelle qui consiste à garantir la correction par la simulation ne suffit plus. Par ailleurs, les systèmes électroniques sont de plus en plus présents dans les systmes de toute nature et l'exigence en qualité est de plus en plus forte. Les méthodes formelles sont les seules à pouvoir faire face à cette complexité croissante. Nous présentons dans cet article comment la méthode B peut être utilisée pour la conception des systèmes électroniques.},
  AUTHOR = {Cansell, Dominique and Hallerstede, Stefan and Zimmermann, Yann},
  DATE = {2004-00},
  JOURNALTITLE = {Génie Logiciel},
  NUMBER = {67},
  PAGES = {38--44},
  TITLE = {Construction sûre de systèmes électroniques},
}

@ARTICLE{VoSnHaMa04_274,
  ABSTRACT = {The approach proposed in this paper introduces a hardware/software co-design framework for developing complex embedded systems. The method relies on formal proof of system properties at every phase of the co-design cycle. The key concept is the combined use of UML and the B language for system modeling and design, and the seamless transition from UML specifications to system descriptions in B. The final system prototype emerges from correct-by-construction subsystems described in the B language; the hardware components are translated in VHDL/SystemC, while for the software components C/C++ is used. The outcome is a formally proven correct system implementation. The efficiency of the proposed method is exhibited through the design of a case study from the telecommunication domain.},
  AUTHOR = {Voros, Nikolaos S. and Snook, Colin and Hallerstede, Stefan and Masselos, Konstantinos},
  PUBLISHER = {Springer-Verlag},
  DATE = {2004},
  JOURNALTITLE = {Design Automation for Embedded Systems},
  NUMBER = {2},
  PAGES = {67--99},
  TITLE = {Embedded System Design Using Formal Model Refinement: An Approach Based on the Combined Use of UML and the B Language},
  VOLUME = {9},
}

@ARTICLE{HaBu04_263,
  ABSTRACT = {Formal notations like B or action systems support a notion of refinement. Refinement relates an abstract specification AA to a more deterministic concrete specification CC. Knowing AA and CC one proves CC refines, or implements, specification AA. In this study we consider specification AA as given and concern ourselves with a way to find a good candidate for implementation CC. To this end we classify all implementations of an abstract specification according to their performance. We distinguish performance from correctness. Concrete systems that do not meet the abstract specification correctly are excluded. Only the remaining correct implementations CC are considered with respect to their performance. A good implementation of a specification is identified by having some optimal behaviour in common with it. In other words, a good refinement corresponds to a reduction of non-optimal behaviour. This also means that the abstract specification sets a boundary for the performance of any implementation. We introduce the probabilistic action system formalism which combines refinement with performance. In our current study we measure performance in terms of long-run expected average-cost. Performance is expressed by means of probability and expected costs. Probability is needed to express uncertainty present in physical environments. Expected costs express physical or abstract quantities that describe a system. They encode the performance objective. The behaviour of probabilistic action systems is described by traces of expected costs. A corresponding notion of refinement and simulation-based proof rules are introduced. Probabilistic action systems are based on discrete-time Markov decision processes. Numerical methods solving the optimisation problems posed by Markov decision processes are well-known, and used in a software tool that we have developed. The tool computes an optimal behaviour of a specification AA thus assisting in the search for a good implementation CC.},
  AUTHOR = {Hallerstede, Stefan and Butler, Michael},
  PUBLISHER = {Springer-Verlag},
  DATE = {2004},
  JOURNALTITLE = {Formal Aspects of Computing},
  NUMBER = {4},
  PAGES = {313--331},
  TITLE = {Performance analysis of probabilistic action systems},
  VOLUME = {16},
}

@INPROCEEDINGS{HaZi04_287,
  ABSTRACT = {We present the design of a parallel synchronous hardware component from a purely functional description of its behaviour. Starting from an abstract specification of a linear time-invariant (LTI) system in Event-B a pipelined implementation is developed. The presented approach is applicable to LTI systems that can be represented as linear constant-coefficient difference equations. Scheduling and allocation can be conveniently expressed in the Event-B formalism.},
  AUTHOR = {Hallerstede, Stefan and Zimmermann, Yann},
  BOOKTITLE = {Proceedings of the Forum on Specification and Design Languages (FDL'04)},
  DATE = {2004},
  TITLE = {Circuit Design by Refinement in Event-B},
}

@INCOLLECTION{VoSnHaLe04_294,
  ABSTRACT = {The approach presented in this book relies on the unification of system specification environments for developing electronic systems that are formally proven to be correct (correct-by-construction systems). The key concept conveyed is the formal proof of system properties, which is carried out at every phase of the co-design cycle. The main idea is to build fully functional system models that are formally proven to be correct, and based on them to produce automatically the hardware and the software parts of the system. The approach presented relies on the combined use of UML and B language.},
  AUTHOR = {Voros, Nikolaos S. and Snook, Colin and Hallerstede, Stefan and Lecomte, Thierry},
  EDITOR = {Mermet, J.},
  PUBLISHER = {Kluwer},
  BOOKTITLE = {UML-B Specification for Proven Embedded Systems Design},
  DATE = {2004},
  PAGES = {37--52},
  TITLE = {Embedded System Design Using the PUSSEE Method},
}

@INCOLLECTION{Ha04_295,
  ABSTRACT = {In this chapter we discuss modeling of hardware and translation to VHDL. Translation to SystemC or Verilog is similar. However VHDL is easier to read and we use VHDL synthesis tools. Translation is important to provide a complete path from formal models to a circuit. Equally important we need a refinement method to arrive at a formal circuit description that can be translated. This method has some significant differences to the refinement method for software. As one would expect, they are virtually not present at system level but become more and more visible as an actual implementation is approached. This means that the initial refinement steps used in hardware are, in principle, also applicable to software, and vice versa. The subset of the B-language that serves to describe hardware is called BHDL. The definition of the BHDL subset is oriented at the register transfer level for hardware description.},
  AUTHOR = {Hallerstede, Stefan},
  EDITOR = {Mermet, J.},
  PUBLISHER = {Kluwer},
  BOOKTITLE = {UML-B Specification for Proven Embedded Systems Design},
  CHAPTER = {7},
  DATE = {2004},
  PAGES = {109--120},
  TITLE = {BHDL},
}

@INCOLLECTION{ZiHaCa04_296,
  ABSTRACT = {This chapter presents a study of the SAE J1708 Serial Communication link. The study is carried out in Event-B, an extension of the B method. The system is implemented and decomposed using step-wise refinement. We present how to derive with this method a cycle-accurate hardware model. The model of the communication link system is composed of an arbitrary finite number of identical components that run concurrently. The model contains synchronisation of these components required to control access to the communication link. At the end of the refinement we obtain an implementable model of the components which is translated into VHDL. The generated VHDL design is synthesizable, meaning that the implementable B model is synthesizable as well.},
  AUTHOR = {Zimmermann, Yann and Hallerstede, Stefan and Cansell, Dominique},
  EDITOR = {Mermet, J.},
  PUBLISHER = {Kluwer},
  BOOKTITLE = {UML-B Specification for Proven Embedded Systems Design},
  DATE = {2004},
  PAGES = {211--226},
  TITLE = {Formal Modelling of Electronic Circuits Using Event-B, Case Study: SAE J1708 Serial Communication Link},
}

@INCOLLECTION{CaHaOl04_297,
  ABSTRACT = {Formal refinement as offered by the B method has been shown to be applicable in practice and to scale up. However, it has been recognised that it is difficult communicate a formal B model with customers. Recently, the UML has been investigated as an interface to rigorous formal B models to facilitate this communication. The UML is generally accepted as being a good vehicle for communicating models of systems. Availability of this interface to the B method addresses a major problem faced by most formal methods: How to validate a formal model with a customer who is not formal methods expert? In this chapter we present an approach to the development of a formally verified circuit implementing a Hamming encoder/decoder. The UML-B is used as a formal specification language and the B method is used to prove refinements until the implementation level at which we can translate into VHDL.},
  AUTHOR = {Cansell, Dominique and Hallerstede, Stefan and Oliver, Ian},
  EDITOR = {Mermet, J.},
  PUBLISHER = {Kluwer},
  BOOKTITLE = {UML-B Specification for Proven Embedded Systems Design},
  DATE = {2004},
  PAGES = {261--278},
  TITLE = {UML-B Specification and Hardware Implementation of a Hamming Coder/Decoder},
}

@INPROCEEDINGS{LeBu05_1,
  AUTHOR = {Leuschel, Michael and Butler, Michael},
  EDITOR = {Fitzgerald, John and Hayes, Ian and Tarlecki, Andrzej},
  PUBLISHER = {Springer-Verlag},
  BOOKTITLE = {FM'2005},
  DATE = {2005-01},
  ISSN = {0302-9743},
  PAGES = {221--236},
  SERIES = {Lecture Notes in Computer Science},
  TITLE = {Combining {CSP} and {B} for Specification and Property Verification},
  VOLUME = {3582},
}

@INPROCEEDINGS{BuLeSn05_2,
  ABSTRACT = {In this paper we give an overview of some tools that we have developed to support the application of the B Method. ProB is an animation and model checking tool for the B method. ProB's animation facilities allow users to gain confidence in their specifications. ProB contains a temporal and a state-based model checker, both of which can be used to detect various errors in B specifications. We also overview a recent extension of ProB that supports checking of specifications written in a combination of CSP and B. Finally we describe the UML-B profile and associated U2B tool that allows UML and B to be combined and is intended to make modelling with B more appealing to software engineers.},
  AUTHOR = {Butler, Michael and Leuschel, Michael and Snook, Colin},
  BOOKTITLE = {12th International Workshop on Abstract State Machines},
  DATE = {2005-03},
  PAGES = {57--69},
  TITLE = {Tools for system validation with {B} abstract machines},
}

@ARTICLE{Le05_4,
  AUTHOR = {Leuschel, Michael},
  PUBLISHER = {Springer-Verlag},
  DATE = {2005-08},
  JOURNALTITLE = {Formal Aspects of Computing},
  NUMBER = {2},
  PAGES = {91--92},
  TITLE = {Guest Editorial -- Special Issue on Automated Verification of Critical Systems},
  VOLUME = {17},
}

@INPROCEEDINGS{LeBu05_5,
  AUTHOR = {Leuschel, Michael and Butler, Michael},
  EDITOR = {Lau, Kung-Kiu and Banach, Richard},
  PUBLISHER = {Springer-Verlag},
  BOOKTITLE = {Proceedings ICFEM},
  DATE = {2005-05},
  PAGES = {345--359},
  SERIES = {Lecture Notes in Computer Science},
  TITLE = {Automatic Refinement Checking for {B}},
  VOLUME = {3785},
}

@INPROCEEDINGS{LeCr05_7,
  ABSTRACT = {The Lloyd-Topor transformation is a classical transformation that translates extended logic programs with logical connectives and explicit quantifiers into normal logic programs. In this paper we show that this translation can be achieved in a natural way by specialising a meta-interpreter for extended logic programs. For this we use the Logen partial evaluation system, extended to handle coroutining.},
  AUTHOR = {Leuschel, Michael and Craig, Stephen},
  EDITOR = {Hill, Pat},
  BOOKTITLE = {Pre-Proceedings of LOPSTR'05},
  DATE = {2005-09},
  TITLE = {A Reconstruction of the {Lloyd-Topor} Transformation using Partial Evaluation},
}

@INPROCEEDINGS{LeTu05_8,
  ABSTRACT = {ProB is an animator and model checker for the B method. It also allows to visualise the state space of a B machine in graphical way. This is often very useful and allows users to quickly spot whether the machine behaves as expected. However, for larger state spaces the visualisation quickly becomes difficult to grasp by users (and the computation of the graph layout takes considerable time). In this paper we present two relatively simple algorithms to often considerably reduce the complexity of the graphs, while still keeping relevant information. This makes it possible to visualise much larger state spaces and gives the user immediate feedback about the overall behaviour of a machine. The algorithms have been implemented within the ProB toolset and we highlight their potential on several examples. We also conduct a thorough experimentation of the algorithm on 47 B machines and analyse the results.},
  AUTHOR = {Leuschel, Michael and Turner, Edd},
  EDITOR = {Treharne, Helen and King, Steve and Henson, Martin and Schneider, Steve},
  PUBLISHER = {Springer-Verlag},
  BOOKTITLE = {ZB},
  DATE = {2005-11},
  ISBN = {3-540-25559-1},
  PAGES = {6--23},
  SERIES = {Lecture Notes in Computer Science},
  TITLE = {Visualising Larger State Spaces in {ProB}},
  VOLUME = {3455},
}

@INPROCEEDINGS{LeVi05_9,
  ABSTRACT = {Program slicing is a well-known methodology that aims at identifying the program statements that (potentially) affect the values computed at some point of interest. Within imperative programming, this technique has been successfully applied to debugging, specialization, merging, reuse, maintenance, etc. Due to its declarative nature, adapting the slicing notions and techniques to a logic programming setting is not an easy task. In this work, we define the first, semantics-preserving, forward slicing technique for logic programs. Our approach relies on the application of a conjunctive partial deduction algorithm for a precise propagation of information between calls. <br/> We do not distinguish between static and dynamic slicing since partial deduction can naturally deal with both static and dynamic data. Furthermore, this approach can quite easily be implemented by adding a new code generator on top of existing partial deduction systems. A slicing tool has been implemented in ECCE, where a post-processing transformation to remove redundant arguments has been added. Experiments conducted on a wide variety of programs are encouraging and demonstrate the usefulness of our approach, both as a classical slicing method and as a technique for code size reduction.},
  AUTHOR = {Leuschel, Michael and Vidal, Germán},
  EDITOR = {Sagiv, Mooly},
  PUBLISHER = {Springer-Verlag},
  BOOKTITLE = {ESOP},
  DATE = {2005},
  ISBN = {3-540-25435-8},
  PAGES = {61--76},
  SERIES = {Lecture Notes in Computer Science},
  TITLE = {Forward Slicing by Conjunctive Partial Deduction and Argument Filtering},
  VOLUME = {3444},
}

@INPROCEEDINGS{LoBuLeBo05_10,
  ABSTRACT = {We present an analysis Trust Analysis Methodology for finding trust issues within pervasive computing systems. It is based on a systematic analysis of scenarios that describe the typical use of the pervasive system by using a Trust Analysis Grid. The Trust Analysis Grid is composed of eleven Trust Issue Categories that cover the various aspects of the concept of trust in pervasive computing systems. The Trust Analysis Grid is then used to guide the design of the pervasive computing system.},
  AUTHOR = {Presti, Stephane Lo and Butler, Michael and Leuschel, Michael and Booth, Chris},
  EDITOR = {Falcone, R and Barber, S and Sabater, J and Singh, M},
  PUBLISHER = {Springer-Verlag},
  BOOKTITLE = {Trusting Agents for trusting Electronic Societies},
  DATE = {2005},
  ISBN = {978-3-540-28012-5},
  SERIES = {Lecture Notes in Computer Science},
  TITLE = {A Trust Analysis Methodology for Pervasive Computing Systems},
  VOLUME = {3577},
}

@ARTICLE{SaLeBu05_11,
  ABSTRACT = {We present ProTest, an automatic test environment for B specifications. B is a model-oriented notation where systems are specified in terms of abstract states and operations on abstract states. ProTest first generates a state coverage graph of a B specification through exhaustive model checking, and the coverage graph is traversed to generate a set of test cases, each being a sequence of B operations. For the model checking to be exhaustive, some transformations are applied to the sets used in the B machine. The approach also works if it is not exhaustive; one can stop at any point in time during the state space exploration and generate test cases from the coverage graph obtained so far. ProTest then simultaneously performs animation of the B machine and the execution of the corresponding implementation in Java, and assign verdicts on the test results. With some restrictions imposed on the B operations, the whole of the testing process is performed mechanically. We demonstrate the efficacy of our test environment by performing a small case study from industry. Furthermore, we present a solution to the problem of handling non-determinism in B operations.},
  AUTHOR = {Satpathy, Manoranjan and Leuschel, Michael and Butler, Michael},
  EDITOR = {Gurevich, Yuri and Petrenko, Alexander K. and Kossatchev, Alexander},
  PUBLISHER = {Elsevier},
  DATE = {2005-01},
  ISSN = {1571-0661},
  JOURNALTITLE = {Electronic Notes in Theroretical Computer Science},
  PAGES = {113--136},
  TITLE = {{ProTest}: An Automatic Test Environment for {B} Specifications},
  VOLUME = {111},
}

@INPROCEEDINGS{WaGuLe05_12,
  ABSTRACT = {Provably correct compilation is an important aspect in development of high assurance software systems. In this paper we explore approaches to provably correct code generation based on programming language semantics, particularly Horn logical semantics, and partial evaluation. We show that the definite clause grammar (DCG) notation can be used for specifying both the syntax and semantics of imperative languages. We next show that continuation semantics can also be expressed in the Horn logical framework.},
  AUTHOR = {Wang, Qian and Gupta, Gopal and Leuschel, Michael},
  EDITOR = {Hermengildo, Manuel and Cabeza, Daniel},
  PUBLISHER = {Springer-Verlag},
  BOOKTITLE = {PADL},
  DATE = {2005},
  ISBN = {3-540-24362-3},
  PAGES = {98--112},
  SERIES = {Lecture Notes in Computer Science},
  TITLE = {Towards Provably Correct Code Generation via Horn Logical Continuation Semantics},
  VOLUME = {3350},
}

@INPROCEEDINGS{CrLe05_222,
  ABSTRACT = {The paper develops a self-tuning resource aware partial evaluation technique for Prolog programs, which derives its own control strategies tuned for the underlying computer architecture and Prolog compiler using a genetic algorithm approach. The algorithm is based on mutating the annotations of offline partial evaluation.<br/> Using a set of representative sample queries it decides upon the fitness of annotations, controlling the trade-off between code explosion, speedup gained and specialisation time. The user can specify the importance of each of these factors in determining the quality of the produced code, tailoring the specialisation to the particular problem at hand. <br/> We present experimental results for our implemented technique on a series of benchmarks. The results are compared against the aggressive termination based binding-time analysis and optimised using different measures for the quality of code. We also show that our technique avoids some classical pitfalls of partial evaluation.},
  AUTHOR = {Craig, Stephen and Leuschel, Michael},
  PUBLISHER = {ACM Press},
  BOOKTITLE = {Proceedings PPDP'2005},
  DATE = {2005},
  PAGES = {23--34},
  TITLE = {Self-Tuning Resource Aware Specialisation for {Prolog}},
}

@REPORT{Ha05_298,
  ABSTRACT = {This text describes a proof obligation generator for EventB. Most of the document describes the actual generated proof obligations and justification of their correctness. The algorithm for their generation is very simple. We distinguish generated proof obligations from theoretical ones. Theoretical proof obligations are well-suited for hand-written mathematical proofs but less suited for machine-assisted proof. In particular, generated proof obligations have be obtained by decomposing theoretical proof obligations as far as possible so that they are as simple as possible; and hopefully provable by an automatic prover. Substitutions produced by the proof obligation generator are left unevaluated. These are applied in a preprocessing step of the proof manager. The reason for this is to keep the design of the proof obligation generator distinct from the actual provers. By using witnesses in models a part of the proof has been moved into modelling itself. The price to pay is that one has to think about proving while modelling. The advantage is that proofs are decomposed and almost all existential quantifiers are removed from the consequents of proof obligations. There are three main sections on contexts, initial models, and refined models. Each of these contains three subsections: the description subsection introduces the notation used in the section; the theory subsection presents the theoretical proof obligations and derives the generated proof obligations by proof; the generated proof obligations subsection contains the list of proof obligations to be generated by the proof obligation generator. This last section also contains proof obligations for well-definedness. On first reading well-definedness proof obligations should be ignored. These are necessary but are actually not derived from the theoretical proof obligations.},
  AUTHOR = {Hallerstede, Stefan},
  INSTITUTION = {Information Security, ETH Zürich},
  DATE = {2005},
  TITLE = {The Event-B Proof Obligation Generator},
  TYPE = {techreport},
}

@ARTICLE{HaVo05_299,
  ABSTRACT = {All modelling items used in a formal B development are kept in the database kernel-component. This database is analysed by the static checker with respect to various properties the collection of modelling items must satisfy. When the static checker has accepted the database as being consistent, its items can be submitted to proof obligation generation and subsequent proof. In addition to marking modelling items as consistent the static checker computes auxiliary data structures to improve performance of all tasks that involve using items stored in the database.},
  AUTHOR = {Hallerstede, Stefan and Voisin, Laurent},
  DATE = {2005},
  JOURNALTITLE = {Rodin Deliverable D10},
  TITLE = {The Event-B Static Checker},
}

@INPROCEEDINGS{LeElVaCrFo06_140,
  ABSTRACT = {We present Ecce and Logen, two partial evaluators for Prolog using the online and offline approach respectively. We briefly present the foundations of these tools and discuss various applications. We also present new implementations of these tools, carried out in Ciao Prolog. In addition to a command-line interface new user-friendly web interfaces were developed. These enable non-expert users to specialise logic programs using a web browser, without the need for a local installation.},
  AUTHOR = {Leuschel, Michael and Elphick, Daniel and Varea, Mauricio and Craig, Stephen and Fontaine, Marc},
  EDITOR = {Hatcliff, John and Tip, Frank},
  PUBLISHER = {IBM Press},
  BOOKTITLE = {Proceedings PEPM 06},
  DATE = {2006-01},
  PAGES = {88--94},
  TITLE = {The {Ecce} and {Logen} Partial Evaluators and their Web Interfaces},
}

@INPROCEEDINGS{LeCrEl06_199,
  AUTHOR = {Leuschel, Michael and Craig, Stephen and Elphick, Daniel},
  EDITOR = {Puebla, German},
  PUBLISHER = {Springer-Verlag},
  BOOKTITLE = {Proceedings LOPSTR'06},
  DATE = {2006},
  PAGES = {43--59},
  SERIES = {Lecture Notes in Computer Science},
  TITLE = {Supervising Offline Partial Evaluation of Logic Programs using Online Techniques},
  VOLUME = {4407},
}

@INCOLLECTION{LoBuLeBo06_200,
  AUTHOR = {Presti, Stephane Lo and Butler, Michael and Leuschel, Michael and Booth, Chris},
  EDITOR = {Song, Ronggong and Korba, Larry and Yee, George},
  PUBLISHER = {IGI Global},
  BOOKTITLE = {Trust in E-services: Technologies, Practices and Challenges},
  DATE = {2006},
  PAGES = {113--139},
  TITLE = {Holistic Trust Design of E-Services},
}

@INPROCEEDINGS{LeBe06_206,
  AUTHOR = {Leuschel, Michael and Bendisposto, Jens},
  EDITOR = {J. Abrial, U. Glässer},
  BOOKTITLE = {Dagstuhl Seminar 06191 "Rigorous Methods for Software Construction and Analysis"},
  DATE = {2006-05},
  TITLE = {Animating and Model Checking B Specifications with Higher-Order Recursive Functions},
}

@INPROCEEDINGS{AbBuHaVo06_286,
  ABSTRACT = {We consider modelling indispensable for the development of complex systems. Modelling must be carried out in a formal notation to reason and make meaningful conjectures about a model. But formal modelling of complex systems is a difficult task. Even when theorem provers improve further and get more powerful, modelling will remain difficult. The reason for this that modelling is an exploratory activity that requires ingenuity in order to arrive at a meaningful model. We are aware that automated theorem provers can discharge most of the onerous trivial proof obligations that appear when modelling systems. In this article we present a modelling tool that seamlessly integrates modelling and proving similar to what is offered today in modern integrated development environments for programming. The tool is extensible and configurable so that it can be adapted more easily to different application domains and development methods.},
  AUTHOR = {Abrial, Jean-Raymond and Butler, Michael and Hallerstede, Stefan and Voisin, Laurent},
  PUBLISHER = {Springer-Verlag},
  BOOKTITLE = {ICFEM 2006},
  DATE = {2006},
  PAGES = {49--63},
  SERIES = {Lecture Notes in Computer Science},
  TITLE = {An open extensible tool environment for Event-B},
}

@INPROCEEDINGS{BoDoLeMa07_220,
  ABSTRACT = {We present a new verification technique for Promela which exploits state-space symmetries induced by scalarset values used in a model. The technique involves efficiently computing a marker for each state encountered during search. We propose a complete verification method which only partially exploits symmetry, and an approximate verification method which fully exploits symmetry. We describe how symmetry markers can be efficiently computed and integrated into the Spin tool, and provide an empirical evaluation of our technique using the Topspin symmetry reduction package, which shows very good performance results and a high degree of precision for the approximate method (i.e. very few non-symmetric states receive the same marker). We also identify a class of models for which the approximate technique is precise.},
  AUTHOR = {Bosnacki, Dragan and Donaldson, Alastair F. and Leuschel, Michael and Massart, Thierry},
  PUBLISHER = {Springer-Verlag},
  BOOKTITLE = {ATVA},
  DATE = {2007},
  ISBN = {978-3-540-75595-1},
  PAGES = {300--315},
  SERIES = {Lecture Notes in Computer Science},
  TITLE = {Efficient Approximate Verification of {Promela} Models via Symmetry Markers},
  VOLUME = {4762},
}

@INPROCEEDINGS{BeLe07_207,
  ABSTRACT = {The open-source Eclipse platform has become hugely popular as an integrated development environment for Java, and a considerable number of plug-ins have been developed for other programming languages (e.g., C++,PHP, Eiffel, Python, Fortran, etc.). In this paper we present a new plug-in for Eclipse, supporting the B-method and B's abstract machine notation (AMN). In addition to providing editing and syntax highlighting, the plug-in displays syntax and structural errors in the B source code, as well as suggesting fixes for those errors.},
  AUTHOR = {Bendisposto, Jens and Leuschel, Michael},
  EDITOR = {Julliand, Jacques and Kouchnarenko, Olga},
  PUBLISHER = {Springer},
  BOOKTITLE = {Proceedings of B 2007},
  DATE = {2007},
  ISBN = {3-540-68760-2},
  PAGES = {270--273},
  SERIES = {Lecture Notes in Computer Science},
  TITLE = {{BE4}: The B Extensible Eclipse Editing Environment},
  VOLUME = {4355},
}

@INPROCEEDINGS{KlOsLe07_211,
  ABSTRACT = {In aspect-oriented programming, pointcuts are usually compiled by identifying a set of shadows - that is, places in the code whose execution is potentially relevant for a pointcut - and inserting dynamic checks at these places for those parts of the pointcut that cannot be evaluated statically. Today, the algorithms for shadow and check computation are specific for every pointcut designator. This makes it very tedious to extend the pointcut language. We propose the use of declarative languages, together with associated analysis and specialisation tools, to implement powerful and extensible pointcut languages. More specifically, we propose to synthesize (rather than program manually) the shadow and dynamic check algorithms. With this approach, it becomes easier to implement powerful pointcut languages efficiently and to keep pointcut languages open for extension.},
  AUTHOR = {Klose, Karl and Ostermann, Klaus and Leuschel, Michael},
  PUBLISHER = {Springer-Verlag},
  BOOKTITLE = {Practical Applications of Declarative Languages (PADL'07)},
  DATE = {2007-01},
  ISBN = {978-3-540-69608-7},
  PAGES = {320--334},
  SERIES = {Lecture Notes in Computer Science},
  TITLE = {Partial Evaluation of Pointcuts},
}

@INPROCEEDINGS{BeLe07_210,
  ABSTRACT = {Writing a formal specification for real-life, industrial problems is a difficult and error prone task, even for experts in formal methods. In the process of specifying a formal model for later refinement and implementation it is crucial to get approval and feedback from domain experts to avoid the costs of changing a specification at a late point of the development. But understanding formal models written in a specification language like B requires mathematical knowledge a domain expert might not have. In this paper we present a new tool to visualize B Machines using the ProB animator and Macromedia Flash. Our tool offers an easy way for specifiers to build a domain specific visualization that can be used by domain experts to check whether a B specification corresponds to their expectations.},
  AUTHOR = {Bendisposto, Jens and Leuschel, Michael},
  EDITOR = {Julliand, Jacques and Kouchnarenko, Olga},
  PUBLISHER = {Springer},
  BOOKTITLE = {Proceedings of B 2007},
  DATE = {2007},
  ISBN = {3-540-68760-2},
  PAGES = {266--269},
  SERIES = {Lecture Notes in Computer Science},
  TITLE = {A Generic Flash-Based Animation Engine for ProB},
  VOLUME = {4355},
}

@INPROCEEDINGS{LeBuSpTu07_209,
  ABSTRACT = {Symmetry reduction is an established method for limiting the amount of states that have to be checked during exhaustive model checking. The idea is to only verify a single representative of every class of symmetric states. However, computing this representative can be nontrivial, especially for a language such as B with its involved data structures and operations. In this paper, we propose an alternate approach, called permutation flooding. It works by computing permutations of newly encountered states, and adding them to the state space. This turns out to be relatively unproblematic for B?s data structures and we have implemented the algorithm inside the ProB model checker. Empirical results confirm that this approach is effective in practice; speedups exceed an order of magnitude in some cases. The paper also contains correctness results of permutation flooding, which should also be applicable for classical symmetry reduction in B.},
  AUTHOR = {Leuschel, Michael and Butler, Michael and Spermann, Corinna and Turner, Edd},
  PUBLISHER = {Springer-Verlag},
  BOOKTITLE = {Proceedings B'2007},
  DATE = {2007},
  PAGES = {79--93},
  SERIES = {Lecture Notes in Computer Science},
  TITLE = {Symmetry Reduction for {}B by Permutation Flooding},
  VOLUME = {4355},
}

@INPROCEEDINGS{LeMa07_212,
  AUTHOR = {Leuschel, Michael and Massart, Thierry},
  LOCATION = {Edinburgh, UK},
  BOOKTITLE = {Proceedings International Symmetry Conference},
  DATE = {2007-01},
  PAGES = {71--85},
  TITLE = {Efficient Approximate Verification of {B} via Symmetry Markers},
}

@INPROCEEDINGS{SaBuLeRa07_215,
  AUTHOR = {Satpathy, Manoranjan and Butler, Michael and Leuschel, Michael and Ramesh, S.},
  PUBLISHER = {Springer-Verlag},
  BOOKTITLE = {Tests and Proofs (TAP 2007)},
  DATE = {2007-02},
  ISBN = {978-3-540-73769-8},
  PAGES = {95--113},
  SERIES = {Lecture Notes in Computer Science},
  TITLE = {Automatic Testing from Formal Specifications},
  VOLUME = {4454},
}

@INPROCEEDINGS{TuLeSpBu07_217,
  ABSTRACT = {Symmetry reduction is a technique that can help alleviate the problem of state space explosion in model checking. The idea is to verify only a subset of states from each class (orbit) of symmetric states. This paper presents a framework for symmetry reduced model checking of B machines, which verifies a unique representative from each orbit. Symmetries are induced by the deferred set; a key component of the B language. This contrasts with strategies that require the introduction of a special data type into a language, to indicate symmetry. An extended version of the graph isomorphism program, textitnauty, is used to detect symmetries, and the symmetry reduction package has been integrated into the ProB model checker. Experimental results illustrate the effectiveness of the method, where exponential speedups are sometimes possible. Relevant algorithms are presented, and there is a comparison with an alternate symmetry reduction strategy, called permutation flooding.},
  AUTHOR = {Turner, Edd and Leuschel, Michael and Spermann, Corinna and Butler, Michael},
  PUBLISHER = {IEEE},
  BOOKTITLE = {Proceedings TASE 2007},
  DATE = {2007},
  PAGES = {25--34},
  TITLE = {Symmetry Reduced Model Checking for {B}},
}

@INPROCEEDINGS{proz07,
  ABSTRACT = {We present the architecture and implementation of the ProZ tool to validate high-level Z specifications. The tool was integrated into ProB, by providing a translation of Z into B and by extending the kernel of ProB to accommodate some new syntax and data types. We describe the challenge of going from the tool friendly formalism B to the more specification-oriented formalism Z, and show how many Z specifications can be systematically translated into B. We describe the extensions, such as record types and free types, that had to be added to the kernel to support a large subset of Z. As a side-effect, we provide a way to animate and model check records in ProB. By incorporating ProZ into ProB, we have inherited many of the recent extensions developed for B, such as the integration with CSP or the animation of recursive functions. Finally, we present a successful industrial application, which makes use of this fact, and where ProZ was able to discover several errors in Z specifications containing higher-order recursive functions.},
  AUTHOR = {Plagge, Daniel and Leuschel, Michael},
  EDITOR = {Davies, J. and Gibbons, J.},
  PUBLISHER = {Springer-Verlag},
  BOOKTITLE = {Integrated Formal Methods},
  DATE = {2007},
  PAGES = {480--500},
  SERIES = {Lecture Notes in Computer Science},
  TITLE = {Validating {Z} Specifications using the {ProB} Animator and Model Checker},
  VOLUME = {4591},
}

@ARTICLE{LiBeLe07_219,
  ABSTRACT = {The B-method, as well as its offspring Event-B, are both tool-supported formal methods used for the development of computer systems whose correctness is formally proven. However, the more complex the specification becomes, the more proof obligations need to be discharged. While many proof obligations can be discharged automatically by recent tools such as the Rodin platform, a considerable number still have to be proven interactively. This can be either because the required proof is too complicated or because the B model is erroneous. In this paper we describe a disprover plugin for Rodin that utilizes the ProB animator and model checker to automatically find counterexamples for a given problematic proof obligation. In case the disprover finds a counterexample, the user can directly investigate the source of the problem (as pinpointed by the counterexample) and should not attempt to prove the proof obligation. We also discuss under which circumstances our plug-in can be used as a prover, i.e., when the absence of a counterexample actually is a proof of the proof obligation.},
  AUTHOR = {Ligot, Olivier and Bendisposto, Jens and Leuschel, Michael},
  DATE = {2007-06},
  JOURNALTITLE = {Proceedings AFADL'07},
  TITLE = {Debugging Event-B Models using the ProB Disprover Plug-in},
}

@INPROCEEDINGS{BoRi07_223,
  ABSTRACT = {Typical modern dynamic languages have a growing number of implementations. We explore the reasons for this situation, and the limitations it imposes on open source or academic communities that lack the resources to fine-tune and maintain them all. It is sometimes proposed that implementing dynamic languages on top of a standardized general-purpose ob ject-oriented virtual machine (like Java or .NET) would help reduce this burden. We propose a complementary alternative to writing custom virtual machine (VMs) by hand, validated by the PyPy pro ject: flexibly generating VMs from a high-level ?specification?, inserting features and low-level details automatically ? including good just-in-time compilers tuned to the dynamic language at hand. We believe this to be ultimately a better investment of efforts than the development of more and more advanced general-purpose object oriented VMs. In this paper we compare these two approaches in detail.},
  AUTHOR = {Bolz, Carl Friedrich and Rigo, Armin},
  BOOKTITLE = {Proceeding of Dyla 2007},
  DATE = {2007},
  TITLE = {How to not write Virtual Machines for Dynamic Languages},
}

@REPORT{LePl07ltltechrep,
  ABSTRACT = {This technical report is an extension to the conference paper with the same name. It contains the proofs that were omitted in the conference paper.},
  AUTHOR = {Leuschel, Michael and Plagge, Daniel},
  INSTITUTION = {Institut für Informatik, Heinrich-Heine-Universität Düsseldorf},
  DATE = {2007},
  NUMBER = {STUPS/2007/02},
  TITLE = {Seven at one stroke: {LTL} model checking for High-level Specifications in {B}, {Z}, {CSP}, and more},
  TYPE = {techreport},
}

@INPROCEEDINGS{LeuschelPlagge2007ltl,
  ABSTRACT = {The size of formal models is steadily increasing and there is a demand from industrial users to be able to use expressive temporal query languages for validating and exploring high-level formal specifications. We present an extension of LTL, which is well adapted for validating B, Z and CSP specifications.<br/>We present a generic, flexible LTL model checker, implemented inside the ProB tool, that can be applied to a multitude of formalisms such as B, Z, CSP, B CSP, as well as Object Petri nets, compensating CSP, and dSL. Our algorithm can deal with deadlocking states, partially explored state spaces, past operators, and can be combined with existing symmetry reduction techniques of ProB. We establish correctness of our algorithm in general, as well as combined with symmetry reduction.<br/> Finally, we present various applications and empirical results of our tool, showing that it can be applied successfully in practice.},
  AUTHOR = {Leuschel, Michael and Plagge, Daniel},
  EDITOR = {Ameur, Yamine Aı̈t and Boniol, Frédéric and Wiels, Virginie},
  PUBLISHER = {Cépaduès-Éditions},
  BOOKTITLE = {ISoLA},
  DATE = {2007},
  ISBN = {978-2-85428-814-8},
  PAGES = {73--84},
  SERIES = {Revue des Nouvelles Technologies de l'Information},
  TITLE = {Seven at one stroke: {LTL} model checking for High-level Specifications in {B}, {Z}, {CSP}, and more},
  VOLUME = {RNTI-SM-1},
}

@ARTICLE{AbHa07_273,
  ABSTRACT = {We argue that formal modeling should be the starting point for any serious development of computer systems. This claim poses a challenge for modeling: at first it must cope with the constraints and scale of serious developments. Only then it is a suitable starting point. We present three techniques, refinement, decomposition, and instantiation, that we consider indispensable for modeling large and complex systems. The vehicle of our presentation is Event-B, but the techniques themselves do not depend on it.},
  AUTHOR = {Abrial, Jean-Raymond and Hallerstede, Stefan},
  DATE = {2007},
  JOURNALTITLE = {Fundamenta Informaticae},
  NUMBER = {1-2},
  PAGES = {1--28},
  TITLE = {Refinement, Decomposition, and Instantiation of Discrete Models: Application to Event-B},
  VOLUME = {77},
}

@INPROCEEDINGS{HaHo07_284,
  ABSTRACT = {Event-B is a notation and method for discrete systems modelling by refinement. We introduce a small but very useful construction: qualitative probabilistic choice. It extends the expressiveness of Event-B allowing us to prove properties of systems that could not be formalised in Event-B before. We demonstrate this by means of a small example, part of a larger Event-B development that could not be fully proved before. An important feature of the introduced construction is that it does not complicate the existing Event-B notation or method, and can be explained without referring to the underlying more complicated probabilistic theory. The necessary theory itself is briefly outlined in this article to justify the soundness of the proof obligations given. We also give a short account of alternative constructions that we explored, and rejected.},
  AUTHOR = {Hallerstede, Stefan and Hoang, Thai Son},
  EDITOR = {Davies, J. and Gibbons, J.},
  PUBLISHER = {Springer-Verlag},
  BOOKTITLE = {IFM 2007},
  DATE = {2007},
  PAGES = {293--312},
  SERIES = {Lecture Notes in Computer Science},
  TITLE = {Qualitative Probabilistic Modelling in Event-B},
}

@INPROCEEDINGS{Ha07_285,
  ABSTRACT = {Event-B is a notation and method for discrete systems modelling by refinement. The notation has been carefully designed to be simple and easily teachable. The simplicity of the notation takes also into account the support by a modelling tool. This is important because Event-B is intended to be used to create complex models. Without appropriate tool support this would not be possible. This article presents justifications and explanations for the choices that have been made when designing the Event-B notation.},
  AUTHOR = {Hallerstede, Stefan},
  EDITOR = {Julliand, J. and Kouchnarenko, O.},
  PUBLISHER = {Springer-Verlag},
  BOOKTITLE = {B 2007},
  DATE = {2007},
  PAGES = {293--312},
  SERIES = {Lecture Notes in Computer Science},
  TITLE = {Justifications for the Event-B Modelling Notation},
  VOLUME = {4591},
}

@INPROCEEDINGS{BuHa07_292,
  ABSTRACT = {We present a software tool, the Rodin tool, for formal modelling in Event-B. Event-B is a notation and method developed from the B-Method and is intended to be used with an incremental style of modelling. The idea of incremental modelling has been taken from programming: modern programming languages come with integrated development environments that make it easy to modify and improve programs. The Rodin tool provides such an environment for Event-B. The two main characteristics of the Rodin tool are its ease of use and its extensibility. The tool focuses on modelling. It is easy to modify models and try out variations of a model. The tool can also be extended easily. This will make it possible to adapt the tool specific needs. So the tool can be adapted to fit into existing development processes instead demanding the opposite. We believe that these two characteristics are major points for industrial uptake.},
  AUTHOR = {Butler, Michael and Hallerstede, Stefan},
  BOOKTITLE = {BCS-FACS Christmas 2007 Meeting},
  DATE = {2007},
  TITLE = {The Rodin Formal Modelling Tool},
}

@ARTICLE{LeBu08_225,
  ABSTRACT = {We present ProB, a validation toolset for the B method. ProB's automated animation facilities allow users to gain confidence in their specifications. ProB also contains a model checker and a refinement checker, both of which can be used to detect various errors in B specifications. We describe the underlying methodology of ProB, and present the important aspects of the implementation. We also present empirical evaluations as well as several case studies, highlighting that ProB enables users to uncover errors that are not easily discovered by existing tools.},
  AUTHOR = {Leuschel, Michael and Butler, Michael},
  PUBLISHER = {Springer-Verlag},
  DATE = {2008},
  JOURNALTITLE = {Software Tools for Technology Transfer (STTT)},
  NUMBER = {2},
  PAGES = {185--203},
  TITLE = {{ProB}: An Automated Analysis Toolset for the {B} Method},
  VOLUME = {10},
}

@INPROCEEDINGS{LeSaBeLu08_228,
  AUTHOR = {Leuschel, Michael and Samia, Mireille and Bendisposto, Jens and Luo, Li},
  EDITOR = {Attiogbé, C. and Habrias, H.},
  PUBLISHER = {Lina},
  BOOKTITLE = {The B Method: from Research to Teaching},
  DATE = {2008},
  PAGES = {17--32},
  TITLE = {Easy Graphical Animation and Formula Viewing for Teaching {B}},
}

@INPROCEEDINGS{SpLe08_229,
  ABSTRACT = {Symmetry reduction holds great promise to counter the state explosion problem. However, currently it is ``conducting a life on the fringe'', and is not widely applied, mainly due to the restricted applicability of many of the techniques. In this paper we propose a symmetry reduction technique applied to high-level formal specification languages (B and Z). Not only does symmetry arise naturally in most models, it can also be exploited without restriction by our method. This method translates states of a formal model into directed graphs, and then uses graph canonicalisation to detect symmetries. We use the tool nauty to efficiently perform graph canonicalisation, which we have interfaced with the model checker ProB. In this paper we present the general technique, show how states can be translated first into vertex-coloured graphs suitable for nauty. We present empirical results, showing the effectiveness of our method as well as analysing the cost of graph canonicalisation.},
  AUTHOR = {Spermann, Corinna and Leuschel, Michael},
  PUBLISHER = {IEEE},
  BOOKTITLE = {Proceedings TASE 2008},
  DATE = {2008-06},
  PAGES = {15--22},
  TITLE = {{ProB} gets {Nauty}: Effective Symmetry Reduction for {B} and {Z} Models},
}

@INPROCEEDINGS{Leuschel08highroad,
  ABSTRACT = {In this paper we examine the difference between model checking high-level and low-level models. In particular, we compare the ProB model checker for the B-method and the Spin model checker for Promela. While Spin has a dramatically more efficient model checking engine, we show that in practice the performance can be disappointing compared to model checking high-level specifications with ProB. We investigate the reasons for this behaviour, examining expressivity, granularity and Spin's search algorithms. We also show that certain types of information (such as symmetry) can be more easily inferred and exploited in high-level models, leading to a considerable reduction in model checking time.},
  AUTHOR = {Leuschel, Michael},
  PUBLISHER = {Springer-Verlag},
  BOOKTITLE = {ABZ 2008},
  DATE = {2008-09},
  PAGES = {4--23},
  SERIES = {Lecture Notes in Computer Science},
  TITLE = {The High Road to Formal Validation: Model Checking High-Level versus Low-Level Specifications},
  VOLUME = {5238},
}

@INPROCEEDINGS{Le08_233,
  ABSTRACT = {This paper summarises roughly ten years of experience using declarative programming for developing tools to validate formal specifications. More precisely, we present insights gained and lessons learned while implementing animators and model checkers in Prolog for various specification languages, ranging from process algebras such as CSP to model-based specifications such as Z and B.},
  AUTHOR = {Leuschel, Michael},
  PUBLISHER = {ACM Press},
  BOOKTITLE = {Proceedings PPDP'2008},
  DATE = {2008-07},
  PAGES = {1--7},
  TITLE = {Declarative Programming for Verification: Lessons and Outlook},
}

@INPROCEEDINGS{LeVi08_234,
  ABSTRACT = {In this paper, we present a fast binding-time analysis (BTA) by integrating a size-change analysis, which is independent of a selection rule, into a classical BTA for offline partial evaluation of logic programs. In contrast to previous approaches, the new BTA is conceptually simpler and considerably faster, scaling to medium-sized or even large examples and, moreover, it ensures both the so called local and global termination. We also show that through the use of selective hints, we can achieve both good specialisation results and a fast BTA and specialisation process.},
  AUTHOR = {Leuschel, Michael and Vidal, Germán},
  EDITOR = {Hanus, Michael},
  BOOKTITLE = {Proceedings LOPSTR'08},
  DATE = {2008},
  PAGES = {119--134},
  SERIES = {Lecture Notes in Computer Science},
  TITLE = {Fast Offline Partial Evaluation for Large Logic Programs},
  VOLUME = {5438},
}

@INPROCEEDINGS{LeLlOlSiTa08_236,
  ABSTRACT = {This work presents a static slicing based technique to slice CSP specifications. Given a particular event in a CSP specification, our technique allows us to know what parts of the specification must necessarily be executed before this event, and what parts of the specification could be executed before it in some execution. Our technique is based on a new data structure which extends the synchronized CFG. We show that this new data structure improves the synchronized CFG by taking into account the context in which processes are called and, thus, makes the slicing process more precise.},
  AUTHOR = {Leuschel, Michael and Llorens, Marisa and Olivier, Javier and Silva, Josep and Tamarit, Salvador},
  EDITOR = {Hanus, Michael},
  BOOKTITLE = {Preproceedings LOPSTR'08},
  DATE = {2008},
  PAGES = {103--118},
  SERIES = {Lecture Notes in Computer Science},
  TITLE = {Static Slicing of CSP Specifications},
  VOLUME = {5438},
}

@ARTICLE{LeFo08_237,
  ABSTRACT = {We present a new animation and model checking tool for CSP. The tool covers the CSP-M language, as supported by existing tools such as fdr and probe. Compared to those tools, it provides visual feedback in the source code, has an LTL model checker and can be used for combined CSP||B specifications. During the development of the tool some intricate issues were uncovered with the CSP-M language. We discuss those issues, and provide suggestions for improvement. We also explain how we have ensured conformance with fdr, by using fdr itself to validate our tool's output. We also provide empirical evidence on the performance of our tool compared to fdr, showing that it can be used on industrial-strength specifications.},
  AUTHOR = {Leuschel, Michael and Fontaine, Marc},
  PUBLISHER = {Springer-Verlag},
  DATE = {2008},
  JOURNALTITLE = {ICFEM 2008},
  PAGES = {278--297},
  TITLE = {Probing the Depths of CSP-M: A new FDR-compliant Validation Tool},
}

@INPROCEEDINGS{BeEnLeSc08_240,
  ABSTRACT = {In this paper we present a Prolog plugin for Eclipse based upon BE4, and providing many features such as semantic-aware syntax highlighting, outline view, error marking, content assist, hover information, documentation generation, and quick fixes. The plugin makes use of a Java parser for full Prolog with an inte- grated Prolog engine, and can be extended with further semantic analyses, e.g., based on abstract interpretation.},
  AUTHOR = {Bendisposto, Jens and Endrijautzki, Ian and Leuschel, Michael and Schneider, David},
  BOOKTITLE = {Proceedings of the 18th Workshop on Logic-based methods in Programming Environments, WLPE},
  DATE = {2008},
  TITLE = {A Semantics-Aware Editing Environment for Prolog in Eclipse},
}

@INPROCEEDINGS{BoKuMaLiNiReRiVe08_245,
  ABSTRACT = {We report on our experiences with the Spy project, including implementation details and benchmark results. Spy is a re-implementation of the Squeak (i.e. Smalltalk-80) VM using the PyPy toolchain. The PyPy project allows code written in RPython, a subset of Python, to be translated to a multitude of different backends and architectures. During the translation, many aspects of the implementation can be independently tuned, such as the garbage collection algorithm or threading implementation. In this way, a whole host of interpreters can be derived from one abstract interpreter definition. Spy aims to bring these benefits to Squeak, allowing for greater portability and, eventually, improved performance. The current Spy codebase is able to run a small set of benchmarks that demonstrate performance superior to many similar Smalltalk VMs, but which still run slower than in Squeak itself. Spy was built from scratch over the course of a week during a joint Squeak-PyPy Sprint in Bern last autumn.},
  AUTHOR = {Bolz, Carl Friedrich and Kuhn, Adrian and Matsakis, Nicholas and Lienhard, Adrian and Nierstrasz, Oscar and Renggli, Lukas and Rigo, Armin and Verwaest, Toon},
  PUBLISHER = {Springer},
  BOOKTITLE = {Self-Sustaining Systems},
  DATE = {2008},
  PAGES = {123--139},
  SERIES = {Lecture Notes in Computer Science},
  TITLE = {Back to the Future in One Week – Implementing a Smalltalk VM in PyPy},
}

@INPROCEEDINGS{Ha08_281,
  ABSTRACT = {A reasonable approach to formal modelling is to start with a specification that captures the requirements of a system and then use formal refinement to implement it. The problem with this approach is that for complex systems the specification itself is complex. It becomes a challenge to say whether the specification is the right one for the given requirements. Sometimes requirements also concern features of a system closely related to its implementation. This would make an abstract specification necessarily incomplete. We believe that it is better not to follow the rigid approach to modelling described above. Instead, we argue that the specification itself should be elaborated by refinement. Ultimately, the distinction between specification and implementation is no longer made in the strict sense above. There is only one model of the system that is connected by successive refinements. Using Event-B, we demonstrate how this can be applied to cope with the complexity of specifications. On the one hand we benefit from the reduced number of detail to consider at different times. On the other hand we are encouraged to reason about the formal model since the beginning and to rethink it occasionally to capture better its intended behaviour and match the requirements.},
  AUTHOR = {Hallerstede, Stefan},
  PUBLISHER = {Springer-Verlag},
  BOOKTITLE = {FMCO 2008},
  DATE = {2008},
  PAGES = {139--158},
  SERIES = {Lecture Notes in Computer Science},
  TITLE = {Incremental system modelling in Event-B},
}

@INPROCEEDINGS{AbBuHaVo08_282,
  ABSTRACT = {Event-B is a formal method for system-level modelling and analysis. Key features of Event-B are the use of set theory as a modelling notation, the use of refinement to represent systems at different abstraction levels and the use of mathematical proof to verify consistency between refinement levels. The continued development of the Rodin toolset is funded by the EU research project ICT 214158 DEPLOY (Industrial deployment of system engineering methods providing high dependability and productivity) www.deploy-project.eu. The toolset was originally developed as part of the project IST 511599 RODIN (Rigorous Open Development Environment for Complex Systems).},
  AUTHOR = {Abrial, Jean-Raymond and Butler, Michael and Hallerstede, Stefan and Voisin, Laurent},
  PUBLISHER = {Verlag},
  BOOKTITLE = {ABZ 2008},
  DATE = {2008},
  PAGES = {347--347},
  SERIES = {Lecture Notes in Computer Science},
  TITLE = {A roadmap for the Rodin Toolset},
}

@INPROCEEDINGS{Ha08_283,
  ABSTRACT = {Event-B is a formal modelling method which is claimed to be suitable for diverse modelling domains, such as reactive systems and sequential program development. This claim hinges on the fact that any particular model has an appropriate semantics. In Event-B this semantics is provided implicitly by proof obligations associated with a model. There is no fixed semantics though. In this article we argue that this approach is beneficial to modelling because we can use similar proof obligations across a variety of modelling domains. By way of two examples we show how similar proof obligations are linked to different semantics. A small set of proof obligations is thus suitable for a whole range of modelling problems in diverse modelling domains.},
  AUTHOR = {Hallerstede, Stefan},
  PUBLISHER = {Springer-Verlag},
  BOOKTITLE = {ABZ 2008},
  DATE = {2008},
  PAGES = {125--138},
  SERIES = {Lecture Notes in Computer Science},
  TITLE = {On the Purpose of Event-B Proof Obligations},
}

@ARTICLE{DBLP:journals/tsi/BendispostoLLS08,
  AUTHOR = {Bendisposto, Jens and Leuschel, Michael and Ligot, O. and Samia, Mireille},
  DATE = {2008},
  JOURNALTITLE = {Technique et Science Informatiques},
  NUMBER = {8},
  PAGES = {1065--1084},
  TITLE = {La validation de modèles Event-B avec le plug-in ProB pour RODIN},
  VOLUME = {27},
}

@ARTICLE{BaLeVa07_198,
  ABSTRACT = {We describe the use of a flexible meta-interpreter for performing access control checks on deductive databases. The meta-program is implemented in Prolog and takes as input a database and an access policy specification. For processing access control requests we specialise the meta-program for a given access policy and database by using the Logen partial evaluation system. The resulting specialised control checking program is dependent solely upon dynamic information that can only be known at the time of actual access request evaluation. In addition to describing our approach, we give a number of performance measures for our implementation of an access control checker. In particular, we show that by using our approach we get flexible access control with virtually no overhead, satisfying the Jones optimality criterion. The paper also shows how to satisfy the Jones optimality criterion more generally for interpreters written in the non-ground representation.},
  AUTHOR = {Barker, Steve and Leuschel, Michael and Varea, Mauricio},
  DATE = {2008},
  JOURNALTITLE = {Higher-Order and Symbolic Computation},
  NUMBER = {1--2},
  PAGES = {5--35},
  TITLE = {Efficient and Flexible Access Control via {Jones}-Optimal Logic Program Specialisation},
  VOLUME = {21},
}

@INPROCEEDINGS{LeCaBu09_221,
  ABSTRACT = {ProB is an animation and model checking tool for the B Method, which can deal with many interesting specifications. Some specifications, however, contain complicated functions which cannot be represented explicitly by a tool. We present a scheme with which higher-order recursive functions can be encoded in B, and establish soundness of this scheme. We then describe a symbolic representation for such functions. This representation enables ProB to successfully animate and model check a new class of relevant specifications, where animation is especially important due to the involved nature of the specification.},
  AUTHOR = {Leuschel, Michael and Cansell, Dominique and Butler, Michael},
  EDITOR = {Abrial, Jean-Raymond and Glässer, Uwe},
  PUBLISHER = {Springer-Verlag},
  BOOKTITLE = {Festschrift for Egon Börger},
  DATE = {2009},
  SERIES = {Lecture Notes in Computer Science},
  TITLE = {Validating and Animating Higher-Order Recursive Functions in {B}},
  VOLUME = {5115},
}

@INPROCEEDINGS{BoLeRi09_235,
  ABSTRACT = {We introduce a just-in-time specializer for Prolog. Just-in-time specialization attempts to unify of the concepts and benefits of partial evaluation (PE) and just-in-time (JIT) compilation. It is a variant of PE that occurs purely at runtime, which lazily generates residual code and is constantly driven by runtime feedback. Our prototype is an on-line just-in-time partial evaluator. A major focus of our work is to remove the overhead incurred when executing an interpreter written in Prolog. It improves over classical offline PE by requiring almost no heuristics nor hints from the author of the interpreter; it also avoids most termination issues due to interleaving execution and specialization. We evaluate the performance of our prototype on a small number of benchmarks.},
  AUTHOR = {Bolz, Carl Friedrich and Leuschel, Michael and Rigo, Armin},
  EDITOR = {Schreye, Danny De},
  PUBLISHER = {Springer},
  BOOKTITLE = {Logic-Based Program Synthesis and Transformation, 19th International Symposium, LOPSTR 2009, Coimbra, Portugal, September 2009, Revised Selected Papers},
  DATE = {2009},
  ISBN = {978-3-642-12591-1},
  PAGES = {158--172},
  SERIES = {Lecture Notes in Computer Science},
  TITLE = {Towards Just-In-Time Partial Evaluation of {Prolog}},
  VOLUME = {6037},
}

@INPROCEEDINGS{LeLlOlSiTa09_241,
  ABSTRACT = {This paper describes SOC, a program slicer for CSP specifications. In order to increase the precision of program slicing, SOC uses a new data structure called Context-sensitive Synchronized Control Flow Graph (CSCFG). Given a CSP specification, SOC generates its associated CSCFG and produces from it two different kinds of slices; which correspond to two different static analyses. We present the tool's architecture, its main applications and the results obtained from experiments conducted in order to measure the performance of the tool.},
  AUTHOR = {Leuschel, Michael and Llorens, Marisa and Olivier, Javier and Silva, Josep and Tamarit, Salvador},
  PUBLISHER = {ACM Press},
  BOOKTITLE = {PEPM 2009},
  DATE = {2009},
  TITLE = {{SOC}: A Slicer for {CSP} Specifications},
}

@PROCEEDINGS{LeWe09_243,
  EDITOR = {Leuschel, Michael and Wehrheim, Heike},
  PUBLISHER = {Springer-Verlag},
  DATE = {2009},
  ISBN = {978-3-642-00254-0},
  SERIES = {Lecture Notes in Computer Science},
  TITLE = {Integrated Formal Methods: Proceedings {iFM} 2009},
  VOLUME = {5423},
}

@INPROCEEDINGS{BoCuFiRi09_246,
  ABSTRACT = {We attempt to apply the technique of Tracing JIT Compilers in the context of the PyPy project, i.e. to programs that are interpreters for some dynamic languages, including Python. Tracing JIT compilers can greatly speed up programs that spend most of their time in loops in which they take similar code paths. However, applying an unmodified tracing JIT to a program that is itself a bytecode interpreter results in very limited or no speedup. In this paper we show how to guide tracing JIT compilers to greatly improve the speed of bytecode interpreters. One crucial point is to unroll the bytecode dispatch loop, based on two hints provided by the implementer of the bytecode interpreter. We evaluate our technique by applying it to two PyPy interpreters: one is a small example, and the other one is the full Python interpreter.},
  AUTHOR = {Bolz, Carl Friedrich and Cuni, Antonio and Fijalkowski, Maciej and Rigo, Armin},
  PUBLISHER = {ACM},
  BOOKTITLE = {ICOOOLPS 2009},
  DATE = {2009},
  PAGES = {18--25},
  TITLE = {Tracing the Meta-Level: PyPy's Tracing JIT Compiler},
}

@INPROCEEDINGS{SaLe09_247,
  ABSTRACT = {Visualizing graphs with a large number of edges and vertices can be cumbersome and ineffective. This is due to the presence of countless overlapping arrows, which makes a graph unclear and hard to understand and interpret by a human. The aim of this paper is to try to address this problem using a new concept of data visualization, namely pie tree visualization. We illustrate this technique on the module architecture of a real-life development from the project Deploy. We first describe pie tree visualization, and then, present its advantages.},
  AUTHOR = {Samia, Mireille and Leuschel, Michael},
  PUBLISHER = {Knowledge Systems Institute},
  BOOKTITLE = {Proceedings SEKE},
  DATE = {2009},
  ISBN = {1-891706-24-1},
  PAGES = {400--405},
  TITLE = {Pie Tree Visualization},
}

@INPROCEEDINGS{LeFaFrPl09_248,
  ABSTRACT = {In this paper we describe the successful application of the ProB validation tool on an industrial case study. The case study centres on the San Juan metro system installed by Siemens. The control software was developed and formally proven with B. However, the development contains certain assumptions about the actual rail network topology which have to be validated separately in order to ensure safe operation. For this task, Siemens has developed custom proof rules for AtelierB. AtelierB, however, was unable to deal with about 80 properties of the deployment (running out of memory). These properties thus had to be validated by hand at great expense (and they need to be revalidated whenever the rail network infrastructure changes).<br/> In this paper we show how we were able to use ProB to validate all of the about 300 properties of the San Juan deployment, detecting exactly the same faults automatically in around 17 minutes that were manually uncovered in about one man-month. This achievement required the extension of the ProB kernel for large sets as well as an improved constraint propagation phase. We also outline some of the effort and features that were required in moving from a tool capable of dealing with medium-sized examples towards a tool able to deal with actual industrial specifications. Notably, a new parser and type checker had to be developed. We also touch upon the issue of validating ProB, so that it can be integrated into the SIL4 development chain at Siemens},
  AUTHOR = {Leuschel, Michael and Falampin, Jérôme and Fritz, Fabian and Plagge, Daniel},
  PUBLISHER = {Springer-Verlag},
  BOOKTITLE = {Proceedings FM 2009},
  DATE = {2009},
  PAGES = {708--723},
  SERIES = {Lecture Notes in Computer Science},
  TITLE = {Automated Property Verification for Large Scale {B} Models},
  VOLUME = {5850},
}

@INPROCEEDINGS{PlLeLoRo09_249,
  ABSTRACT = {ProB is a model checker for high-level B and Event-B models based on constraint-solving. In this paper we investigate alternate approaches for validating high-level B models using alternative techniques and tools based on using BDDs, SAT-solving and SMT-solving. In particular, we examine whether PROB can be complemented or even supplanted by using one of the tools BDDBDDB, Kodkod or SAL.},
  AUTHOR = {Plagge, Daniel and Leuschel, Michael and Lopatkin, Ilya and Romanovsky, Alexander},
  BOOKTITLE = {Proceedings AFM 2009},
  DATE = {2009},
  PAGES = {16--22},
  TITLE = {{SAL}, {Kodkod}, and {BDD}s for Validation of {B} Models. Lessons and Outlook},
}

@PROCEEDINGS{DBLP:conf/icfem/2009,
  EDITOR = {Breitman, Karin K. and Cavalcanti, Ana},
  PUBLISHER = {Springer},
  URL = {http://dx.doi.org/10.1007/978-3-642-10373-5},
  DATE = {2009},
  DOI = {10.1007/978-3-642-10373-5},
  ISBN = {978-3-642-10372-8},
  SERIES = {Lecture Notes in Computer Science},
  TITLE = {Formal Methods and Software Engineering, 11th International Conference on Formal Engineering Methods, {ICFEM} 2009, Rio de Janeiro, Brazil, December 9-12, 2009. Proceedings},
  VOLUME = {5885},
}

@INPROCEEDINGS{BeLe09_253,
  ABSTRACT = {With the aid of the ProB Plugin, the Rodin Platform provides an integrated environment for editing, proving, animating and model checking Event-B models. This is of considerable benefit to the modeler, as it allows him to switch between the various tools to validate, debug and improve his or her models. The crucial idea of this paper is that the integrated platform also provides benefits to the tool developer, i.e., it allows easy access to information from other tools. Indeed, there has been considerable interest in combining model checking, proving and testing. In previous work we have already shown how a model checker can be used to complement the Event-B proving environment, by acting as a disprover. In this paper we show how the prover can help improve the efficiency of the animator and model checker.},
  AUTHOR = {Bendisposto, Jens and Leuschel, Michael},
  EDITOR = {Breitman, Karin and Cavalcanti, Ana},
  PUBLISHER = {Springer},
  BOOKTITLE = {Proceedings of ICFEM 2009},
  CROSSREF = {DBLP:conf/icfem/2009},
  DATE = {2009},
  ISBN = {978-3-642-10372-8},
  PAGES = {504--520},
  SERIES = {Lecture Notes in Computer Science},
  TITLE = {Proof Assisted Model Checking for {B}},
  VOLUME = {5885},
}

@INPROCEEDINGS{WiKoRoLeBePlSc09_252,
  ABSTRACT = {Choreography models describe the communication protocols between services. Testing of service choreographies is an important task for the quality assurance of service-based systems as used e.g. in the context of service-oriented architectures (SOA). The formal modeling of service choreographies enables a model-based integration testing (MBIT) approach. We present MBIT methods for our service choreography modeling approach called Message Choreography Models (MCM). For the model-based testing of service choreographies, MCMs are translated into Event-B models and used as input for our test generator which uses the model checker ProB.},
  AUTHOR = {Wieczorek, Sebastian and Kozyura, Vitaly and Roth, Andreas and Leuschel, Michael and Bendisposto, Jens and Plagge, Daniel and Schieferdecker, Ina},
  PUBLISHER = {Springer-Verlag},
  BOOKTITLE = {Proceedings TESTCOM/FATES 2009},
  DATE = {2009},
  PAGES = {179--194},
  SERIES = {Lecture Notes in Computer Science},
  TITLE = {Applying Model Checking to Generate Model-based Integration Tests from Choreography Models},
  VOLUME = {5826},
}

@INPROCEEDINGS{LaBeLe09_258,
  ABSTRACT = {B-MotionStudio provides a way to quickly generate domain specific visualisations for a formal model, enabling domain experts and managers to understand and validate the model. We also believe that our tool will be of use when teaching formal methods, both during lectures as a way to motivate students to write their own formal models.},
  AUTHOR = {Ladenberger, Lukas and Bendisposto, Jens and Leuschel, Michael},
  EDITOR = {Alpuente, Marı́a and Cook, Byron and Joubert, Christophe},
  PUBLISHER = {Springer},
  BOOKTITLE = {Proceedings of FMICS 2009},
  DATE = {2009},
  ISBN = {978-3-642-04569-1},
  PAGES = {202--204},
  SERIES = {Lecture Notes in Computer Science},
  TITLE = {Visualising Event-B Models with B-Motion Studio},
  VOLUME = {5825},
}

@ARTICLE{AbBuHaHoMeVo09_272,
  ABSTRACT = {Event-B is a formal method for system-level modelling and analysis. Key features of Event-B are the use of set theory as a modelling notation, the use of refinement to represent systems at different abstraction levels and the use of mathematical proof to verify consistency between refinement levels. In this article we present the Rodin modelling tool that seamlessly integrates modelling and proving. We outline how the Event-B language was designed to facilitate proof and how the tool has been designed to support changes to models while minimising the impact of changes on existing proofs. We outline the important features of the prover architecture and explain how well-definedness is treated. The tool is extensible and configurable so that it can be adapted more easily to different application domains and development methods.},
  AUTHOR = {Abrial, Jean-Raymond and Butler, Michael and Hallerstede, Stefan and Hoang, Thai Son and Mehta, Farhad and Voisin, Laurent},
  DATE = {2009},
  JOURNALTITLE = {Software Tools for Technology Transfer},
  TITLE = {{Rodin}: An Open Toolset for Modelling and Reasoning in {Event-B}},
}

@ARTICLE{Ha09_271,
  ABSTRACT = {Event-B is a formal modelling method which is claimed to be suitable for diverse modelling domains, such as reactive systems and sequential program development. This claim hinges on the fact that any particular model has an appropriate semantics. In Event-B this semantics is provided implicitly by proof obligations associated with a model. There is no fixed semantics though. In this article we argue that this approach is beneficial to modelling because we can use similar proof obligations across a variety of modelling domains. By way of two examples we show how similar proof obligations are linked to different semantics. A small set of proof obligations is thus suitable for a whole range of modelling problems in diverse modelling domains.},
  AUTHOR = {Hallerstede, Stefan},
  PUBLISHER = {Springer-Verlag},
  DATE = {2009},
  JOURNALTITLE = {Formal Aspects of Computing},
  TITLE = {On the Purpose of {Event-B} Proof Obligations},
}

@INPROCEEDINGS{HaLe09_277,
  ABSTRACT = {Usually we teach formal methods relying for a large part on one kind of reasoning technique about a formal model. For instance, we either use formal proof or we use model-checking. It would appear that it is already hard enough to learn one technique and having to cope with two puts just another burden on the students. This is not our experience. Especially model-checking is easily used to complement formal proof. It only relies on an intuitive operational understanding of a formal model. In this article we show how using model-checking, animation, and formal proof together can be used to improve understanding of formal models. We demonstrate how animation can help finding an explanation for a failing proof. We also demonstrate where animation or model-checking may not help and where proving may not help. For most part use of another tool pays off. Proof obligations present intentionally a static view of a system so that we focus on abstract properties of a model and not on its behaviour. By contrast model-checking provides a more dynamic view based on an operational interpretation. Both views are valuable aids to reasoning about a model.},
  AUTHOR = {Hallerstede, Stefan and Leuschel, Michael},
  PUBLISHER = {Springer-Verlag},
  BOOKTITLE = {TFM 2009},
  DATE = {2009},
  PAGES = {105--124},
  SERIES = {Lecture Notes in Computer Science},
  TITLE = {How to explain mistakes},
}

@INPROCEEDINGS{Ha09_280,
  ABSTRACT = {When teaching Event-B to beginners, we usually start with models that are already good enough, demonstrating occasionally some standard techniques like ``invariant strengthening''. We show that we got it essentially right but need to make improvements here and there. However, this is not how we really create formal models. To a beginner, getting shown only nearly perfect models is overwhelming. So we should start earlier and show how we usually get models wrong initially. This provides ample opportunity to demonstrate the strengths of formal reasoning (and the weaknesses). The principal strength of formal reasoning lies in its capacity to locate mistakes in a model and to suggest corrections. A beginner should learn how to profit from his mistakes by improving his understanding of the model. A weakness of formal reasoning is that we only find mistakes that we expect, for example, invariant violation or non-termination. Mistakes that do not fall into one of these categories may slip through. In this article we present how a formal model is created by refinement and alteration. The approach employs mathematical methodology for problem solving and a software tool. Both aspects are important. Mathematical methodology provides ways to turn mistakes into improvements. The software tool is necessary to ease the impact of changes on a model and to obtain rapid feed back. We begin with a set of assumptions and requirements, the problem, and set out to solve it, giving a more vivid picture of how formal methods work.},
  AUTHOR = {Hallerstede, Stefan},
  PUBLISHER = {University of Nantes},
  BOOKTITLE = {TFM-B 2009},
  DATE = {2009},
  PAGES = {93--108},
  TITLE = {How to make mistakes},
}

@INPROCEEDINGS{Ha09_290,
  ABSTRACT = {The Event-B method can be used to model all sorts of discrete event systems, among them sequential programs. We have made the experience that the minimalist nature of Event-B is of advantage when it comes to tool support and to using proof as a means to analyse a model. The downside of the minimalism is that when models get more complex the lack of structure in the models can make them cluttered with auxiliary variables. System decomposition will not solve this problem. This can not be reasonably applied to a sequential program. In this article we describe our experiences with using Event-B by way of an example. We show how we verified iterative Quicksort in Event-B and intersperse our observations and criticisms. We use them to formulate some suggestions of how we believe Event-B should evolve in future. Some of the minimalism may have to be abandoned in favour of more clarity of the produced formal models.},
  AUTHOR = {Hallerstede, Stefan},
  BOOKTITLE = {Refine 2009},
  DATE = {2009},
  JOURNALTITLE = {ENTCS},
  SERIES = {ENTCS},
  TITLE = {Proving {Quicksort} correct in {Event-B}},
}

@INPROCEEDINGS{Ha09_291,
  ABSTRACT = {Event-B and the Rodin tool use a number of simple techniques that make the modelling method around them effective in practical applications. We present two of these techniques, anticipation and witnesses. It is interesting how a couple of very simple techniques are so important for the method to work. Finally we propose a small enhancement of Event-B that would extend the use of witnesses.},
  AUTHOR = {Hallerstede, Stefan},
  BOOKTITLE = {Proceedings of Dagstuhl Seminar on Refinement Based Methods for the Construction of Dependable Systems (09381)},
  DATE = {2009},
  TITLE = {A (Small) Improvement of {Event-B}?},
}

@INPROCEEDINGS{SaWiBeLe09_307,
  ABSTRACT = {During previous teaching and research experience, we have accumulated anecdotal evidence that using a high-level formalism such as B can be much more productive than using a low-level formalism such as Promela. Furthermore, quite surprisingly, it turned out that the use of a high-level model checker such as prob, was much more effective in practice than using a very efficient model checker such as spin on the corresponding low-level model. In this paper, we try to put this anecdotal evidence on a more firm empirical footing, by systematically comparing the development and validation of B models with the development and validation corresponding Promela models. These experiments have confirmed our previous experience, and show the merits of using a high-level specification language such as B, both in a teaching and in a research environment.},
  AUTHOR = {Samia, Mireille and Wiegard, Harald and Bendisposto, Jens and Leuschel, Michael},
  EDITOR = {Attiogbe and Mery},
  PUBLISHER = {APCB},
  BOOKTITLE = {Proceedings TFM-B 2009},
  DATE = {2009-06},
  ISBN = {2951246102},
  TITLE = {High-Level versus Low-Level Specifications: Comparing {B} with {Promela} and {ProB} with {Spin}},
}

@MISC{pdmc09,
  AUTHOR = {Bendisposto, Jens and Leuschel, Michael},
  DATE = {2009},
  HOWPUBLISHED = {Work in Progress Report at PDMC 2009},
  NOTE = {http://www.pdmc.cz/PDMC09/accepted-papers.shtml},
  TITLE = {Parallel Model Checking of Event-B Specification with ProB},
}

@INPROCEEDINGS{LeuschelTamaritVidal_WFLP09,
  AUTHOR = {Leuschel, Michael and Tamarit, Salvador and Vidal, Germán},
  EDITOR = {Escobar, Santiago},
  PUBLISHER = {Springer-Verlag},
  BOOKTITLE = {Proceedings WFLP'2009},
  DATE = {2010},
  PAGES = {111--127},
  SERIES = {LNCS 5979},
  TITLE = {Fast and Accurate Strong Termination Analysis with an Application to Partial Evaluation},
}

@INPROCEEDINGS{abz-HaLePl2010,
  ABSTRACT = {We provide a detailed description of refinement in Event-B, both as a contribution in itself and as a foundation for the approach to simultaneous animation of multiple levels of refinement that we propose. We present an algorithm for simultaneous multi-level animation of refinement, and show how it can be used to detect a variety of errors that occur frequently when using refinement. The algorithm has been implemented in ProB and we applied it to several case studies, showing that multi-level animation is tractable also on larger models.},
  AUTHOR = {Hallerstede, Stefan and Leuschel, Michael and Plagge, Daniel},
  PUBLISHER = {Springer-Verlag},
  BOOKTITLE = {Proceedings ABZ'2010},
  DATE = {2010},
  PAGES = {287--301},
  SERIES = {Lecture Notes in Computer Science},
  TITLE = {Refinement-Animation for {Event-B} - Towards a Method of Validation},
  VOLUME = {5977},
}

@INPROCEEDINGS{TuBuLe2010,
  ABSTRACT = {Symmetry reduction is a model checking technique that can help alleviate the problem of state space explosion, by preventing redundant state space exploration. In previous work, we have developed three effective approaches to symmetry reduction for B that have been implemented into the ProB model checker, and we have proved the soundness of our state symmetries. However, it is also important to show our techniques are sound with respect to standard model checking, at the algorithmic level. In this paper, we present a retrospective B development that addresses this issue through a series of B refinements. This work also demonstrates the valuable insights into a system that can be gained through formal modelling.},
  AUTHOR = {Turner, Edd and Butler, Michael and Leuschel, Michael},
  PUBLISHER = {Springer-Verlag},
  BOOKTITLE = {Proceedings ABZ'2010},
  DATE = {2010},
  ISBN = {978-3-642-11810-4},
  PAGES = {231--244},
  SERIES = {Lecture Notes in Computer Science},
  TITLE = {A Refinement-Based Correctness Proof of Symmetry Reduced Model Checking},
  VOLUME = {5977},
}

@INPROCEEDINGS{abz-Ha2010,
  ABSTRACT = {Event-B does not provide specific support for the modelling of problems that require some structuring, such as, local variables or sequential ordering of events. All variables need to be declared globally and sequential ordering of events can only be achieved by abstract program counters. This has two unfortunate consequences: such models become less comprehensible - we have to infer sequential ordering from the use of program counters; proof obligation generation does not consider ordering - generating too many proof obligations (although these are usually trivially discharged). In this article we propose a method for specifying structured models avoiding, in particular, the use of abstract program counters. It uses a notation that mainly serves to drive proof obligation generation. However, the notation also describes the structure of a model explicitly. A corresponding graphical notation is introduced that visualises the structure of a model.},
  AUTHOR = {Hallerstede, Stefan},
  PUBLISHER = {Springer-Verlag},
  BOOKTITLE = {ABZ 2010},
  DATE = {2010},
  SERIES = {Lecture Notes in Computer Science},
  TITLE = {Structured {Event-B} Models and Proofs},
}

@ARTICLE{PlLe2010,
  ABSTRACT = {The size of formal models is steadily increasing and there is a demand from industrial users to be able to use expressive temporal query languages for validating and exploring high-level formal specifications. We present an extension of LTL, which is well adapted for validating B, Z and CSP specifications. We present a generic, flexible LTL model checker, implemented inside the ProB tool, that can be applied to a multitude of formalisms such as B, Z, CSP, B CSP, as well as Object Petri nets, compensating CSP, and dSL. Our algorithm can deal with deadlock states, partially explored state spaces, past operators, and can be combined with existing symmetry reduction techniques of ProB. We establish correctness of our algorithm in general, as well as combined with symmetry reduction. Finally, we present various applications and empirical results of our tool, showing that it can be applied successfully in practice.},
  AUTHOR = {Plagge, Daniel and Leuschel, Michael},
  PUBLISHER = {Springer-Verlag},
  DATE = {2010-02},
  ISSN = {1433-2779},
  JOURNALTITLE = {Software Tools for Technology Transfer (STTT)},
  NUMBER = {1},
  PAGES = {9--21},
  TITLE = {Seven at one stroke: {LTL} model checking for High-level Specifications in {B}, {Z}, {CSP}, and more},
  VOLUME = {12},
}

@ARTICLE{LeMa2010,
  ABSTRACT = {We present a new approximate verification technique for falsifying the invariants of B models. The technique employs symmetry of B models induced by the use of deferred sets. The basic idea is to efficiently compute markers for states, so that symmetric states are guaranteed to have the same marker (but not the other way around).<br/> The falsification algorithm then assumes that two states with the same marker can be considered symmetric. We describe how symmetry markers can be efficiently computed and empirically evaluate an implementation, showing both very good performance results and a high degree of precision (i.e., very few non-symmetric states receive the same marker).<br/> We also identify a class of B models for which the technique is precise and therefore provides an efficient and complete verification method. Finally, we show that the technique can be applied to Z models as well.},
  AUTHOR = {Leuschel, Michael and Massart, Thierry},
  DATE = {2010},
  JOURNALTITLE = {Annals of Mathematics and Artificial Intelligence},
  NUMBER = {1},
  PAGES = {81--106},
  TITLE = {Efficient Approximate Verification of {B} via Symmetry Markers},
  VOLUME = {59},
}

@INPROCEEDINGS{BoLeSch2010,
  ABSTRACT = {Most Prolog implementations are implemented in low-level languages such as C and are based on a variation of the WAM instruction set, which enhances their performance but makes them hard to write. We present a high-level continuation-based Prolog interpreter written in RPython, a restricted subset of Python. This interpreter is annotated with hints, so that it can be fed through the PyPy tracing JIT generator, which incorporates partial evaluation techniques. The resulting Prolog implementation is surprisingly efficient: it clearly outperforms existing implementations of Prolog in high-level languages such as Java. Moreover, on some benchmarks, our system outperforms state-of-the-art WAM-based Prolog implementations. Our paper tries to show that PyPy can indeed form the basis for implementing programming languages other than Python. Furthermore, we believe that our results showcase the great potential of the tracing JIT approach for declarative programming languages},
  AUTHOR = {Bolz, Carl Friedrich and Leuschel, Michael and Schneider, David},
  LOCATION = {Hagenberg, Austria},
  PUBLISHER = {ACM},
  BOOKTITLE = {PPDP '10 - Proceedings of the 12th international ACM SIGPLAN symposium on Principles and practice of declarative programming},
  DATE = {2010},
  TITLE = {Towards a Jitting {VM} for Prolog Execution},
}

@INPROCEEDINGS{SchBoLe2010,
  AUTHOR = {Schneider, David and Bolz, Carl Friedrich and Leuschel, Michael},
  LOCATION = {Málaga, Spain},
  BOOKTITLE = {DYLA 2010 - 4th Workshop on Dynamic Languages and Applications},
  DATE = {2010},
  TITLE = {Jitting Prolog for Fun and Profit},
}

@INPROCEEDINGS{LeBe2010,
  ABSTRACT = {ProB is a model checker for high-level formalisms such as B, Event-B, CSP and Z. ProB uses a mixed depth-first/breadth-first search strategy, and in previous work we have argued that this can perform better in practice than pure depth-first or breadth-first search, as employed by low-level model checkers. In this paper we present a thorough empirical evaluation of this technique, which confirms our conjecture. The experiments were conducted on a wide variety of B and Event-B models, including several industrial case studies. Furthermore, we have extended ProB to be able to perform directed model checking, where each state is associated with a priority computed by a heuristic function. We evaluate various heuristic functions, on a series of problems, and find some interesting candidates for detecting deadlocks and finding specific target states.},
  AUTHOR = {Leuschel, Michael and Bendisposto, Jens},
  EDITOR = {Davies, Jim and Silva, Leila and da Silva Simão, Adenilso},
  PUBLISHER = {Springer},
  BOOKTITLE = {SBMF'2010},
  DATE = {2010},
  PAGES = {1--16},
  SERIES = {Lecture Notes in Computer Science},
  TITLE = {Directed Model Checking for {B}: An Evaluation and New Techniques},
  VOLUME = {6527},
}

@ARTICLE{JastramProR2010,
  ABSTRACT = {Proper tool support in requirements engineering is important. A number of proprietary solutions are available in the market place, but few open solutions, and none that are widespread at this time.<br> In this paper, we introduce ProR, an open platform for requirements engineering. The project was initiated by the EU FP7 Project ``Deploy'', which has the goal to make major advances in engineering methods for dependable systems through the deployment of formal engineering methods. Rather than building a project-specific solution, we decided to develop an extensible, general purpose platform.<br> We based the tool's data model on the Requirements Interchange Format (RIF / ReqIF), a standard driven by the automotive industry. This gives us interoperability with a number of existing tools. The tool is based on the Eclipse Platform and uses the Eclipse Modeling Framework (EMF). We managed to establish a cooperation with the ITEA-Project ``Verde'', which supplied the implementation of the RIF data model.<br> In this paper, we will introduce the tool, describe its architecture, and present a small case study. ProR is still under development, and we welcome contributors and are very interested in potential users to validate our approach. Please visit www.pror.org for more information, and to download the current development version.},
  AUTHOR = {Jastram, Michael},
  DATE = {2010},
  JOURNALTITLE = {SEISCONF},
  TITLE = {{ProR}, an Open Source Platform for Requirements Engineering based on {RIF}},
}

@PROCEEDINGS{avocs2010,
  EDITOR = {Bendisposto, Jens and Leuschel, Michael and Roggenbach, Markus and Hallerstede, Stefan and Butler, Michael and Voisin, Laurent},
  DATE = {2010},
  TITLE = {Proceedings of {AVoCS} 2010 and {Rodin} 2010},
}

@REPORT{gepavas1,
  AUTHOR = {Bendisposto, Jens and Leuschel, Michael and Borgermans, Markus},
  INSTITUTION = {University of Düsseldorf},
  DATE = {2010},
  TITLE = {{GEPAVAS} Gerichtete und parallele Validierung von abstrakten Spezifikationen - Projektreport},
  TYPE = {techreport},
}

@ARTICLE{LeFaFrPl2011,
  ABSTRACT = {In this paper we describe the successful application of the ProB validation tool for several industrial applications. The initial case study centred on the San Juan metro system installed by Siemens. The control software was developed and formally proven with B. However, the development contains certain assumptions about the actual rail network topology which have to be validated separately in order to ensure safe operation. For this task, Siemens has developed custom proof rules for Atelier B. Atelier B, however, was unable to deal with about 80 properties of the deployment (running out of memory). These properties thus had to be validated by hand at great expense (and they need to be revalidated whenever the rail network infrastructure changes).<br/> In this paper we show how we were able to use ProB to validate all of the about 300 properties of the San Juan deployment, detecting exactly the same faults automatically in a few minutes that were manually uncovered in about one man-month. We have repeated this task for three ongoing projects at Siemens, notably the ongoing automatisation of the line 1 of the Paris Metro. Here again, about a man month of effort has been replaced by a few minutes of computation.<br/> This achievement required the extension of the ProB kernel for large sets as well as an improved constraint propagation phase. We also outline some of the effort and features that were required in moving from a tool capable of dealing with medium-sized examples towards a tool able to deal with actual industrial specifications. We also describe the issue of validating ProB, so that it can be integrated into the SIL4 development chain at Siemens.},
  AUTHOR = {Leuschel, Michael and Falampin, Jérôme and Fritz, Fabian and Plagge, Daniel},
  DATE = {2011},
  JOURNALTITLE = {Formal Aspects of Computing},
  NUMBER = {6},
  PAGES = {683--709},
  TITLE = {Automated Property Verification for Large Scale {B} Models with {ProB}},
  VOLUME = {23},
}

@ARTICLE{SPE1016,
  ABSTRACT = {Initially, the Rodin platform for Event-B did away with a textual representation for models. In this paper, we explain why a textual representation was required after all and we present the semantic-aware text editor Camille for Rodin. We explain the design choices of Camille, such as splitting the syntax into two-levels for machine and formula syntax. We also describe the challenges, such as synchronizing the textual representation with the Rodin database, and how they were overcome using an EMF abstraction layer.},
  AUTHOR = {Bendisposto, Jens and Fritz, Fabian and Jastram, Michael and Leuschel, Michael and Weigelt, Ingo},
  PUBLISHER = {John Wiley & Sons, Ltd.},
  URL = {http://dx.doi.org/10.1002/spe.1016},
  DATE = {2011},
  DOI = {10.1002/spe.1016},
  ISSN = {1097-024X},
  JOURNALTITLE = {Software: Practice and Experience},
  KEYWORDS = {formal methods,Event-B,tools,Rodin},
  NUMBER = {2},
  PAGES = {189--198},
  TITLE = {Developing {Camille}, a text editor for {Rodin}},
  VOLUME = {41},
}

@REPORT{tr-JaGr2011,
  ABSTRACT = {Requirements engineering (RE) is a crucial aspect in systems development and is the area of ongoing research and process improvement. However, unlike in modelling, there has been no established standard that activities could converge on.<br> In recent years, the emerging Requirements Interchange Format (RIF/ReqIF) gained more and more visibility in industry, and research projects start to investigate these standards. To avoid redundant efforts in implementing the standard, the VERDE and Deploy projects cooperate to provide a stable common basis for RIF/ReqIF that could be leveraged by other research projects too. In this paper, we present an Eclipse-based extensible implementation of a RIF/ReqIF-based requirements editing platform.<br> In addition, we are concerned with two related aspects of RE that take advantage of the common platform. First, how can the quality of requirements be improved by replacing or complementing natural language requirements with formal approaches such as domain specific languages or models. Second, how can we establish robust traceability that links requirements and model constructs and other artefacts of the development process. We present two approaches to traceability and two approaches to modelling.<br> We believe that our research represents a significant contribution to the existing tooling landscape, as it is the first clean-room implementation of the RIF/ReqIF standard. We believe that it will help reduce gaps in often heterogeneous tool chains and inspire new conceptual work and new tools.},
  AUTHOR = {Jastram, Michael and Graf, Andreas},
  INSTITUTION = {Dagstuhl-Workshop MBEES 2011: Modellbasierte Entwicklung eingebetteter Systeme},
  DATE = {2011},
  TITLE = {Requirements, Traceability and {DSLs} in {Eclipse} with the Requirements Interchange Format ({RIF/ReqIF})},
  TYPE = {techreport},
}

@ARTICLE{topcase-JaGr2011,
  ABSTRACT = {One important step of the systems engineering process is requirements engineering. Parallel to the development of Topcased, which includes tooling for requirements engineering, a new standard for requirements exchange is emerging at the OMG under the name “ReqIF” (formally called RIF). In our talk we introduce the activities of two research projects and their tool developments, VERDE (Yakindu Requirements) and Deploy (ProR) and discuss possible synergies with Topcased.},
  AUTHOR = {Jastram, Michael and Graf, Andreas},
  DATE = {2011},
  JOURNALTITLE = {First Topcased Days Toulouse},
  TITLE = {Requirement Traceability in {Topcased} with the Requirements Interchange Format ({RIF}/{ReqIF})},
}

@INPROCEEDINGS{flow2011,
  ABSTRACT = {In Event-B a system is developed using refinement. The language is based on a relatively small core; in particular there is only a very small number of substitutions. This results in much simpler proof obligations, that can be handled by automatic tools. However, the downside is that, in case of software development, structural information is not explicitly available but hidden in the chain of refinements. This paper discusses a method to uncover these implicit algorithmic structures and use them in a model checker. Other applications are code generation, model comprehension, and testcase generation.},
  AUTHOR = {Bendisposto, Jens and Leuschel, Michael},
  EDITOR = {Giannakopoulou, Dimitra and Orejas, Fernando},
  PUBLISHER = {Springer},
  BOOKTITLE = {Proceedings of Fundamental Approaches to Software Engineering (FASE) 2011},
  DATE = {2011},
  ISBN = {3642198104},
  PAGES = {50--64},
  SERIES = {Lecture Notes in Computer Science},
  TITLE = {Automatic Flow Analysis for {Event-B}},
  VOLUME = {6603},
}

@ARTICLE{HaLe2011,
  ABSTRACT = {Establishing the absence of deadlocks is important in many applications of formal methods. The use of model checking for finding deadlocks in formal models is limited because in many industrial applications the state space is either infinite or much too large to be explored exhaustively.<br/> In this paper we propose a constraint-based approach to finding deadlocks employing the ProB constraint solver to find values for the constants and variables of formal models that describe a deadlocking state. We present the general technique, as well as various improvements that had to be performed on ProB's Prolog kernel, such as reification of membership and arithmetic constraints.<br/> ProB typically finds counter examples to deadlock-freedom constraints, a formula of about 900 partly nested conjunctions and disjunction among them 80 arithmetic and 150 set-theoretic predicates (in total a formula of 30 pages), in under two seconds.<br/> We also present other successful applications of this new technique, in particular to BPEL processes. Experiments using SAT and SMT solvers on these constraints were thus far unsuccessful.},
  AUTHOR = {Hallerstede, Stefan and Leuschel, Michael},
  PUBLISHER = {Cambridge University Press},
  BOOKTITLE = {Proceedings ICLP'2011},
  DATE = {2011},
  JOURNALTITLE = {Theory and Practice of Logic Programming},
  NUMBER = {4--5},
  PAGES = {767--782},
  TITLE = {Constraint-Based Deadlock Checking of High-Level Specifications},
  VOLUME = {11},
}

@INPROCEEDINGS{HaLeBW2011,
  ABSTRACT = {Establishing the absence of deadlocks is important in many applications of formal methods. The use of model checking for finding deadlocks in formal models is limited because in many industrial applications the state space is either infinite or much too large to be explored exhaustively. In this paper we propose a constraint-based approach to finding deadlocks employing the ProB constraint solver to find values for the constants and variables of formal models that describe a deadlocking state. We discuss the principles of the technique implemented in ProB's Prolog kernel and present some results of a larger case study to which we have applied the approach.},
  AUTHOR = {Hallerstede, Stefan and Leuschel, Michael},
  BOOKTITLE = {B2011 Workshop (short paper)},
  DATE = {2011},
  TITLE = {Finding Deadlocks of Event-B Models by Constraint Solving},
}

@INPROCEEDINGS{JaHaLeRu2010,
  ABSTRACT = {Formal modeling of computing systems yields models that are intended to be correct with respect to the requirements that have been formalized. The complexity of typical computing systems can be addressed by formal refinement introducing all the necessary details piecemeal. We report on preliminary results that we have obtained for tracing informal natural-language requirements into formal models across refinement levels. The approach uses the WRSPM reference model for requirements modeling, and Event-B for formal modeling and formal refinement. The combined use of WRSPM and Event-B is facilitated by the rudimentary refinement notion of WRSPM, which provides the foundation for tracing requirements to formal refinements.<br> We assume that requirements are evolving, meaning that we have to cope with frequent changes of the requirements model and the formal model. Our approach is capable of dealing with frequent changes, making use of corresponding techniques already built into the Event-B method.},
  AUTHOR = {Jastram, Michael and Hallerstede, Stefan and Leuschel, Michael and Jr, Aryldo G Russo},
  PUBLISHER = {Springer},
  BOOKTITLE = {VSTTE},
  DATE = {2010},
  ISBN = {978-3-642-15056-2},
  PAGES = {97--111},
  SERIES = {Lecture Notes in Computer Science},
  TITLE = {An Approach of Requirements Tracing in Formal Refinement},
  VOLUME = {6217},
}

@ARTICLE{HaLePl2011refanim,
  ABSTRACT = {We provide a detailed description of refinement in Event-B, both as a contribution in itself and as a foundation for the approach to simultaneous animation of multiple levels of refinement that we propose. We present an algorithm for simultaneous multi-level animation of refinement, and show how it can be used to detect a variety of errors that occur frequently when using refinement. The algorithm has been implemented in ProB and we applied it to several case studies, showing that multi-level animation is tractable also on larger models. We present empirical results and discuss how the algorithm can be combined with symmetry reduction.},
  AUTHOR = {Hallerstede, Stefan and Leuschel, Michael and Plagge, Daniel},
  DATE = {2013},
  DOI = {DOI: 10.1016/j.scico.2011.03.005},
  ISSN = {0167-6423},
  JOURNALTITLE = {Science of Computer Programming},
  NUMBER = {3},
  PAGES = {272--292},
  TITLE = {Validation of Formal Models by Refinement Animation},
  VOLUME = {78},
}

@INPROCEEDINGS{BoCuFiLePeRi2011,
  ABSTRACT = {The performance of many dynamic language implementations suffers from high allocation rates and runtime type checks. This makes dynamic languages less applicable to purely algorithmic problems, despite their growing popularity. In this paper we present a simple compiler optimization based on online partial evaluation to remove object allocations and runtime type checks in the context of a tracing {JIT.} We evaluate the optimization using a Python {VM} and find that it gives good results for all our (real-life) benchmarks.},
  AUTHOR = {Bolz, Carl Friedrich and Cuni, Antonio and Fijałkowski, Maciej and Leuschel, Michael and Pedroni, Samuele and Rigo, Armin},
  LOCATION = {Austin, Texas, {USA}},
  BOOKTITLE = {{PEPM}},
  DATE = {2011},
  KEYWORDS = {code generation,experimentation,interpreters,languages,optimization,partial evaluation,performance,run-time environments,tracing jit},
  TITLE = {Allocation removal by partial evaluation in a tracing {JIT}},
}

@ARTICLE{Jas11,
  ABSTRACT = {Gute Werkzeugunterstützung ist ein wichtiger Aspekt im Requirements Engineering. Es gibt zwar ein breites kommerzielles Angebot, aber wenige offene Lösungen. ProR ist eine OpenSource Software zum Arbeiten mit natürlichsprachigen Anforderungen. Es basiert auf dem Requirements Interchange Format (RIF), womit wir die Interoperabilität mit anderen Werkzeugen gewährleisten. Wir legen großen Wert auf die Erweiterbarkeit der Plattform, was wir mit einem Integrations-Plugin für die formale Event-B-Methode belegen.},
  AUTHOR = {Jastram, Michael},
  PUBLISHER = {Gesellschaft für Informatik (GI)},
  URL = {http://pi.informatik.uni-siegen.de/stt/31_1/index.html},
  DATE = {2011},
  ISSN = {0720-8928},
  JOURNALTITLE = {Softwaretechnik-Trends},
  NUMBER = {1},
  TITLE = {ProR - Eine Softwareplattform für Requirements Engineering},
  VOLUME = {31},
}

@INPROCEEDINGS{GmehlichGHLLP11,
  ABSTRACT = {The development of the Event-B formal method and the supporting tools Rodin and ProB was guided by practical experiences with the B-Method, the Z specification notation, VDM and similar practical formal methods. The case study discussed in this article -- a cruise control system -- is a serious test of industrial use. We report on where Event-B and its tools have succeeded, where they have not. We also report on advances that were inspired by the case study. Interestingly, the case study was not a pure formal methods problem. In addition to Event-B, it used Problem Frames for capturing requirements. The interaction between the two proved to be crucial for the success of the case study. The heart of the problem was tracing informal requirements from Problem Frames descriptions to formal Event-B models. To a large degree, this issue dictated the approach that had to be used for formal modelling. A dedicated record theory and dedicated tool support were required. The size of the formal models rather than complex individual formulas was the main challenge for tool support.},
  AUTHOR = {Gmehlich, Rainer and Grau, Katrin and Hallerstede, Stefan and Leuschel, Michael and Lösch, Felix and Plagge, Daniel},
  EDITOR = {Qin, Shengchao and Qiu, Zongyan},
  PUBLISHER = {Springer},
  BOOKTITLE = {Proceedings ICFEM'2011},
  DATE = {2011},
  ISBN = {978-3-642-24558-9},
  PAGES = {195--210},
  SERIES = {Lecture Notes in Computer Science},
  TITLE = {On Fitting a Formal Method into Practice},
  VOLUME = {6991},
}

@INPROCEEDINGS{BoCuFiLePeRi11,
  ABSTRACT = {Meta-tracing JIT compilers can be applied to a variety of differ- ent languages without explicitly encoding language semantics into the compiler. So far, they lacked a way to give the language im- plementor control over runtime feedback. This restricted their per- formance. In this paper we describe the mechanisms in PyPy’s meta-tracing JIT that can be used to control runtime feedback in language-specific ways. These mechanisms are flexible enough to express classical VM techniques such as maps and runtime type feedback.},
  AUTHOR = {Bolz, Carl Friedrich and Cuni, Antonio and Fijałkowski, Maciej and Leuschel, Michael and Pedroni, Samuele and Rigo, Armin},
  BOOKTITLE = {Proceedings of the 6th workshop on the Implementation, Compilation, Optimization of Object-Oriented Languages and Programming Systems},
  DATE = {2011},
  SERIES = {ICOOOLPS '11},
  TITLE = {Runtime Feedback in a Meta-Tracing {JIT} for Efficient Dynamic Languages},
}

@INPROCEEDINGS{JasHalLad2011,
  ABSTRACT = {Tracing between informal requirements and formal models is challenging. A method for such tracing should permit to deal efficiently with changes to both the requirements and the model. A particular challenge is posed by the persisting interplay of formal and informal elements. <br> In this paper, we describe an incremental approach to requirements validation and systems modelling. Formal modelling facilitates a high degree of automation: it serves for validation and traceability.<br> The foundation for our approach are requirements that are structured according to the WRSPM reference model. We provide a system for traceability with a state-based formal method that supports refinement. We do not require all specification elements to be modelled formally and support incremental incorporation of new specification elements into the formal model. Refinement is used to deal with larger amounts of requirements in a structured way.<br> We provide a small example using Problem Frames and Event-B to demonstrate our approach.},
  AUTHOR = {Jastram, Michael and Hallerstede, Stefan and Ladenberger, Lukas},
  DATE = {2011},
  SERIES = {AVOCS 2011},
  TITLE = {Mixing Formal and Informal Model Elements for Tracing Requirements},
}

@ARTICLE{abs-1210-6815,
  AUTHOR = {Lecomte, Thierry and Burdy, Lilian and Leuschel, Michael},
  BOOKTITLE = {Proceedings DS-EventB'2012},
  DATE = {2012},
  JOURNALTITLE = {CoRR},
  TITLE = {Formally Checking Large Data Sets in the Railways},
  VOLUME = {abs/1210.6815},
}

@INPROCEEDINGS{HansenLeuschelTLA2012,
  ABSTRACT = {TLA+ and B share the common base of predicate logic, arithmetic and set theory. However, there are still considerable differences, such as very different approaches to typing and modularization. There is also considerable difference in the available tool support. In this paper, we present a translation of the non-temporal part of TLA+ to B, which makes it possible to feed TLA+ specifications into existing tools for B. Part of this translation must include a type inference algorithm, in order to produce typed B specifications. There are many other tricky aspects, such as translating modules as well as let and if-then-else expressions. We also present an integration of our translation into ProB. ProB thus provides a complementary tool to the explicit state model checker TLC, with convenient animation and constraint solving for TLA+. We also present a series of case studies, highlighting the complementarity to TLC. In particular, we highlight the sometimes dramatic difference in performance when it comes to solving complicated constraints in TLA+.},
  AUTHOR = {Hansen, Dominik and Leuschel, Michael},
  PUBLISHER = {Springer},
  BOOKTITLE = {Proceedings iFM'2012},
  DATE = {2012-06},
  PAGES = {24--38},
  SERIES = {LNCS 7321},
  TITLE = {Translating {TLA+} to {B} for Validation with {ProB}},
}

@INPROCEEDINGS{PlaggeLeuschel_Kodkod2012,
  ABSTRACT = {We present the integration of the Kodkod high-level interface to SAT-solvers into the kernel of ProB. As such, predicates from B, Event-B, Z and TLA+ can be solved using a mixture of SAT-solving and ProB's own constraint-solving capabilities developed using constraint logic programming: the first-order parts which can be dealt with by Kodkod and the remaining parts solved by the existing ProB kernel. We also present an extensive empirical evaluation and analyze the respective merits of SAT-solving and classical constraint solving. We also compare to using SMT solvers via recently available translators for Event-B.},
  AUTHOR = {Plagge, Daniel and Leuschel, Michael},
  EDITOR = {Giannakopoulou, Dimitra and Méry, Dominique},
  PUBLISHER = {Springer},
  BOOKTITLE = {Proceedings FM'2012},
  DATE = {2012-08},
  PAGES = {372--386},
  SERIES = {LNCS 7436},
  TITLE = {Validating {B}, {Z} and {TLA+} using {ProB} and {Kodkod}},
}

@UNPUBLISHED{LadenbergerJastram_iFMABZ2012,
  ABSTRACT = {<p>Traceability within a system description is a challenging problem of requirements engineering. In particular, formal models of the system are often based on informal requirements, but creating and maintaining the traceability between the two can be challenging. Previously, we presented an incremental approach for producing a system description from an initial set of requirements. The foundation of the approach is a classification of requirements into artefacts W (domain properties), R (requirements) and S (specification). In addition, the approach uses designated phenomena as the vocabulary employed by the artefacts. The central idea is that adequacy of the system description must be justified, meaning that W /\ S => R. The approach establishes a traceability, and the resulting system description may consist of formal and informal artefacts.</p><p>We created tool support for this approach by integrating Rodin and ProR ...</p>},
  AUTHOR = {Ladenberger, Lukas and Jastram, Michael},
  DATE = {2012-06},
  NOTE = {Accepted for iFM'2012},
  TITLE = {Requirements Traceability between Textual Requirements and Formal Models Using ProR},
}

@REPORT{Weigelt2012,
  ABSTRACT = {<p>Rodin is a platform for Event-B modelling. Its native editor is a structural editor that allows the modification of a tree-like model.</p> <p>Especially for large models, some users found the default editor inadequate and preferred a text-based editor. Such an editor, called Camille, was created by Fabian Fritz in 2009 and was a huge success.</p> <p>Nevertheless, Camille does not directly support extensions for Rodin. As more and more extensions are being created, this became a larger issue over the years.</p> <p>This report analyses how Camille extensibility can be achieved. It analyses a number of different architectures and compares their mutual advantages and disadvantages.</p> <p>This paper discusses four different approaches. Out of these, we find two particularly promising. The first option would be the implementation of a block parser that provides a useful default implementation for plug-in developers and a pleasing syntax to editor users. The second option is the use of an existing syntax like YAML. This solution could be extended all the way to the persistence layer of Rodin, thereby simplifying the back end significantly. But such an effort would require additional resources. Nevertheless, the result would simplify maintenance of the platform significantly in the long run.</p>},
  AUTHOR = {Weigelt, Ingo},
  INSTITUTION = {University of Düsseldorf},
  DATE = {2012-04},
  TITLE = {Architectures for an Extensible Text Editor for Rodin},
  TYPE = {techreport},
}

@REPORT{tr-JaGr2012,
  AUTHOR = {Jastram, Michael and Graf, Andreas},
  INSTITUTION = {Commercial Vehicle Technology Symposium},
  DATE = {2012},
  TITLE = {ReqIF – the new Requirements Standard and its Open Source implementation Eclipse RMF},
  TYPE = {techreport},
}

@INPROCEEDINGS{schneider_efficient_2012,
  ABSTRACT = {Tracing just-in-time (JIT) compilers record linear control flow paths, inserting operations called guards at points of possible divergence. These operations occur frequently in generated traces and therefore it is important to design and implement them carefully to find the right trade-off between deoptimization, memory overhead, and (partly) execution speed. In this paper, we perform an empirical analysis of runtime properties of guards. This is used to guide the design of guards in the RPython tracing JIT.},
  AUTHOR = {Schneider, David and Bolz, Carl Friedrich},
  BOOKTITLE = {VMIL, accepted for publication},
  DATE = {2012},
  TITLE = {The Efficient Handling of Guards in the Design of {RPython’s} Tracing {JIT}},
}

@BOOK{jastram-thesis-2012,
  ABSTRACT = {<p>Creating a system description of high quality is still a challenging problem in the field of requirements engineering. Creating a formal system description addresses some issues. However, the relationship of the formal model to the user requirements is rarely clear, or documented satisfactorily.</p> <p>This work presents the ProR approach, an approach for the creation of a consistent system description from an initial set of requirements. The resulting system description is a mixture of formal and informal artefacts. Formal and informal reasoning is employed to aid in the process. To achieve this, the artefacts must be connected by traces to support formal and informal reasoning, so that conclusions about the system description can be drawn.</p> <p>The ProR approach enables the incremental creation of the system description, alternating between modelling (both formal and informal) and validation. During this process, the necessary traceability for reasoning about the system description is established. The formal model employs refinement for further structuring of large and complex system descriptions. The development of the ProR approach is the first contribution of this work.</p> <p>This work also presents ProR, a tool platform for requirements engineering, that supports the ProR approach. ProR has been integrated with Rodin, a tool for Event-B modelling, to provide a number of features that allow the ProR approach to scale.</p> <p>The core features of ProR are independent from the ProR approach. The data model of ProR builds on the international ReqIF standard, which provides interoperability with industrial tools for requirements engineering. The development of ProR created enough interest to justify the creation of the Requirements Modeling Framework (RMF), a new Eclipse Foundation project, which is the open source host for ProR. RMF attracted an active community, and ProR development continues. The development of ProR is the second contribution of this work.</p> <p>This work is accompanied by a case study of a traffic light system, which demonstrates the application of both the ProR approach and ProR.</p>},
  AUTHOR = {Jastram, Michael},
  INSTITUTION = {Heinrich-Heine University Dusseldorf},
  PUBLISHER = {CreateSpace},
  DATE = {2012},
  SERIES = {Inaugural-Dissertation},
  TITLE = {The ProR Approach: Traceability of Requirements and System Descriptions},
}

@INPROCEEDINGS{ebert_jastram_reqif_2012,
  ABSTRACT = {The primary sources of project risks and product problems are poor, missing, or changing requirements. Often, the underlying root cause is insufficient collaboration between business partners. This article provides insight into how to effectively collaborate in requirements engineering. We describe the Requirements Interchange Format (ReqIF) standard and technologies for seamless requirements development and management. We look forward to hearing from both readers and prospective column authors about this and the technologies and tools you want to know more about.},
  AUTHOR = {Christof Ebert, Michael Jastram},
  BOOKTITLE = {{IEEE Software}},
  DATE = {2012-10},
  PAGES = {82--87},
  TITLE = {{ReqIF: Seamless Requirements Interchange Format between Business Partners}},
}

@INPROCEEDINGS{ardo_loop-aware_2012,
  ABSTRACT = {<p>One of the nice properties of a tracing just-in-time compiler (JIT) is that many of its optimizations are simple, requiring one forward pass only. This is not true for loop-invariant code motion which is a very important optimization for code with tight kernels. Especially for dynamic languages that typically perform quite a lot of loop invariant type checking, boxed value unwrapping and virtual method lookups.</p> <p>In this paper we explain a scheme pioneered within the context of the LuaJIT project for making basic optimizations loop-aware by using a simple pre-processing step on the trace without changing the optimizations themselves.</p> <p>We have implemented the scheme in RPython's tracing JIT compiler. PyPy's Python JIT executing simple numerical kernels can become up to two times faster, bringing the performance into the ballpark of static language compilers.</p>},
  AUTHOR = {Ardö, Håkan and Bolz, Carl Friedrich and Fijałkowski, Maciej},
  BOOKTITLE = {{DLS}},
  DATE = {2012-10},
  NOTE = {Accepted for publication},
  TITLE = {Loop-Aware Optimizations in {PyPy’s} Tracing {JIT}},
}

@INPROCEEDINGS{jastram_forms_2012,
  ABSTRACT = {<p>Formal methods are experiencing a renaissance, especially in the development of safety-critical systems. An indicator for this is the fact that more and more standards either recommend or prescribe the use of formal methods. </p><p> Using formal methods on an industrial scale requires their integration into the system engineering process. This paper is exploring how an integrated tool chain that supports formal methods may look like. It thereby focusses on our experience with tool chains that are based on the open source Eclipse platform in general, and the Rodin formal modeling environment in particular. </p><p> Open Source allows organisations to remedy the risk of being dependent on one single vendor. This includes the risk of the feature set provided: users can add missing features themselves or commission their inclusion to any competent party, rather than having to rely on the vendor to implement it. It further includes the risk of maintenance and long-term support. </p><p> We see industrial interest in open source for systems engineering in general, and Eclipse in particular. Eclipse is attractive, because its license is business-friendly. Further, its modular architecture makes it easy to seamlessly integrate the various Eclipse-based tools for systems engineering. </p><p> This paper focuses on an ecosystem that is accumulated around two Eclipse-based platforms, First, the Rodin platform is an open source modeling environment for the Event-B formalism. Second, the Requirements Modeling Framework (RMF) is a platform for working with natural language requirements, supporting the international ReqIF standard.</p>},
  AUTHOR = {Jastram, Michael},
  BOOKTITLE = {{Forms/Format}},
  DATE = {2012-11},
  TITLE = {{A Systems Engineering Tool Chain Based on Eclipse and Rodin}},
}

@INPROCEEDINGS{RodinWorkshop2013Tutorial,
  ABSTRACT = {We believe that any proof centric formal method must be complemented by animation and visualization to be useful because there are always properties of a model that cannot be covered by proof. In particular a proof can guarantee that a model is internally consistent but it cannot guarantee that this model is actually what its designer had in mind. Animation and visualization can help to review models. ProB is a mature toolset1 that supports a whole range of different formalisms such as classical B, Event-B, CSP and Z.},
  AUTHOR = {Bendisposto, Jens and Clark, Joy and Dobrikov, Ivaylo and Körner, Philipp and Krings, Sebastian and Ladenberger, Lukas and Leuschel, Michael and Plagge, Daniel},
  PUBLISHER = {TUCS},
  URL = {http://stups.hhu.de/ProB/index.php5/Tutorial13},
  BOOKTITLE = {Proceedings of the 4th Rodin User and Developer Workshop},
  DATE = {2013},
  SERIES = {TUCS Lecture Notes},
  TITLE = {ProB 2.0 Tutorial},
}

@INPROCEEDINGS{RodinWorkshop2013Parallel,
  ABSTRACT = {Model checking of a specification using ProB can easily become a task with a long running time. However, the task can very easily be parallelized. If we had a transition system (the state space) and an invariant we could partition the vertices of the state space into k partitions of equal size and then check the invariant on k processors in parallel. However, in reality we cannot afford to precompute the state space in advance. We need to explore the state space itself in parallel. This imposes some challenges that the implementation has to address. Firstly, we have to avoid duplicated invariant checking or at least make sure that duplicate invariant checking does not happen too often in practice. Also in contrast to an offline algorithm, the online version cannot split up the workload fairly. This reduces the scalability of the approach. In particular, the scalability depends on the model. For example, let us consider a counter specification that has an integer variable x ranging from zero to a billion. The variable is initialized with the value zero, and the model has a single event that increments x by one. Assuming that we have k processors, the offline version can easily partition the state space and ensure that every processor gets the same amount of work. For instance, it can decide to use x mod k to determine the processor for a state. The online algorithm has only a limited sight. It processes only one state at a time because each state has a single successor state.},
  AUTHOR = {Bendisposto, Jens and Körner, Philipp and Leuschel, Michael},
  PUBLISHER = {TUCS},
  BOOKTITLE = {Proceedings of the 4th Rodin User and Developer Workshop},
  DATE = {2013},
  SERIES = {TUCS Lecture Notes},
  TITLE = {Parallel Model Checking of B Specifications},
}

@INPROCEEDINGS{RodinWorkshop2013CBC,
  ABSTRACT = {In a previous work, we applied constraint solving techniques to problems like invariant preservation and deadlock freedom checking [2]. The idea behind constraint based deadlock checking is that we set up a logical formula encoding a state where the invariant holds, but all guards are false. We then use the built-in constraint solver to check if the formula has a model. If we can find such a model, we know that the system cannot be proven to be deadlock free. The invariant preservation checking is similar. We encode a state where the invariant holds and a successor state (for some event) where the invariant is false. If this formula has a model, we know that the system cannot be proven correctly. Note that in both cases we do not require that the states are reachable. The system might behave correctly, but the invariant is too weak to prove its correctness.},
  AUTHOR = {Krings, Sebastian and Bendisposto, Jens and Dobrikov, Ivaylo and Leuschel, Michael},
  PUBLISHER = {TUCS},
  BOOKTITLE = {Proceedings of the 4th Rodin User and Developer Workshop},
  DATE = {2013},
  SERIES = {TUCS Lecture Notes},
  TITLE = {B constrained},
}

@INPROCEEDINGS{KringsLeuschelUnits,
  ABSTRACT = {Most state-based formal methods, like B, Event-B or Z, provide support for static typing. However, these methods and the associated tools lack support for annotating variables with (physical) units of measurement. There is thus no obvious way to reason about correct or incorrect usage of such units. In this paper we present a technique that analyses the usage of physical units throughout a B machine, infers missing units and notifies the user of incorrectly handled units. The technique combines abstract interpretation with classical animation and model checking and has been integrated into the ProB validation tool, both for classical B and for Event-B. It provides source-level feedback about errors detected in the models. The plugin uses a combination of abstract interpretation and constraint solving techniques. We provide an empirical evaluation of our technique, and demonstrate that it scales up to real-life industrial models.},
  AUTHOR = {Krings, Sebastian and Leuschel, Michael},
  PUBLISHER = {Springer},
  BOOKTITLE = {Proceedings SEFM'2013},
  DATE = {2013},
  PAGES = {137--151},
  SERIES = {LNCS 8137},
  TITLE = {Inferring Physical Units in {B} Models},
}

@INPROCEEDINGS{RMF_Mark_Book_Jastram_2013,
  ABSTRACT = {<p>This chapter presents the the Requirements Modeling Framework (RMF), an Eclipse-based open source platform for requirements engineering. The core of RMF is based on the emerging Requirements Interchange Format (ReqIF), which is an OMG standard. The project uses ReqIF as the central data model. At the time of this writing, RMF was the only open source implementation of the ReqIF data model.</p><p> By being based on an open standard that is currently gaining industry support, RMF can act as an interface to existing requirements management tools. Further, by based on the Eclipse platform, integration with existing Eclipse-based offerings is possible.</p><p> In this chapter, we will describe the architecture of the RMF project, as well as the underlying ReqIF standard. Further, we give an overview of the GUI, which is called ProR. A key strength of RMF and ProR is the extensibility, and we present the integration ProR with Rodin, which allows traceability between natural language requirements and Event-B formal models.</p>},
  AUTHOR = {Jastram, Michael},
  EDITOR = {Maalej, Walid and Thurimella, Anil},
  PUBLISHER = {Springer},
  BOOKTITLE = {{Managing Requirements Knowledge}},
  DATE = {2013-03},
  TITLE = {{The Eclipse Requirements Modeling Framework}},
}

@UNPUBLISHED{Hallerstede2013nopub1,
  ABSTRACT = {Based on methods for program verification by refinement such as the B-Method or VDM we propose an approach for verifying programs composed of sequential and concurrent parts. Similar to the approach to modelling and proving taken in Event-B we focus on the support for incremental development and ease of proof. We achieve this by following the style of proof obligations used in Event-B. Mixing sequentiality and concurrency requires some structuring in the modelling notation. The main challenge of our approach is permitting such structuring while keeping proof as easy as possible. To achieve this we pragmatic with respect to the proof techniques employed borrowing from Hoare-style program verification and rely-guarantee reasoning. The approach is suitable for reasoning about abstract models of programs where refinement is used for structuring a complex proof. It does not describe a development method by step-wise refinement but an approach to fill in gaps in a complex proof. Refinement is used to produce proofs comparable to those obtained by Hoare-style verification but with flexibility obtained by refinement techniques.},
  AUTHOR = {Hallerstede, Stefan},
  INSTITUTION = {Aarhus University},
  DATE = {2013-03},
  NOTE = {Technical Note},
  TITLE = {On Sequentiality and Concurrency,},
}

@UNPUBLISHED{HalJasLad2013,
  ABSTRACT = {<p>The creation of a consistent system description is a challenging problem of requirements engineering. Formal and informal reasoning can greatly contribute to meet this challenge. However, this demands that formal and informal reasoning and the system description are connected in such way that the reasoning permits drawing conclusions about the system description.</p> <p>We describe an incremental approach to requirements modelling and validation that incorporates formal and informal reasoning. Our main contribution is an approach to requirements tracing that delivers the necessary connection that links the reasoning to the system description. Formal refinement is used in order to deal with large and complex system descriptions.</p> <p>We discuss tool support for our approach of requirements tracing that combines informal requirements modelling with formal modelling and verification while tracing requirements among each other and into the formal model.</p>},
  AUTHOR = {Hallerstede, Stefan and Jastram, Michael and Ladenberger, Lukas},
  DATE = {2013},
  NOTE = {Science of Computer Programming},
  PAGES = {36 p},
  TITLE = {A Method and Tool for Tracing Requirements into Specifications},
}

@INPROCEEDINGS{BoDiTr13_246,
  ABSTRACT = {Dynamically typed language implementations often use more memory and execute slower than their statically typed cousins, in part because operations on collections of elements are unoptimised. This paper describes storage strategies, which dynamically optimise collections whose elements are instances of the same primitive type. We implement storage strategies in the PyPy virtual machine, giving a performance increase of 18% on wide-ranging benchmarks of real Python programs. We show that storage strategies are simple to implement, needing only 1500LoC in PyPy, and have applicability to a wide range of virtual machines. The experiments of this paper were accepted by OOPSLA's artefact evaluation committee.},
  AUTHOR = {Bolz, Carl Friedrich and Diekmann, Lukas and Tratt, Laurence},
  PUBLISHER = {ACM},
  BOOKTITLE = {Proc. OOPSLA, to appear},
  DATE = {2013},
  TITLE = {Storage strategies for collections in dynamically typed languages},
}

@INCOLLECTION{FalampinLeuschelDeployBook,
  AUTHOR = {Falampin, Jerome and Le-Dang, Hung and Leuschel, Michael and Mokrani, Mikael and Plagge, Daniel},
  PUBLISHER = {Springer},
  URL = {http://www.springer.com/computer/swe/book/978-3-642-33169-5},
  BOOKTITLE = {Industrial Deployment of System Engineering Methods},
  DATE = {2013},
  ISBN = {978-3-642-33170-1},
  NOTE = {to appear},
  PAGES = {27--44},
  TITLE = {Improving Railway Data Validation with {ProB}},
}

@REPORT{HansenLeuschel_TLC4B_techreport,
  ABSTRACT = {This technical report is an extension to the conference submission with the same name. It contains translation tables and examples that were omitted in the conference paper.},
  AUTHOR = {Hansen, Dominik and Leuschel, Michael},
  INSTITUTION = {Institut für Informatik, Heinrich-Heine-Universität Düsseldorf},
  URL = {http://www.stups.uni-duesseldorf.de/w/Special:Publication/HansenLeuschel_TLC4B_techreport},
  DATE = {2013},
  NUMBER = {STUPS/2013/xx},
  TITLE = {Translating {B} to {TLA+} for Validation with {TLC}},
  TYPE = {techreport},
}

@ARTICLE{LeuschelVidal-IC14,
  ABSTRACT = {One of the most important challenges in partial evaluation is the design of automatic methods for ensuring the termination of the process.In this work, we introduce sufficient conditions for the strong (i.e., independent of a computation rule) termination and quasi-termination of logic programs which rely on the construction of so called size-change graphs.We then present a fast binding-time analysis that takes the output of the termination analysis and annotates logic programs so that partial evaluation terminates. In contrast to previous approaches, the new binding-time analysis is conceptually simpler and considerably faster, scaling to medium-sized or even large examples.Link: <a href="http://www.sciencedirect.com/science/article/pii/S0890540114000066">http://www.sciencedirect.com/science/article/pii/S0890540114000066</a>},
  AUTHOR = {Leuschel, Michael and Vidal, Germán},
  URL = {http://www.sciencedirect.com/science/article/pii/S0890540114000066},
  DATE = {2014},
  JOURNALTITLE = {Information and Computation},
  PAGES = {70--97},
  TITLE = {Fast offline partial evaluation of logic programs},
  VOLUME = {235},
}

@INPROCEEDINGS{hofm2014cspvis,
  ABSTRACT = {A domain specific visualisation can greatly contribute to better understanding of formal models. In this work we propose an approach that supports the user in creating domain specific visualisations of CSP models. CSP (Communicating Sequential Processes) is a formal language that is mainly used for specifying concurrent and distributed systems.We have successfully created various visualisations of CSP models in order to demonstrate our approach. The visualisations of two case studies are presented in this paper: the bully algorithm and a level crossing gate.In addition, we discuss possible applications of our approach.},
  AUTHOR = {Ladenberger, Lukas and Dobrikov, Ivaylo and Leuschel, Michael},
  EDITOR = {Giannakopoulou, Dimitra and Salaün, Gwen},
  BOOKTITLE = {HOFM 2014},
  DATE = {2014},
  SERIES = {LNCS},
  TITLE = {An Approach for Creating Domain Specific Visualisations of CSP Models},
}

@INPROCEEDINGS{sefm14por,
  ABSTRACT = {Partial order reduction has been very successful at combatting the state explosion problem for lower-level formalisms, but has thus far made hardly any impact for model checking higher-level formalisms such as B, Z or TLA+. This paper attempts to remedy this issue in the context of the increasing importance of Event-B, with its much more fine-grained events and thus increased potential for event-independence and partial order reduction. This paper provides a detailed description of a partial order reduction in ProB. The technique is evaluated on a variety of models. Additionally, the implementation of the method is discussed, which contains new constraint-based analyses.},
  AUTHOR = {Dobrikov, Ivaylo and Leuschel, Michael},
  EDITOR = {Giannakopoulou, Dimitra and Salaün, Gwen},
  LOCATION = {Grenoble},
  BOOKTITLE = {SEFM 2014},
  DATE = {2014},
  DOI = {http://dx.doi.org/10.1007/978-3-319-10431-7_16},
  PAGES = {220--234},
  SERIES = {LNCS 8702},
  TITLE = {Optimising the ProB Model Checker for {B} using Partial Order Reduction},
}

@INCOLLECTION{2014formal,
  ABSTRACT = {We present our ten year experience in developing and applying the ProB validation tool. Initially, the tool provided animation and model checking capabilities for the B-method. Over the years it has been extended to other formal specification languages and provides various constraint-based validation techniques. The tool itself was developed in SICStus Prolog, makes use of the finite domain library together with newly developed constraint solvers for booleans, sets, relations and sequences. The various solvers are linked via reification and Prolog co-routines. The overall challenge of ProB is to solve constraints in full predicate logic with arithmetic, set theory and higher-order relations and functions for safety critical applications. In addition to the tool development, we also provide details about various industrial applications of the tool as well as about our efforts in qualifying the tool for usage in safety critical contexts. Finally, we also describe our experiences in applying alternate approaches, such as SAT or SMT. Link: <a href="http://onlinelibrary.wiley.com/doi/10.1002/9781119002727.ch14/summary">http://onlinelibrary.wiley.com/doi/10.1002/9781119002727.ch14/summary</a>},
  AUTHOR = {Leuschel, Michael and Bendisposto, Jens and Dobrikov, Ivaylo and Krings, Sebastian and Plagge, Daniel},
  EDITOR = {Boulanger, Jean-Louis},
  LOCATION = {Hoboken, NJ},
  PUBLISHER = {Wiley ISTE},
  URL = {http://eu.wiley.com/WileyCDA/WileyTitle/productCd-1848216327.html},
  BOOKTITLE = {Formal Methods Applied to Complex Systems: Implementation of the B Method},
  CHAPTER = {Chapter 14},
  DATE = {2014},
  PAGES = {427--446},
  TITLE = {From Animation to Data Validation: The ProB Constraint Solver 10 Years On},
}

@REPORT{DobrikovLeuschelPORtechreport,
  ABSTRACT = {This technical report is an extension to the conference submission with the same name. It contains proofs and comments that were omitted in the conference paper.},
  AUTHOR = {Dobrikov, Ivaylo and Leuschel, Michael},
  INSTITUTION = {Institut für Informatik, Heinrich-Heine-Universität Düsseldorf},
  DATE = {2014},
  NUMBER = {STUPS/2014/xx},
  TITLE = {Optimising the ProB Model Checker for {B} using Partial Order Reduction},
  TYPE = {techreport},
}

@INPROCEEDINGS{sets14,
  ABSTRACT = {The ProB disprover uses constraint solving to try and find counter examples to proof obligations. As the ProB kernel is now capable of determining whether a search was exhaustive, one can also use the disprover as a prover. In this paper, we compare the ProB Prover with the standard automatic provers for B and Event-B, such as ml, pp and the Rodin SMT plug-in. We demonstrate that ProB is able to deal with classes of proof obligations that are not easily discharged by other provers. As benchmarks we use medium sized specifications such as solutions to the ABZ 2014 case study, a CAN bus specification and a railway system.},
  AUTHOR = {Krings, Sebastian and Bendisposto, Jens and Leuschel, Michael},
  BOOKTITLE = {Proceedings of the 1st International Workshop about Sets and Tools},
  DATE = {2014},
  TITLE = {Turning Failure into Proof: Evaluating the ProB Disprover},
}

@INPROCEEDINGS{fide14pyb,
  ABSTRACT = {We present the implementation of PyB, a predicate- and expression-checker for the B language. The tool is to be used for a secondary tool chain for data validation and data generation, with ProB being used in the primary tool chain. Indeed, PyB is an independent cleanroom-implementation which is used to double-check solutions generated by ProB, an animator and model-checker for B specifications. One of the major goals is to use ProB together with PyB to generate reliable outputs for high-integrity safety critical applications. Although PyB is still work in progress, the ProB/pyB toolchain has already been successfully tested on various industrial B machines and data validation tasks.},
  AUTHOR = {Witulski, John and Leuschel, Michael},
  PUBLISHER = {Electronic Proceedings in Theoretical Computer Science},
  BOOKTITLE = {Proceedings of the 1st Workshop on Formal-IDE},
  DATE = {2014},
  SERIES = {EPTCS},
  TITLE = {Checking Computations of Formal Method Tools - A Secondary Toolchain for ProB},
  VOLUME = {149},
}

@INPROCEEDINGS{fide14toolchain,
  ABSTRACT = {Over the years, ProB has moved from a tool that complemented proving, to a development environment that is now sometimes used instead of proving for applications, such as exhaustive model checking or data validation. This has led to much more stringent requirements on the integrity of ProB. In this paper we present a summary of our validation efforts for ProB, in particular within the context of the norm EN 50128 and safety critical applications in the railway domain.},
  AUTHOR = {Bendisposto, Jens and Krings, Sebastian and Leuschel, Michael},
  PUBLISHER = {Electronic Proceedings in Theoretical Computer Science},
  BOOKTITLE = {Proceedings of the 1st Workshop on Formal-IDE},
  DATE = {2014},
  SERIES = {EPTCS},
  TITLE = {Who watches the watchers: Validating the ProB Validation Tool},
  VOLUME = {149},
}

@INPROCEEDINGS{abz14casestudy,
  ABSTRACT = {In this paper we present our formalisation of the ABZ landing gear case study in Event-B. The development was carried out using the Rodin platform and mainly used superposition refinement to struc- ture the specification. To validate the model we complemented proof with animation and model checking. For the latter we used the ProB anima- tor and model checker. Graphical representation of the model turned out to be crucial in the development and validation of the model; this was achieved using a new version of BMotion Studio integrated into ProB 2.0.},
  AUTHOR = {Hansen, Dominik and Ladenberger, Lukas and Wiegard, Harald and Bendisposto, Jens and Leuschel, Michael},
  BOOKTITLE = {ABZ 2014: The Landing Gear Case Study},
  DATE = {2014},
  TITLE = {Validation of the ABZ Landing Gear System using ProB},
}

@INPROCEEDINGS{tla_abz14,
  ABSTRACT = {The TLA2B translator enables the validation of TLA+ specifications with the model checker, animator and constraint-based checker ProB. In order to provide a convenient way to use ProB as new validation tool for TLA+, we integrated ProB into the TLA toolbox.},
  AUTHOR = {Hansen, Dominik and Bendisposto, Jens and Leuschel, Michael},
  LOCATION = {Toulouse},
  BOOKTITLE = {TLA Workshop},
  DATE = {2014},
  TITLE = {Integrating ProB into the TLA Toolbox},
}

@INPROCEEDINGS{HansenLeuschel_ABZ14,
  ABSTRACT = {The state-based formal methods B and TLA+ share the common base of predicate logic, arithmetic and set theory. However, there are still considerable differences, such as the way to specify state transitions, the different approaches to typing, and the available tool support. In this paper, we present a translation from B to TLA+ to validate B specifications using the model checker TLC. We provide translation rules for almost all constructs of B, in particular for those which are not built-in in TLA+. The translation also includes many adaptations and optimizations to allow efficient checking by TLC. Moreover, we present a way to validate liveness properties for B specifications under fairness conditions. Our implemented translator, TLC4B, automatically translates a B specification to TLA+, invokes the model checker TLC, and translates the results back to B. We use ProB to double check the counter examples produced by TLC and replay them in the ProB animator. We also present a series of case studies and benchmark tests comparing TLC4B and ProB.},
  AUTHOR = {Hansen, Dominik and Leuschel, Michael},
  BOOKTITLE = {Proceedings ABZ'14},
  DATE = {2014},
  PAGES = {40--55},
  SERIES = {LNCS 8477},
  TITLE = {Translating B to TLA + for Validation with TLC},
}

@INPROCEEDINGS{LeuschelSchneider_ABZ14,
  ABSTRACT = {We argue that B is a good language to conveniently express a wide range of constraint satisfaction problems. We also show that some problems can be solved quite effectively by the ProB tool. We illustrate our claim on several examples, such as the jobs puzzle - for which we solve the challenge set out by Shapiro. Here we show that the B formalization is both very close to the natural language specification and can still be solved efficiently by ProB. Our approach is particularly interesting when a high assurance of correctness is required. Indeed, compared to other existing approaches and tools, validation and double checking of solutions is available for ProB and formal proof can be applied to establish important properties or provide an unambiguous semantics to the problem specification.},
  AUTHOR = {Leuschel, Michael and Schneider, David},
  EDITOR = {Ait Ameur, Yamine and Schewe, Klaus-Dieter},
  PUBLISHER = {Springer Berlin Heidelberg},
  URL = {http://dx.doi.org/10.1007/978-3-662-43652-3_8},
  BOOKTITLE = {Abstract State Machines, Alloy, B, TLA, VDM, and Z},
  DATE = {2014},
  DOI = {10.1007/978-3-662-43652-3_8},
  ISBN = {978-3-662-43651-6},
  KEYWORDS = {B-method; constraint programming; logic programming; Alloy; Kodkod; optimization},
  PAGES = {101--116},
  SERIES = {Lecture Notes in Computer Science},
  TITLE = {Towards B as a High-Level Constraint Modelling Language},
  VOLUME = {8477},
}

@INPROCEEDINGS{EasyChair:390,
  ABSTRACT = {We argue that formal methods such as B can be used to conveniently express a wide range of constraint satisfaction problems. We also show that some problems can be solved quite eectively by existing formal methods tools such as Alloy or ProB. We illustrate our claim on several examples. Our approach is particularly interesting when a high assurance of correctness is required. Indeed, validation and double checking of solutions is available for certain formal methods tools and formal proof can be applied to establish important properties or provide unambiguous semantics to problem specications. The experiments also provide interesting insights about the eectiveness of existing formal method tools, and highlight interesting avenues for future improvement.},
  AUTHOR = {Leuschel, Michael},
  EDITOR = {Lisitsa, Alexei and Nemytykh, Andrei},
  PUBLISHER = {EasyChair},
  URL = {http://easychair.org/publications/?page=1018594602},
  BOOKTITLE = {VPT 2014},
  DATE = {2014},
  ISSN = {2040-557X},
  PAGES = {1--1},
  SERIES = {EPiC Series},
  TITLE = {Towards Constraint-Solving over Higher-Order Unbounded Datatypes using Formal Methods Tools},
  VOLUME = {28},
}

@ARTICLE{abz14casestudyjournal,
  ABSTRACT = {In this article, we present our formalization of the ABZ landing gear case study in Event-B. The development was carried out using the Rodin platform and mainly used superposition refinement to structure the specification. To validate the model, we complemented proof with animation and model checking. For the latter, we used the ProB animator and model checker. Graphical representation of the model turned out to be crucial in the development and validation of the model; this was achieved using the visualization features provided by ProB and BMotion Studio. In addition, we discuss the positive and negative aspects of the Event-B language and tools which we encountered while working on the ABZ case study.},
  AUTHOR = {Ladenberger, Lukas and Hansen, Dominik and Wiegard, Harald and Bendisposto, Jens and Leuschel, Michael},
  LANGUAGE = {English},
  PUBLISHER = {Springer Berlin Heidelberg},
  URL = {http://dx.doi.org/10.1007/s10009-015-0395-9},
  DATE = {2015},
  DOI = {10.1007/s10009-015-0395-9},
  ISSN = {1433-2779},
  JOURNALTITLE = {International Journal on Software Tools for Technology Transfer},
  KEYWORDS = {Formal methods; B-method; Validation; Toolchain; Visualization},
  PAGES = {1--17},
  TITLE = {Validation of the ABZ landing gear system using ProB},
}

@INPROCEEDINGS{timetable_validation,
  ABSTRACT = {Constraint satisfaction problems can be expressed very elegantly in state-based formal methods such as B. However, can such specifications be directly used for solving real-life problems? We will try and answer this question in the present paper with regard to the university timetabling problem. We report on an ongoing project to build a formal model-based curriculum timetable validation tool where we use a formal specification as the basis to validate timetables from a student’s perspective and to support incremental modification of timetables. In this article we focus on expressing the problem domain, the formalization in B and our approach to execute the formal model in a production system using ProB.},
  AUTHOR = {Schneider, David and Leuschel, Michael and Witt, Tobias},
  PUBLISHER = {Springer},
  BOOKTITLE = {FM 2015: Formal Methods: 20th International Symposium},
  DATE = {2015},
  PAGES = {487--495},
  SERIES = {Lecture Notes in Computer Science (Book 9109)},
  TITLE = {{Model-Based Problem Solving for University Timetable Validation and Improvement}},
}

@INPROCEEDINGS{kps15,
  AUTHOR = {Körner, Philipp and Schneider, David and Leuschel, Michael},
  PUBLISHER = {Springer},
  URL = {http://www.complang.tuwien.ac.at/kps2015/proceedings/KPS_2015_submission_24.pdf},
  BOOKTITLE = {18. Kolloquium Programmiersprachen und Grundlagen der Programmierung KPS 2015},
  DATE = {2015},
  SERIES = {Schriftenreihe des Instituts für Computersprachen},
  TITLE = {{Evaluating Interpreter Design in Prolog}},
}

@INPROCEEDINGS{disprover_eval,
  ABSTRACT = {The ProB disprover uses constraint solving to find counter examples for B proof obligations. As the ProB kernel is now capable of determining whether a search was exhaustive, one can also use the disprover as a prover. In this paper, we explain how ProB has been embedded as a prover into Rodin and Atelier B. Furthermore, we compare ProB with the standard automatic provers and SMT solvers used in Rodin. We demonstrate that constraint solving in general and ProB in particular are able to deal with classes of proof obligations that are not easily discharged by other provers and solvers. As benchmarks we use medium sized specifications such as landing gear systems, a CAN bus specification and a railway system. We also present a new method to check proof obligations for inconsistencies, which has helped uncover various issues in existing (sometimes fully proven) models.},
  AUTHOR = {Krings, Sebastian and Bendisposto, Jens and Leuschel, Michael},
  PUBLISHER = {Springer},
  BOOKTITLE = {Proceedings SEFM'2015},
  DATE = {2015},
  SERIES = {LNCS 9276},
  TITLE = {{From Failure to Proof: The ProB Disprover for B and Event-B}},
}

@ARTICLE{KringsLeuschelUnitsJournal,
  ABSTRACT = {Most state-based formal methods, like B, Event-B or Z, provide support for static typing. However, these methods and the associated tools lack support for annotating variables with (physical) units of measurement. There is thus no obvious way to reason about correct or incorrect usage of such units. We present a technique that analyses the usage of physical units throughout B and Event-B machines, infers missing units and notifies the user of incorrectly handled units. The technique combines abstract interpretation with classical animation, constraint solving and model checking and has been integrated into the ProB validation tool, both for classical B and for Event-B. It provides source-level feedback about errors detected in the models. We also describe how to extend our approach to TLA+, an untyped formal language. We provide an in-depth empirical evaluation and demonstrate that our technique scales up to real-life industrial models.},
  AUTHOR = {Krings, Sebastian and Leuschel, Michael},
  LANGUAGE = {English},
  PUBLISHER = {Springer Berlin Heidelberg},
  DATE = {2015},
  DOI = {10.1007/s10270-015-0458-0},
  ISSN = {1619-1366},
  JOURNALTITLE = {Software & Systems Modeling},
  KEYWORDS = {B-Method; Event-B; Physical Units; Model Checking; Abstract Interpretation},
  PAGES = {1--23},
  TITLE = {Inferring Physical Units in Formal Models},
}

@REPORT{HansenLeuschel_TLC4B_Journal,
  ABSTRACT = {This technical report is an extension to the ABZ'2014 conference submission with the same name. It is submitted to Science of Computer Programming.},
  AUTHOR = {Hansen, Dominik and Leuschel, Michael},
  INSTITUTION = {Institut für Informatik, Heinrich-Heine-Universität Düsseldorf},
  URL = {http://www.stups.uni-duesseldorf.de/w/Special:Publication/HansenLeuschel_TLC4B_Journal},
  DATE = {2015},
  NUMBER = {STUPS/2015/Feb},
  TITLE = {Translating {B} to {TLA+} for Validation with {TLC}},
  TYPE = {techreport},
}

@REPORT{LadenbergerLeuschel_ProjectDiagram,
  ABSTRACT = {This technical report is an extension to the ICFEM'15 conference paper with the same name. It contains more diagram examples that were omitted in the conference paper.},
  AUTHOR = {Ladenberger, Lukas and Leuschel, Michael},
  INSTITUTION = {Institut für Informatik, Heinrich-Heine-Universität Düsseldorf},
  URL = {http://www.stups.uni-duesseldorf.de/w/Special:Publication/LadenbergerLeuschel_ProjectDiagram},
  DATE = {2015},
  NUMBER = {STUPS/2015/May},
  TITLE = {Mastering the Visualization of Larger State Spaces with Projection Diagrams},
  TYPE = {techreport},
}

@INPROCEEDINGS{LadenbergerLeuschel_ICFEM15,
  ABSTRACT = {State space visualization is a popular technique for supporting the analysis of formal models. It often allows users to get a global view of the system and to identify structural similarities, symmetries, and unanticipated properties (only to name a few). However, state spaces typically become very large, so human inspection of the visualization becomes difficult. To overcome this challenge, we present an approach which can considerably reduce the size of the state space by creating projection diagrams. Moreover, we present an approach to link a projection diagram with a domain specific visualization. The projection diagram construction can be initiated directly from user-selected graphical elements, without the user having to write formulas or having to know the variables or internal structure of the model. This makes the projection diagram inspection and construction accessible to non-formal method experts. These techniques have been implemented within the ProB toolset, and we demonstrate their benefits and usefulness on several examples.},
  AUTHOR = {Ladenberger, Lukas and Leuschel, Michael},
  PUBLISHER = {Springer-Verlag},
  BOOKTITLE = {Proceedings ICFEM'2015},
  DATE = {2015},
  PAGES = {153--169},
  SERIES = {LNCS 9407},
  TITLE = {Mastering the Visualization of Larger State Spaces with Projection Diagrams},
}

@INPROCEEDINGS{infinite_domain_solver,
  ABSTRACT = {We present a CLP(FD)-based constraint solver able to deal with unbounded domains. It is based on constraint propagation, resorting to enumeration as a last resort. An important aspect is detecting when enumeration was complete and if this has an impact on the soundness of the result. We present a technique which guarantees soundness in the following way: if the constraint solver finds a solution it is guaranteed to be correct; if the constraint solver fails to find a solution it can either return the result “definitely false” in case it knows enumeration was exhaustive, or “unknown” in case it was aborted. The technique can deal with nested universal and existential quantifiers. It can easily be extended to set comprehensions and other operators introducing new quantified variables. We show applications in data validation and proof.},
  AUTHOR = {Krings, Sebastian and Leuschel, Michael},
  BOOKTITLE = {Proceedings of the 30th Workshop on (Constraint) Logic Programming},
  DATE = {2016},
  SERIES = {EPTCS},
  TITLE = {Constraint Logic Programming over Infinite Domains with an Application to Proof},
  VOLUME = {234},
}

@ARTICLE{Dobrikov2016,
  ABSTRACT = {Partial order reduction has been very successful at combatting the state explosion problem for lower-level formalisms, but has thus far made hardly any impact for model checking higher-level formalisms such as B, Z or TLA+. This paper attempts to remedy this issue in the context of Event-B, with its much more fine-grained events and thus increased potential for event-independence and partial order reduction. In this work, we provide a detailed description of a partial order reduction for explicit state model checking in ProB. The technique is evaluated on a variety of models. The implementation of the method is discussed, which is based on new constraint-based analyses. Further, we give a comprehensive description for elaborating the implementation into the LTL model checker of ProB for checking LTL−X formulae.},
  AUTHOR = {Dobrikov, Ivaylo and Leuschel, Michael},
  URL = {http://dx.doi.org/10.1007/s00165-015-0351-1},
  DATE = {2016},
  DOI = {10.1007/s00165-015-0351-1},
  JOURNALTITLE = {Formal Aspects of Computing},
  NUMBER = {2},
  PAGES = {179--323},
  TITLE = {{Optimising the ProB Model Checker for B using partial order reduction}},
  VOLUME = {28},
}

@INPROCEEDINGS{KringsLeuschelSymbolicMc,
  ABSTRACT = {We have implemented various symbolic model checking algorithms, like BMC, k-Induction and IC3 for B and Event-B. The high-level nature of B and Event-B accounts for complicated constraints arising in these symbolic analysis techniques. In this paper we suggest using static information stemming from proof obligations to simplify occurring constraints. We show how to include proof information in the aforementioned algorithms. Using different benchmarks we compare explicit state to symbolic model checking as well as techniques with and without proof assistance. In particular for models with large branching factor, e.g., due to complicated data values being manipulated, the symbolic techniques fare much better than explicit state model checking. The inclusion of proof information results in further clear performance improvements.},
  AUTHOR = {Krings, Sebastian and Leuschel, Michael},
  PUBLISHER = {Springer},
  BOOKTITLE = {Proceedings ABZ 2016},
  DATE = {2016},
  SERIES = {LNCS},
  TITLE = {Proof Assisted Symbolic Model Checking for B and Event-B},
  VOLUME = {9675},
}

@ARTICLE{KringsLeuschelSymbolicMcJournal,
  AUTHOR = {Krings, Sebastian and Leuschel, Michael},
  DATE = {2017},
  JOURNALTITLE = {Science of Computer Programming},
  TITLE = {Proof Assisted Bounded and Unbounded Symbolic Model Checking of Software and System Models},
  NOTE = {To appear}
}

@INPROCEEDINGS{RepairBySynthesisShort,
  ABSTRACT = {When using B or Event-B for formal specifications, model checking is often used to detect errors such as invariant violations, deadlocks or refinement errors. Errors are presented as counter-example states and traces and should help fixing the underlying bugs. We suggest automating parts of this process: Using a synthesis technique, we try to generate more permissive or restrictive guards or invariants. Furthermore, synthesized actions allow to modify the behaviour of the model. All this could be done with constant user feedback, yielding an interactive debugging aid.},
  AUTHOR = {Schmidt, Joshua and Krings, Sebastian and Leuschel, Michael},
  PUBLISHER = {Springer},
  BOOKTITLE = {Proceedings ABZ 2016},
  DATE = {2016},
  SERIES = {LNCS},
  TITLE = {Interactive Model Repair by Synthesis},
  VOLUME = {9675},
}

@INPROCEEDINGS{probz3integration,
  ABSTRACT = {We present an integration of the constraint solving kernel of the ProB model checker with the SMT solver Z3. We apply the combined solver to B and Event-B predicates, featuring higher-order datatypes and constructs like set comprehensions. To do so we rely on the finite set logic of Z3 and provide a new translation from B to Z3, better suited for constraint solving. Predicates can then be solved by the two solvers working hand in hand: constraints are set up in both solvers simultaneously and (intermediate) results are transferred. We thus combine a constraint logic programming based solver with a DPLL(T) based solver into a single procedure. The improved constraint solver finds application in many validation tasks, from animation of implicit specifications, to test case generation, bounded and symbolic model checking on to disproving of proof obligations. We conclude with an empirical evaluation of our approach focusing on two dimensions: comparing low and high-level encodings of B as well as comparing pure ProB to ProB combined with Z3.},
  AUTHOR = {Krings, Sebastian and Leuschel, Michael},
  PUBLISHER = {Springer},
  BOOKTITLE = {Proceedings iFM 2016},
  DATE = {2016},
  SERIES = {LNCS},
  TITLE = {SMT Solvers for Validation of B and Event-B models},
  VOLUME = {9681},
}

@INPROCEEDINGS{probltsminintegration,
  ABSTRACT = {We present a symbolic reachability analysis approach for B that can provide a significant speedup over traditional explicit state model checking. The symbolic analysis is implemented by linking ProB to LTSmin, a high-performance language independent model checker. The link is achieved via LTSmin's PINS interface, allowing ProB to benefit from LTSmin's analysis algorithms, while only writing a few hundred lines of glue-code, along with a bridge between ProB and C using ZeroMQ. ProB supports model checking of several formal specification languages such as B, Event-B, Z and TLA. Our experiments are based on a wide variety of B-Method and Event-B models to demonstrate the efficiency of the new link. Among the tested categories are state space generation and deadlock detection; but action detection and invariant checking are also feasible in principle. In many cases we observe speedups of several orders of magnitude. We also compare the results with other approaches for improving model checking, such as partial order reduction or symmetry reduction. We thus provide a new scalable, symbolic analysis algorithm for the B-Method and Event-B, along with a platform to integrate other model checking improvements via LTSmin in the future. Link: <a href="http://arxiv.org/abs/1603.04401">http://arxiv.org/abs/1603.04401</a>},
  AUTHOR = {Bendisposto, Jens and Körner, Philipp and Leuschel, Michael and Meijer, Jeroen and van de Pol, Jaco and Treharne, Helen and Whitefield, Jorden},
  PUBLISHER = {Springer},
  BOOKTITLE = {Proceedings iFM 2016},
  DATE = {2016},
  NOTE = {Available at {\tt \url{http://arxiv.org/abs/1603.04401}}},
  SERIES = {LNCS},
  TITLE = {Symbolic Reachability Analysis of B through ProB and LTSmin},
  VOLUME = {9681},
}

@INPROCEEDINGS{DobrikovLeuschelEnablingAnalysis,
  ABSTRACT = {In this paper we present a static analysis to determine how events influence each other in Event-B models. The analysis, called an enabling analysis, uses syntactic and constraint-based techniques to compute the effect of executing one event on the guards of another event. We describe the foundations of the approach along with the realisation in ProB. The output of the analysis can help a user to understand the control flow of a formal model. Additionally, we discuss how the information of the enabling analysis can be used to obtain a new optimised model checking algorithm. We evaluate both the performance of the enabling analysis and the new model checking technique on a variety of models. The technique is also applicable to B, TLA+, and Z models.},
  AUTHOR = {Dobrikov, Ivaylo and Leuschel, Michael},
  PUBLISHER = {Springer},
  BOOKTITLE = {Proceedings ABZ 2016},
  DATE = {2016},
  SERIES = {LNCS},
  TITLE = {Enabling Analysis for Event-B},
  VOLUME = {9675},
}

@INPROCEEDINGS{HansenSchneiderLeuschel:ABZ2016,
  ABSTRACT = {Constraint satisfaction and data validation problems can be expressed very elegantly in state-based formal methods such as B. However, is B suited for developing larger applications and are there existing tools that scale for these projects? In this paper, we present our experiences on two real-world data validation projects from different domains which are based on the B language and use ProB as the central validation tool. The first project is the validation of university timetables, and the second project is the validation of railway topologies. Based on these two projects, we present a general structure of a data validation project in B and outline common challenges along with various solutions. We also discuss possible evolutions of the B language to make it (even) more suitable for such projects.},
  AUTHOR = {Hansen, Dominik and Schneider, David and Leuschel, Michael},
  PUBLISHER = {Springer-Verlag},
  BOOKTITLE = {Proceedings ABZ 2016},
  DATE = {2016},
  SERIES = {LNCS},
  TITLE = {{Using B and ProB for Data Validation Projects}},
  VOLUME = {9675},
}

@REPORT{LeuschelDobrikov-EnablingTR,
  ABSTRACT = {This technical report is an extension to the conference submission with the same name. It contains proofs, comments and additional material that were omitted in the conference paper.},
  AUTHOR = {Dobrikov, Ivaylo and Leuschel, Michael},
  INSTITUTION = {Institut für Informatik, University of Düsseldorf},
  URL = {Available%20at%20%7B%5Ctt%20%5Curl%7Bhttp://stups.hhu.de/w/Special:Publication/DobrikovLeuschelEnablingAnalysis%7D%7D},
  DATE = {2016},
  HOWPUBLISHED = {\url{http://stups.hhu.de/w/Special:Publication/DobrikovLeuschelEnablingAnalysis}},
  NOTE = {http://stups.hhu.de/w/Special:Publication/DobrikovLeuschelEnablingAnalysis},
  NUMBER = {STUPS/2016/xx},
  TITLE = {Enabling Analysis for {Event-B} (Technical Report)},
  TYPE = {techreport},
}

@INPROCEEDINGS{FairnessPaper,
  ABSTRACT = {Model checking of liveness properties often results in unrealistic, unfair infinite behaviors as counterexamples. Fairness is a notion where the search is constrained to infinite paths that do not ignore infinitely the execution of a set of enabled actions. In this work we present an implementation for efficient checking of LTL formulas under strong and weak fairness in ProB, available for model checking B, Event-B, Z, CSP and CSP || B models. The fairness checking algorithm can cope with both weak and strong fairness conditions, where the respective fairness conditions can be joined by means of the logical operators for conjunction and disjunction, which makes setting up and checking fairness to a property more flexible. We evaluate the implementation on various CSP models and compare it to the fairness implementation of the PAT tool.},
  AUTHOR = {Ivaylo Dobrikov, Daniel Plagge and Leuschel, Michael},
  PUBLISHER = {Springer},
  BOOKTITLE = {Proceedings SEFM'16},
  DATE = {2016},
  SERIES = {LNCS},
  TITLE = {LTL Model Checking under Fairness in ProB},
  VOLUME = {9763},
}

@INPROCEEDINGS{RodinWorkshop2016MetaPredicates,
  ABSTRACT = {Event-B provides a concise mathematical language for specifying invariants and guards. While both Event-B and Rodin matured, certain patterns for specifying properties like deadlock freedom emerged and are in use. These patterns are often realized by copy and paste of guards into other guards or invariants, leading to duplicated code and incomprehensible specifications. Furthermore, it may lead to errors if predicates are not kept in sync. We observed errors like these during the case studies of ABZ 2014 and started developing an extension to Event-B that allows accessing guards by corresponding event names. Since, it has been implemented as a plugin for the Rodin platform.},
  AUTHOR = {Krings, Sebastian},
  PUBLISHER = {},
  BOOKTITLE = {6th Rodin User and Developer Workshop},
  DATE = {2016},
  TITLE = {Meta-Predicates for Rodin},
}

@INPROCEEDINGS{iFM16PhDSymposium,
  ABSTRACT = {Symbolic model checking algorithms like IC3 have proven to be an effective technique for hardware model checking. Extensions to software model checking have been suggested and implemented and seem promising so far. However, using symbolic model checking algorithms for the specification languages B and Event-B is complicated. This is due to their high-level nature, which accounts for complex constraints. While some problems can be coped with by modifications to the algorithms, others relate to the heart of our tools: the constraint solver.},
  AUTHOR = {Krings, Sebastian},
  PUBLISHER = {},
  BOOKTITLE = {PhD Symposium at iFM'16 on Formal Methods: Algorithms, Tools and Applications},
  DATE = {2016},
  TITLE = {The Burden of High-Level Languages: Complicated Symbolic Model Checking},
}

@INPROCEEDINGS{LadeLeuBMotionWebSEFM2106,
  AUTHOR = {Ladenberger, Lukas and Leuschel, Michael},
  PUBLISHER = {Springer},
  BOOKTITLE = {Proceedings SEFM'16},
  DATE = {2016},
  SERIES = {LNCS},
  TITLE = {BMotionWeb: A Tool for Rapid Creation of Formal Prototypes},
  VOLUME = {9763},
}

@INPROCEEDINGS{LeuschelSBMF2016,
  ABSTRACT = {Constraint solving technology for formal models has made considerable progress in the last years, and has lead to many applications such as animation of high-level specifications, test case generation, or symbolic model checking. In this article we discuss the idea to use formal models themselves to express constraint satisfaction problems and to embed formal models as executable artefacts at runtime. As part of our work, we have developed a document generation feature, whose output is derived from such executable models. This present article has been generated using this feature, and we use the feature to showcase the suitability of formal modelling to express and solve various constraint solving benchmark examples. We conclude with current limitations and open challenges of formal model-based constraint solving.},
  AUTHOR = {Leuschel, Michael},
  PUBLISHER = {Springer},
  BOOKTITLE = {SBMF'2016},
  DATE = {2016},
  SERIES = {Lecture Notes in Computer Science},
  TITLE = {Formal Model-Based Constraint Solving and Document Generation},
}
