@inproceedings{Le95_91,
  author     = {Michael Leuschel},
  title      = {Partial Evaluation of the "Real Thing"},
  booktitle  = {LOPSTR},
  publisher  = {Springer-Verlag},
  pages      = {122--137},
  series     = {Lecture Notes in Computer Science},
  volume     = {883},
  isbn       = {3-540-58792-6},
  year       = {1994},
}
@inproceedings{LeDe95_92,
  author     = {Michael Leuschel and Danny De Schreye},
  title      = {Towards Creating Specialised Integrity Checks Through Partial
                Evaluation of Meta-Interpreters},
  booktitle  = {PEPM},
  publisher  = {ACM Press},
  pages      = {253--263},
  year       = {1995},
  stupsfile  = {http://www.stups.uni-duesseldorf.de/publications/metaic.pdf},
}
@inproceedings{LeDeMa95_93,
  author     = {Michael Leuschel and Danny De Schreye and Bern Martens},
  title      = {Tutorial on Program Specialisation (abstract)},
  booktitle  = {ILPS},
  publisher  = {MIT Press},
  pages      = {615--616},
  year       = {1995},
}
@inproceedings{LeMa95_94,
  author     = {Michael Leuschel and Bern Martens},
  title      = {Obtaining Specialised Update Procedures through Partial Deduction of
                the Ground Representation},
  booktitle  = {Proc. Joint Workshop on Deductive Databases and Logic Programming and Abduction in Deductive Databases and Knowledge Based Systems},
  publisher  = {GMD-Studien Nr. 266},
  pages      = {81--95},
  year       = {1995},
}
@inproceedings{LeMa95_95,
  author     = {Michael Leuschel and Bern Martens},
  title      = {Partial Deduction of the Ground Representation and its Application to
                Integrity Checking},
  booktitle  = {ILPS},
  publisher  = {MIT Press},
  pages      = {495--509},
  year       = {1995},
}


@inproceedings{JoLe96_82,
  author     = {Jesper J{\o}rgensen and Michael Leuschel},
  title      = {Efficiently Generating Efficient Generating Extensions in {Prolog}},
  booktitle  = {Dagstuhl Seminar on Partial Evaluation},
  editor     = {O. Danvy and R. Glueck and P. Thiemann},
  publisher  = {Springer-Verlag},
  pages      = {238--262},
  series     = {Lecture Notes in Computer Science},
  volume     = {1110},
  isbn       = {3-540-61580-6},
  year       = {1996},
  stupsfile  = {http://www.stups.uni-duesseldorf.de/publications/cogendag.pdf},
}
@inproceedings{JoLeMa96_84,
  author     = {Jesper J{\o}rgensen and Michael Leuschel and Bern Martens},
  title      = {Conjunctive Partial Deduction in Practice},
  booktitle  = {LOPSTR},
  editor     = {J. Gallagher},
  publisher  = {Springer-Verlag},
  month      = {August},
  pages      = {59--82},
  series     = {Lecture Notes in Computer Science},
  volume     = {1207},
  isbn       = {3-540-62718-9},
  year       = {1996},
  stupsfile  = {http://www.stups.uni-duesseldorf.de/publications/cppd.pdf},
}
@inproceedings{Le96_85,
  author     = {Michael Leuschel},
  title      = {Specialised Integrity Checking by Combining Conjunctive Partial Deduction and Abstract Interpretation},
  editor     = {J. Bocca and H. Decker and A. Voronkov},
  publisher  = {IBFI GmbH, Schloss Dagstuhl},
  pages      = {18--19},
  year       = {1996},
  booktitle = {Proc. Logic Databases and the Meaning of Change: Dagstuhl-Seminar-Report 157},
}
@inproceedings{LeDe96_86,
  author     = {Michael Leuschel and Danny De Schreye},
  title      = {Logic Program Specialisation: How To Be More Specific},
  booktitle  = {Proceedings PLILP'96},
  editor     = {H. Kuchen and S. D. Swierstra},
  publisher  = {Springer-Verlag},
  series     = {Lecture Notes in Computer Science},
  volume     = {1140},
  isbn       = {3-540-61756-6},
  month      = {September},
  pages      = {137--151},
  year       = {1996},
  stupsfile  = {http://www.stups.uni-duesseldorf.de/publications/msvplilp.pdf},
}
@inproceedings{LeDe96_87,
  author     = {Michael Leuschel and Danny De Schreye},
  title      = {Logic Program Specialisation: How To Be More Specific (abstract)},
  booktitle  = {LOPSTR},
  editor     = {J. Gallagher},
  publisher  = {Springer-Verlag},
  month      = {August},
  pages      = {58},
  series     = {Lecture Notes in Computer Science},
  volume     = {1207},
  isbn       = {3-540-62718-9},
  year       = {1996},
}
@inproceedings{LeDede96_88,
  author     = {Michael Leuschel and Danny De Schreye and D. Andre de Waal},
  title      = {A Conceptual Embedding of Folding into Partial Deduction:
                Towards a Maximal Integration},
  booktitle  = {JICSLP},
  editor     = {M. Maher},
  publisher  = {MIT Press},
  month      = {September},
  pages      = {319--332},
  year       = {1996},
  stupsfile  = {http://www.stups.uni-duesseldorf.de/publications/fold.iclp.pdf},
}
@inproceedings{LeMa96_89,
  author     = {Michael Leuschel and Bern Martens},
  title      = {Global Control for Partial Deduction through Characteristic Atoms and
                Global Trees},
  booktitle  = {Dagstuhl Seminar on Partial Evaluation},
  editor     = {O. Danvy and R. Glueck and P. Thiemann},
  publisher  = {Springer-Verlag},
  series     = {Lecture Notes in Computer Science},
  volume     = {1110},
  isbn       = {3-540-61580-6},
  pages      = {263--283},
  year       = {1996},
  stupsfile  = {http://www.stups.uni-duesseldorf.de/publications/papdag.pdf},
}
@inproceedings{LeSo96_90,
  author     = {Michael Leuschel and Morten Heine S{\o}rensen},
  title      = {Redundant Argument Filtering of Logic Programs},
  booktitle  = {LOPSTR},
  editor     = {J. Gallagher},
  publisher  = {Springer-Verlag},
  series     = {Lecture Notes in Computer Science},
  volume     = {1207},
  isbn       = {3-540-62718-9},
  month      = {August},
  pages      = {83--103},
  year       = {1996},
}
@mastersthesis{Jastram_thesis_1997,
  author     = {Michael Jastram},
  title      = {Inspection and Feature Extraction of Marine Propellers},
  abstract   = {<b>Localization</b> Localization is the process of determining the rigid-body translations and
rotations that must be performed on a set of points measured on a manufactured surface
(like a propeller blade) to move those points into the closest correspondence with the ideal
design surface. An additional parameter is an offset distance, such that the Euclidean
motion brings the measured points as close as possible to an offset of the design surface.
An algorithm to determine the seven parameters (three rotations, three translations,
one offset) was developed in 1991 by R. A. Jinkerson. But that algorithm makes some
assumptions about the surface and the measured points, which are sometimes not fulfilled.
Specifically, it assumes, that a measured point has always an orthogonal projection on the
offset surface, regardless of the translation and rotation parameters.
This thesis extends Jinkerson's algorithm, so that these assumptions are not necessary
any longer. This involves the development of a new objective function and its gradient.<br><br>
<b>Feature extraction</b> During the manufacturing process, a propeller blade surface is
subject to manufacturing inaccuracies, that result in small changes to the data describing
its features. It is therefore desirable to recompute these features for comparison with the
original design data. Most of the characteristics of a propeller blade are embedded in the
camber lines of its hydrofoil sections. The objective of this part of the thesis is to recompute
the camber line from a hydrofoil shape curve.
An algorithm for this task has already been developed, but it makes the assumption
that the blade thickness has a single maximum, which is often not fulfilled, especially, if the
hydrofoil has been generated from measured data.
In this thesis, a new algorithm has been developed. It generates a highly accurate camber
line by using a two pass iteration method: The first pass generates an approximation of the
camber line, and the second pass refines this approximation to the desired accuracy.
},
  school = {Massachusetts Institute of Technology},
  month      = {December},
  year       = {1996},
}



@article{Le97_79,
  author     = {Michael Leuschel},
  title      = {Advanced Techniques for Logic Program Specialisation},
  journal    = {AI Communications},
  volume     = {10},
  number     = {2},
  pages      = {127--128},
  year       = {1997},
}
@inproceedings{Le97_80,
  author     = {Michael Leuschel},
  title      = {Specialization of Declarative Programs and its Application (workshop
                overview)},
  booktitle  = {ILPS},
  publisher  = {MIT Press},
  month      = {Oct},
  pages      = {413--414},
  year       = {1997},
}
@inproceedings{Le97_81,
  author     = {Michael Leuschel},
  title      = {The {Ecce} Partial Deduction System},
  booktitle  = {Proceedings of the ILPS'97 Workshop on
                Tools and Environments for (Constraint) Logic Programming},
  editor     = {German Puebla},
  series     = {Universidad Polit{\'e}cnica de Madrid Tech. Rep. CLIP7/97.1},
  month      = {October},
  year       = {1997},
}
@proceedings{Leuschel:SP97,
  editor     = {Michael Leuschel},
  title      = {Proceedings of the ILPS'97 Workshop on Specialisation of
                Declarative Programs and its Application},
  year       = {1997},
  month      = {October},
  publisher  = {K. U. Leuven, Tech. Rep. CW 255,
                also as DIKU Report 97/30, University of Copenhagen},
}
@phdthesis{Le97_216,
  author     = {Michael Leuschel},
  title      = {Advanced Techniques for Logic Program Specialisation},
  month      = {May},
  school     = {K.U. Leuven},
  year       = {1997},
  stupsfile  = {http://www.stups.uni-duesseldorf.de/publications/phd.pdf},
}
@mastersthesis{Ha97_302,
  author     = {Stefan Hallerstede},
  title      = {Semantische Fundierung von CSP-Z},
  abstract   = {CSP-Z ist eine Sprache zur Spezifikation zustandsbasierter
    kommunizierender
    Systeme, welche die Prozeßalgebra CSP und die Z-Notation
    zusammenführt. Die Semantik von CSP-Z-Spezifikationen
    wird durch das Failures/Divergences-Modell von CSP beschrieben, das
    von
    Roscoe angepaßt wurde, um unbeschränkten Nichtdetermismus
    besser behandeln zu können. Für CSP gibt es eine Verfeinerungstheorie,
    die
    auf dem Failures/Divergences-Modell basiert. Diese Theorie
    lässt sich in einfacher Weise auf CSP-Z übertragen. Ziel dieser Arbeit
    ist
    es die existierende Verfeinerungstheorie von Z für CSP-Z nutzbar zu
    machen.
    Mit Z können Datentypen prädikativ beschrieben werden, die nicht oder
    nur mit großem Aufwand zu implementieren sind. Doch bieten diese
    Datentypen
    den Vorteil, daß sie zu leichter verständlichen Spezifikationen
    führen,
    da bei starker Abstraktion viele für die Funktionalität des zu
    entwickelnden
    Programms unwesentliche Details wegfallen. Zu einem späteren Zeitpunkt
    werden jedoch besser implementierbare Datentypen benötigt.
    Es ist in Z möglich, einen (abstrakten) Datentypen durch einen anderen
    (konkreten) Datentypen zu ersetzen, so daß Programme, die bei
    Verwendung
    des abstrakten Datentypen korrekt waren, es auch bei Verwendung des
    konkreten
    Datentypen bleiben. Dieses Verfahren heißt Datenverfeinerung. Als
    Beweismethode zum Nachweis einer Datenverfeinerung dient die
    Simulation.
    Bis zu einem gewissen Grade lässt sich die Datenverfeinerungstheorie
    auch im Zusammenhang mit unsichtbaren Operationen verwenden, die durch
    Hiding entstehen. Es werden einige Regeln entwickelt, die auf den
    Regeln
    zur Datenverfeinerung in Z basieren und benutzt werden können, um
    Simulationsbeziehungen
    zwischen CSP-Z-Spezifikationen zu beweisen.
    Die Anwendung der entwickelten Regeln wird anhand kleinerer
    Fallstudien
    veranschaulicht.},
  school = {Carl von Ossietzky Universität Oldenburg},
  month      = {Januar},
  year       = {1997},
  stupsfile  = {http://www.stups.uni-duesseldorf.de/publications/diplom.pdf},
}



@inproceedings{BrLeSa98_68,
  author     = {Maurice Bruynooghe and Michael Leuschel and Konstantinos Sagonas},
  title      = {A Polyvariant Binding-Time Analysis for Off-line Partial Deduction},
  booktitle  = {ESOP},
  editor     = {C. Hankin},
  publisher  = {Springer-Verlag},
  series     = {Lecture Notes in Computer Science},
  volume     = {1381},
  isbn       = {3-540-64302-8},
  month      = {April},
  pages      = {27--41},
  year       = {1998},
  stupsfile  = {http://www.stups.uni-duesseldorf.de/publications/bta.esop.pdf},
}
@inproceedings{DeDeLeMaSa98_69,
  author     = {Stefaan Decorte and Danny De Schreye and Michael Leuschel and
                Bern Martens and Konstantinos Sagonas},
  title      = {Termination Analysis for Tabled Logic Programming},
  booktitle  = {LOPSTR '97},
  editor     = {N. Fuchs},
  publisher  = {Springer-Verlag},
  series     = {Lecture Notes in Computer Science},
  volume     = {1463},
  isbn       = {3-540-65074-1},
  month      = {July},
  pages      = {111--127},
  year       = {1998},
  stupsfile  = {http://www.stups.uni-duesseldorf.de/publications/term.paper.pdf},
}
@inproceedings{Le98_70,
  author     = {Michael Leuschel},
  title      = {Improving Homeomorphic Embedding for Online Termination},
  booktitle  = {LOPSTR '98},
  editor     = {P. Flener},
  publisher  = {Springer-Verlag},
  series     = {Lecture Notes in Computer Science},
  volume     = {1559},
  isbn       = {3-540-65765-7},
  month      = {June},
  pages      = {199--218},
  year       = {1998},
  stupsfile  = {http://www.stups.uni-duesseldorf.de/publications/gh-lopstr.pdf},
}
@inproceedings{Le98_71,
  author     = {Michael Leuschel},
  title      = {On the Power of Homeomorphic Embedding for Online Termination},
  booktitle  = {Proceedings SAS},
  editor     = {Giorgio Levi},
  publisher  = {Springer-Verlag},
  series     = {Lecture Notes in Computer Science},
  volume     = {1503},
  isbn       = {3-540-65014-8},
  month      = {September},
  pages      = {230--245},
  year       = {1998},
  stupsfile  = {http://www.stups.uni-duesseldorf.de/publications/gh-sas.pdf},
}
@inproceedings{Le98_72,
  author     = {Michael Leuschel},
  title      = {Program Specialisation and Abstract Interpretation Reconciled},
  booktitle  = {IJCSLP},
  editor     = {J. Jaffar},
  publisher  = {MIT Press},
  pages      = {220--234},
  year       = {1998},
  stupsfile  = {http://www.stups.uni-duesseldorf.de/publications/apd.jicslp98.pdf},
}
@article{LeDe98_73,
  author     = {Michael Leuschel and Danny De Schreye},
  title      = {Constrained Partial Deduction and the Preservation of Characteristic
                Trees},
  journal    = {New Generation Computing},
  volume     = {16},
  number     = {3},
  pages      = {283--342},
  year       = {1998},
}
@article{LeDe98_74,
  author     = {Michael Leuschel and Danny De Schreye},
  title      = {Creating Specialised Integrity Checks Through Partial Evaluation of
                Meta-interpreters},
  journal    = {Journal of Logic Programming},
  volume     = {36},
  number     = {2},
  pages      = {149--193},
  year       = {1998},
  stupsfile  = {http://www.stups.uni-duesseldorf.de/publications/icjourn.ps},
}
@article{LeMaDe98_75,
  author     = {Michael Leuschel and Bern Martens and Danny De Schreye},
  title      = {Controlling Generalisation and Polyvariance in Partial Deduction of
                Normal Logic Programs},
  journal    = {ACM Transactions on Programming Languages and Systems},
  volume     = {20},
  number     = {1},
  month      = {January},
  pages      = {208--258},
  year       = {1998},
}
@article{LeMaDe98_76,
  author     = {Michael Leuschel and Bern Martens and Danny De Schreye},
  title      = {Some Achievements and Prospects in Partial Deduction},
  journal    = {ACM Computing Surveys},
  volume     = {30},
  number     = {3es},
  month      = {September},
  year       = {1998},
}
@inproceedings{LeMaSa98_77,
  author     = {Michael Leuschel and Bern Martens and Konstantinos Sagonas},
  title      = {Preserving Termination of Tabled Logic Programs While Unfolding},
  booktitle  = {LOPSTR '97},
  editor     = {N. Fuchs},
  publisher  = {Springer-Verlag},
  month      = {July},
  pages      = {189--205},
  series     = {Lecture Notes in Computer Science},
  volume     = {1463},
  isbn       = {3-540-65074-1},
  year       = {1998},
  stupsfile  = {http://www.stups.uni-duesseldorf.de/publications/xsb.lopstr.pdf},
}
@article{SaLe98_78,
  author     = {Konstantinos Sagonas and Michael Leuschel},
  title      = {Extending Partial Deduction to Tabled Execution: Some Results and Open
                Issues},
  journal    = {ACM Computing Surveys},
  volume     = {30},
  number     = {3es},
  month      = {September},
  year       = {1998},
}



@article{DeGlJoLeMaSo99_57,
  author     = {Danny De Schreye and Robert Glueck and Jesper J{\o}rgensen and Michael Leuschel
                and Bern Martens and Morten H. S{\o}rensen},
  title      = {Conjunctive Partial Deduction: Foundations, Control, Algorithms, and
                Experiments},
  journal    = {Journal of Logic Programming},
  volume     = {41},
  number     = {2--3},
  month      = {November},
  pages      = {231--277},
  year       = {1999},
  stupsfile  = {http://www.stups.uni-duesseldorf.de/publications/jlpfold.pdf},
}
@inproceedings{GlLe99_58,
  author     = {Robert Glueck and Michael Leuschel},
  title      = {Abstraction-Based Partial Deduction for Solving Inverse Problems -- A
                Transformational Approach to Software Verification},
  booktitle  = {Ershov Memorial Conference},
  publisher  = {Springer-Verlag},
  pages      = {93--100},
  series     = {Lecture Notes in Computer Science},
  volume     = {1755},
  isbn       = {3-540-67102-1},
  year       = {1999},
}
@inproceedings{HaBuCuHeLeMaSmUlWa99_59,
  author     = {P. Hartel and Michael Butler and Andrew Currie and P. Henderson and
                Michael Leuschel and A. Martin and A. Smith and Ulrich Ultes-Nitsche
                and R.J. Walters},
  title      = {Questions and Answers About Ten Formal Methods},
  booktitle  = {Proc. 4th Int. Workshop on Formal Methods for Industrial Critical Systems},
  abstract   = {An abstract model of an industrial distributed data base application
    has been studied using process based, state based, and queueing theory
    based methods. The methods supported by graphical notations and/or
    integrated development environments were found to be easiest to work
    with. The methods supported by model checkers were the most successful
    in obtaining relevant information about the application.

    Applying a number of different methods to study one particular model
    encourages a problem to be viewed from different angles. This gives
    complementary information about the model.  We report on a variety of
    problems of the model found through various routes. Our main
    conclusion
    is that asking experts to apply different methods and tools at a
    sufficiently abstract level can be done effectively revealing a broad
    range of information about the considered application.},
  editor     = {S. Gnesi and D. Latella},
  publisher  = {STAR/CNR, Pisa, Italy},
  month      = {July},
  ISBN       = {88-7958-009-4},
  pages      = {179--203},
  year       = {1999},
}
@inproceedings{Le99_60,
  author     = {Michael Leuschel},
  title      = {Advanced Logic Program Specialisation},
  booktitle  = {Partial Evaluation - Practice and Theory,
                DIKU 1998 International Summer School},
  publisher  = {Springer-Verlag},
  ISBN       = {3-540-66710-5},
  pages      = {271--292},
  isbn       = {3-540-66710-5},
  year       = {1999},
  stupsfile  = {http://www.stups.uni-duesseldorf.de/publications/pesummer2.pdf},
}
@proceedings{Le99_61,
  editor     = {Michael Leuschel},
  title      = {Int. Workshop on Optimization and Implementation of Declarative
                Programs},
  journal    = {Electronic Notes in Theoretical Computer Science},
  volume     = {30},
  number     = {2},
  month      = {December},
  pages      = {94--},
  year       = {1999},
}
@inproceedings{Le99_62,
  author     = {Michael Leuschel},
  title      = {Logic Program Specialisation},
  booktitle  = {Partial Evaluation: Practice and Theory},
  editor     = {John Hatcliff and Torben AE Mogensen and Peter Thiemann},
  publisher  = {Springer-Verlag},
  series     = {Lecture Notes in Computer Science},
  volume     = {1706},
  ISBN       = {3-540-66710-5},
  pages      = {155--188},
  year       = {1999},
  stupsfile  = {http://www.stups.uni-duesseldorf.de/publications/pesummer1.pdf},
}
@article{LeJo99_63,
  author     = {Michael Leuschel and Jesper J{\o}rgensen},
  title      = {Efficient Specialisation in {Prolog} Using the Hand-Written
                Compiler Generator {LOGEN}},
  journal    = {Electronic Notes in Theoretical Computer Science},
  volume     = {30},
  number     = {2},
  pages      = {157-162},
  year       = {1999},
}
@techreport{LeJo99_64,
  author     = {Michael Leuschel and Jesper J{\o}rgensen},
  title      = {Efficient Specialisation in {Prolog} Using a Hand-Written
                Compiler Generator},
  institution = {University of Southampton},
  number     = {DSSE-TR-99-6},
  month      = {September},
  year       = {1999},
}
@inproceedings{LeLiTh99_65,
  author     = {Michael Leuschel and Nick Linnenbruegger and Jerome Thoma},
  title      = {Analyzing Context-Free and Context-Sensitive Grammars by Abstract
                Interpretation},
  booktitle  = {Proceedings of the Formal Grammar Conference FG'99},
  editor     = {G-J. M. Kruijff and R. T. Oerle},
  publisher  = {University of Utrecht},
  month      = {August},
  pages      = {93--101},
  year       = {1999},
}
@inproceedings{LeMa99_66,
  author     = {Michael Leuschel and Thierry Massart},
  title      = {Infinite State Model Checking by Abstract Interpretation and Program
                Specialisation},
  booktitle  = {LOPSTR '99},

  abstract   = {We illustrate the use of logic programming techniques for finite model
    checking of CTL formulae.  We present a technique for infinite state
    model checking of safety properties based upon logic program
    specialisation and analysis techniques. The power of the approach is
    illustrated on several examples.  For that, the efficient tools
    logen and ecce are used.  We discuss how this approach has to
    be extended to handle more complicated infinite state systems and to
    handle arbitrary CTL formulae.},
  editor     = {A. Bossi},
  publisher  = {Springer-Verlag},
  month      = {September},
  pages      = {63--82},
  series     = {Lecture Notes in Computer Science},
  volume     = {1817},
  isbn       = {3-540-67628-7},
  year       = {1999},
  stupsfile  = {http://www.stups.uni-duesseldorf.de/publications/mc-lopstr99.pdf},
}
@inproceedings{MaLe99_67,
  author     = {Jonathan C. Martin and Michael Leuschel},
  title      = {Sonic Partial Deduction},
  booktitle  = {Ershov Memorial Conference},
  publisher  = {Springer-Verlag},
  pages      = {101--112},
  series     = {Lecture Notes in Computer Science},
  volume     = {1755},
  isbn       = {3-540-67102-1},
  year       = {1999},
}
@techreport{HaBu99_300,
  author     = {Stefan Hallerstede and Michael Butler},
  title      = {Refinement of Dynamic Systems},
  institution    = {Electronics and Computer Science, University of Southampton},
  abstract   = {Existing refinement frameworks such as B allow a developer to specify
    a system on an abstract level. Subsequently, this abstract
    specification is refined into an implementation that performs the
    specified task. In this paper a conventional refinement approach is
    extended with a means for performance analysis. This new approach
    guides a developer towards well-performing implementations throughout
    the refinement process.
    The main achievement of this work is an elaboration of a connection
    between performance and trace refinement.},
  year       = {1999},
  dbslinks = {[http://eprints.ecs.soton.ac.uk/2949/|PDF]},
}



@inproceedings{CuLeMa00_49,
  author     = {Andrew Currie and Michael Leuschel and Thierry Massart},
  title      = {{LTL} Model Checking of {CSP} by Refinement:
                How to Make {FDR} Spin},
  abstract   = {We show how to (and how not to) perform LTL model checking of CSP
    processes using refinement checking in general and the FDR tool in
    particular.
    We show how one can handle (potentially) deadlocking systems,
    discuss the validity of our approach for infinite state systems,
    and shed light on the relationship between ``classical'' model
    checking and refinement checking.},
  month      = {July},
  booktitle = {Proceedings VCL'2000},
  address= {London, UK},
  year       = {2000},
}
@inproceedings{LeLe00_50,
  author     = {Helko Lehmann and Michael Leuschel},
  title      = {Decidability Results for the Propositional Fluent Calculus},
  booktitle  = {Computational Logic},
  editor     = {John LLoyd},
  publisher  = {Springer-Verlag},
  month      = {July},
  series     = {Lecture Notes in Computer Science},
  volume     = {1861},
  isbn       = {3-540-67797-6},
  pages      = {762--776},
  year       = {2000},
}
@inproceedings{LeLe00_51,
  author     = {Helko Lehmann and Michael Leuschel},
  title      = {Solving Planning Problems by Partial Deduction},
  booktitle  = {LPAR},
  editor     = {Michel Parigot and Andrei Voronkov},
  publisher  = {Springer-Verlag},
  series     = {Lecture Notes in Computer Science},
  volume     = {1955},
  year       = {2000},
  stupsfile  = {http://www.stups.uni-duesseldorf.de/publications/paper_camera_ready.ps},
}
@techreport{LeBr00_52,
  author     = {Michael Leuschel and Maurice Bruynooghe},
  title      = {Control Issues in Partial Deduction: The Ever Ending Story},
  abstract   = {Partial deduction is a source-to-source technique for specialising
    logic programs.
    This is (mostly) done by a well-automated application of parts of the
    Burstall and Darlington unfold/fold  transformation framework.
    One of the main challenges of partial deduction is automatic control,
    which has to ensure correctness, efficiency, and termination.
    In this survey and tutorial, we present the essential developments
    over the past 10 years, and discuss their respective merits and
    shortcomings.
    We also present the current state of the art and discuss areas where
    further research is needed to enable
    more widespread practical use of partial deduction and realise its
    potential as a tool for systematic program development.},
  institution = {University of Southampton},
  month      = {October},
  pages      = {45--},
  year       = {2000},
}
@inproceedings{LeLe00_53,
  author     = {Michael Leuschel and Helko Lehmann},
  title      = {Coverability of Reset Petri Nets and other Well-Structured Transition
                Systems by Partial Deduction},
  booktitle  = {Computational Logic},
  abstract   = {In recent work it has been shown that infinite state model checking
    can be
    performed by a combination of partial deduction of logic programs and
    abstract
    interpretation. It has also been shown that partial deduction is
    powerful
    enough to mimic certain algorithms to decide coverability properties
    of Petri
    nets. These algorithms are forward algorithms and hard to scale up to
    deal with more complicated systems. Recently, it has been proposed to
    use a
    backward algorithm scheme instead. This scheme is applicable to
    so--called well--structured transition systems and was successfully
    used,
    e.g., to solve coverability problems for reset Petri nets. In this
    paper, we
    discuss how partial deduction can mimic many of these backward
    algorithms as
    well. We prove this link in particular for reset Petri nets and Petri
    nets
    with transfer and doubling arcs.  We thus establish a surprising link
    between
    algorithms in Petri net theory and program specialisation, and also
    shed light
    on the power of using logic program specialisation for infinite state
    model
    checking.},
  editor     = {John Lloyd and Ver{\'o}nica Dahl and
               Ulrich Furbach and Manfred Kerber and
               Kung-Kiu Lau and Catuscia Palamidessi and
               Lu\'{\i}s Moniz Pereira and Yehoshua Sagiv and
               Peter J. Stuckey},
  publisher  = {Springer-Verlag},
  month      = {July},
  ISBN       = {3-540-67797-6},
  series     = {Lecture Notes in Computer Science},
  volume     = {1861},
  pages      = {101--115},
  year       = {2000},
  stupsfile  = {http://www.stups.uni-duesseldorf.de/publications/CL2000_camera_ready.pdf},
}
@inproceedings{LeLe00_54,
  author     = {Michael Leuschel and Helko Lehmann},
  title      = {Solving Coverability Problems of Petri Nets by Partial Deduction},
  booktitle  = {PPDP},
  abstract   = {In recent work it has been shown that infinite state model checking
    can be performed by a combination of partial deduction of logic
    programs and abstract interpretation.  This paper focuses on one
    particular class of problem--coverability for (infinite state) Petri
    nets--and shows how existing techniques and tools for declarative
    programs can be successfully applied.  In particular, we show that a
    restricted form of partial deduction is already powerful enough to
    decide all coverability properties of Petri Nets.  We also prove that
    two particular instances of partial deduction exactly compute the
    Karp-Miller tree as well as Finkel's minimal coverability set.  We
    thus establish an interesting link between algorithms for Petri nets
    and logic program specialisation.},
  editor     = {Maurizio Gabbrielli and Frank Pfenning},
  publisher  = {ACM Press},
  month      = {September},
  pages      = {268--279},
  year       = {2000},
  stupsfile  = {http://www.stups.uni-duesseldorf.de/publications/PPDP2000.pdf},
}
@proceedings{PoRaUl00_55,
  editor     = {Michael Leuschel and Andreas Podelski and C.R. Ramakrishnan and Ulrich Ultes-Nitsche},
  title      = {Proceedings of the Workshop on Verification and Computational Logic
                VCL'2000},
  abstract   = {The aim of this workshop is to bring together researchers working on
    the interplay between verification techniques (e.g., model checking,
    reduction, and abstraction) and logic programming techniques (e.g.,
    constraints, abstract interpretation, program transformation).},
  month      = {July},
  pages      = {150--},
  year       = {2000},
  dbslinks = {[http://users.ecs.soton.ac.uk/mal/vcl2000.html|VCL'2000 Website]},
}



@inproceedings{AdLe01_42,
  author     = {Laksono Adhianto and Michael Leuschel},
  title      = {Strategy for Improving Memory Locality Reuse and Exploiting Hidden
                Parallelism},
  booktitle  = {Proceedings of ISSM},
  abstract   = {In recent years, methods for analyzing and parallelizing sequential
    code using data analysis and loop transformations have been developed.
    These techniques have proved remarkably successful, and have been used
    to move from sequential to parallel codes, or to improve efficiency of
    existing parallel codes. Our research focuses on Fortran code
    optimisation for parallelisation in Shared Memory architectures by
    using data analysis and loop source-to-source transformations. Our
    optimisation strategy, although designed for OpenMP directives, is
    sufficiently general to be used for pure Fortran code. Our algorithm
    has been implemented as a tool called Automatic Guidance Module (AGM),
    and have received high evaluation scores from our industrial partners},
  month      = {August},
  year       = {2001},
}
@article{GlHaLeMa01_43,
  author     = {Hugh Glaser and Pieter H. Hartel and Michael Leuschel
                and Andrew Martin},
  title      = {Declarative Languages in Education},
  journal    = {Encyclopaedia of Microcomputers},
  editor     = {Allen Kent and James G Williams},
  publisher  = {Marcel Dekker Inc},
  ISBN       = {0-8247-2726-6},
  volume     = {27},
  pages      = {79--102},
  year       = {2001},
  stupsfile  = {http://www.stups.uni-duesseldorf.de/publications/dsse-tr-2000-1.ps},
}
@inproceedings{Le01_44,
  author     = {Michael Leuschel},
  title      = {Design and Implementation of the High-Level Specification Language
                {CSP(LP)}},
  booktitle  = {PADL},
  abstract   = {We describe practical experiences of using a logic programming based
    approach to model and reason about concurrent systems.
    We argue that logic programming is a good foundation for developing,
    prototyping, animating new specification languages.
    In particular, we present the new high-level specification language
    CSP(LP), unifying CSP with concurrent (constraint) logic programming,
    and which can be used to formally reason both about logical and
    concurrent aspects of critical systems.},
  publisher  = {Springer},
  month      = {October},
  ISSN       = {0302-9743},
  ISBN       = {3-540-41768-0},
  pages      = {14--28},
  series     = {Lecture Notes in Computer Science},
  volume     = {1990},
  year       = {2001},
  stupsfile  = {http://www.stups.uni-duesseldorf.de/publications/csp-padl-final.pdf},
}
@inproceedings{LeAdBuFeMi01_45,
  author     = {Michael Leuschel and Laksono Adhianto and Michael Butler and Carla
                Ferreira and Leonid Mikhailov},
  title      = {Animation and Model Checking of {CSP} and {B} using {Prolog} Technology},
  booktitle  = {Proceedings of the ACM Sigplan Workshop on Verification and Computational Logic},
  abstract   = {We describe practical experiences of using a logic programming based
    approach to model and reason about critical systems.
    We argue that logic programming with co-routining, constraints, and
    tabling is a good foundation for developing, animating, and model
    checking new specification languages.
    We present animators and model checkers currently being developed for
    two different extensions of CSP and for the B method.},
  editor     = {Michael Leuschel and Andreas Podelski and C.R. Ramakrishnan
                and Ulrich Ultes-Nitsche},
  month      = {September},
  pages      = {97--109},
  year       = {2001},
}
@inproceedings{LeMaCu01_46,
  author     = {Michael Leuschel and Thierry Massart and Andrew Currie},
  title      = {How to make FDR Spin: LTL model checking of CSP using Refinement},
  abstract   = {We study the possibility of doing LTL model checking on CSP
    specifications in the context of refinement.  We present evidence that
    the refinement-based approach to verification does not seem to be very
    well suited for verifying certain temporal properties.  To remedy this
    problem, we show how to (and how not to) perform LTL model checking of
    CSP processes using refinement checking in general and the FDR tool in
    particular.  We show how one can handle (potentially) deadlocking
    systems, discuss the validity of our approach for infinite state
    systems, and shed light on the relationship between ``classical''
    model checking and refinement checking.},
  editor     = {J.N. Oliviera, P. Zave},
 booktitle = {Proceedings FME'2001},
  publisher  = {Springer-Verlag},
  month      = {March},
  pages      = {99--118},
  year       = {2001},
  stupsfile  = {http://www.stups.uni-duesseldorf.de/publications/fme2001-final.pdf},
}
@proceedings{LePoRaUl01_47,
  editor     = {Michael Leuschel and Andreas Podelski and C.R. Ramakrishnan and Ulrich
                Ultes-Nitsche},
  title      = {Proceedings of the ACM Sigplan Workshop on Verification and
                Computational Logic VCL'2001},
  month      = {September},
  year       = {2001},
}
@inproceedings{LeWoMaAd01_48,
  author     = {Michael Leuschel and Ivan Wolton and Thierry Massart and Laksono
                Adhianto},
  title      = {Temporal Logic Model Checking of {CSP}: Tools and Techniques},
  booktitle  = {AVoCS 2001},
  abstract   = {We study the possibility of doing LTL model checking on CSP
    specifications in the context of refinement.
    We present a technique to perform LTL
    model checking of CSP processes using refinement checking in general
    and the FDR tool in
    particular.  We present a tool which
    automates the translation process from LTL model checking to CSP
    refinement.
    Also, if time permits, we will present another tool which uses
    latest generation Prolog technology to symbolically
    animate, compile, and model check CSP specifications.},
  editor     = {David Nowak},
  publisher  = {Oxford University Computing Laboratory},
  month      = {April},
  year       = {2001},
}
@phdthesis{Ha01_301,
  author     = {Stefan Hallerstede},
  title      = {Performance-Oriented Refinement},
  abstract   = {We introduce the probabilistic action system formalism which combines
    refinement with performance. Performance is expressed by means of
    probability and expected costs. Probability is needed to express
    uncertainty present in physical environments. Expected costs express
    physical or abstract quantities that describe a system. They encode
    the performance objective. The behaviour of probabilistic action
    systems is described by traces of expected costs. Corresponding
    notions of refinement and simulation-based proof rules are introduced.

    Formal notations like B or action systems support a notion of
    refinement. Refinement relates an abstract specification AA to a more
    deterministic concrete specification CC. Knowing AA and CC one proves
    CC refines, or implements, specification AA. In this study we consider
    specification AA as given and concern ourselves with a way to find a
    good candidate for implementation CC. To this end we classify all
    implementations of an abstract specification according to their
    performance. The performance of a specification AA is a value val.AA
    associated with some optimal behaviour it may exhibit. We distinguish
    performance from correctness. Concrete systems that do not meet the
    abstract specification are excluded. Only the remaining correct
    implementations CC are considered with respect to their performance. A
    good implementation of a specification is identified by having some
    optimal behaviour in common with it. In other words, a good refinement
    corresponds to a reduction of non-optimal behaviour. This also means
    that the abstract specification sets a boundary val.AA for the
    performance of any implementation. An implementation may perform worse
    than its specification but never better.

    Probabilistic action systems are based on discrete-time Markov
    decision processes. Numerical methods solving the optimisation
    problems posed by Markov decision processes are well-known, and used
    in a software tool that we have developed. The tool computes an
    optimal behaviour of a specification AA, and the associated value
    val.AA, thus assisting in the search for a good implementation CC.

    We present examples and case studies to demonstrate the use of
    probabilistic action systems. },
  school  = {Electronics and Computer Science, University of Southampton},
  year       = {2001},
  dbslinks = {[http://eprints.ecs.soton.ac.uk/9294/|PDF]},
}



@techreport{LeLe02_36,
  author     = {Helko Lehmann and Michael Leuschel},
  title      = {Generating inductive verification proofs for {Isabelle} using the
                partial evaluator {Ecce}},
  abstract   = {Ecce is a partial deduction system which can be used to automatically
    generate abstractions for the model checking of many infinite state
    systems. We
    show that to verify the abstractions generated by Ecce we may employ
    the
    proof assistant Isabelle. Thereby Ecce is used to generate
    the specification, hypotheses and proof script in Isabelle's theory
    format. Then, in many cases, Isabelle can automatically execute these
    proof
    scripts and thereby verify the soundness of Ecce's abstraction. In
    this work we
    focus on the specification and verification of Petri nets.},
  month      = {September},
  institution = {ECS, University of Southampton},
  number     = {DSSE-TR-2002-02},
  year       = {2002},
  stupsfile  = {http://www.stups.uni-duesseldorf.de/publications/is-tr.dsse-2002-2.pdf},
}
@inproceedings{Le02_37,
  author     = {Michael Leuschel},
  title      = {Homeomorphic Embedding for Online Termination of Symbolic Methods},
  abstract   = {Well-quasi orders in general, and homeomorphic embedding
    in particular, have gained popularity to ensure
    the termination of techniques for program analysis, specialisation,
    transformation, and verification.
    In this paper we survey and discuss this use of homeomorphic
    embedding and clarify the advantages of
    such an approach over one using well-founded orders.
    We also discuss various extensions of the homeomorphic embedding
    relation.
    We conclude with a study of homeomorphic embedding in the context
    of metaprogramming, presenting some new (positive and negative)
    results and open
    problems.},
  booktitle  = {The Essence of Computation -- Essays dedicated to Neil Jones},
  editor     = {Torben Mogensen, David Schmidt, I. H. Sudborough},
  publisher  = {Springer-Verlag},
  series     = {Lecture Notes in Computer Science},
  volume     = {2566},
  ISBN       = {3-540-00326-6},
  pages      = {379--403},
  year       = {2002},
  stupsfile  = {http://www.stups.uni-duesseldorf.de/publications/state-of-the-art.final.pdf},
}
@article{LeBr02_38,
  author     = {Michael Leuschel and Maurice Bruynooghe},
  title      = {Logic program specialisation through partial deduction: Control Issues},
  abstract   = {Program specialisation aims at improving the overall performance of
    programs by performing source to source transformations. A common
    approach within functional and logic programming, known respectively
    as partial evaluation and partial deduction, is to exploit partial
    knowledge about the input.  It is achieved through a well-automated
    application of parts of the Burstall-Darlington unfold/fold
    transformation framework. The main challenge in developing systems
    is to design automatic control that ensures correctness, efficiency,
    and termination.  This survey and tutorial presents the main
    developments in controlling partial deduction over the past 10 years
    and analyses their respective merits and shortcomings.  It ends with
    an assessment of current achievements and sketches some remaining
    research challenges.},
  journal    = {Theory and Practice of Logic Programming},
  volume     = 2,
  number     = {4--5},
  publisher  = {Cambridge University Press},
  month      = {July},
  pages      = {461--515},
  issn       = {1471-0684},
  year       = {2002},
  stupsfile  = {http://www.stups.uni-duesseldorf.de/publications/pdcontrol.tplpfinal.pdf},
}
@inproceedings{LeGr02_39,
  author     = {Michael Leuschel and Stefan Gruner},
  title      = {Abstract Conjunctive Partial Deduction using Regular Types and its
                Application to Model Checking},
  abstract   = {We present an abstract
    partial deduction technique which uses regular types as its domain and
    which
    can handle conjunctions, and thus perform deforestation and tupling.
    We provide a detailed description of all the required operations and
    present
    an implementation within the Ecce system.
    We discuss the power of this new specialisation algorithm,
    especially in the light of verifying and specialising infinite state
    process algebras.
    Here, our new algorithm can provide a more precise treatment of
    synchronisation and can be used for refinement checking.
    Paper Available:
    http://link.springer.de/link/service/series/0558/tocs/t2372.htm#toc2372},
  booktitle  = {LOPSTR},
  editor     = {Alberto Pettorossi},
  publisher  = {Springer-Verlag},
  series     = {Lecture Notes in Computer Science},
  volume     = {2372},
  ISBN       = {3-540-43915-3},
  pages      = {91--110},
  year       = {2002},
}
@inproceedings{LeMa02_40,
  author     = {Michael Leuschel and Thierry Massart},
  title      = {Logic programming and partial deduction for the verification of
                reactive systems: An experimental evaluation},
  booktitle  = {AVoCS},
  abstract   = {In earlier work it has been shown that finite state CTL model
    checking of reactive systems
    can be achieved by a relatively simple interpreter written in tabled
    logic programming.<br/>
    This approach is flexible in the sense that various specification formalisms
    can be easily targeted (e.g., Petri nets, CSP, ...).
    Moreover, infinite state CTL model checking can be
    performed by analysing this interpreter using a combination of partial
    deduction and abstract
    interpretation. It has also been shown that this approach is powerful
    enough to decide coverability properties of various kinds of Petri nets.
    <br/>
    In this ongoing work, we are empirically evaluating these
    approaches on various case studies of finite,
    parameterised and infinite systems.  For finite state systems, we show
    how our approach and tool compares to standard  tools
    for finite state model checking
    For parameterised or infinite state model checking, we are comparing
    our results with, e.g., XMC, Hytech.},
  editor     = {Gethin Norman and Marta Kwiatkoska and Dimitar Guelev},
  publisher  = {University of Birmingham},
  editor     = {Gethin Norman and Martha Kwiatkowska and Dimitar Guelev},
  pages      = {143--149},
  year       = {2002},
  stupsfile  = {http://www.stups.uni-duesseldorf.de/publications/Avocs2002.pdf},
}
@inproceedings{VaAlLe02_41,
  author     = {Mauricio Varea and Bashir Al-Hashimi and Michael Leuschel},
  title      = {Finite and Infinite Model Checking of Dual Transition Petri Net Models},
  booktitle  = {AVoCS},
  month      = {April},
  pages      = {265--269},
  year       = {2002},
  stupsfile  = {http://www.stups.uni-duesseldorf.de/publications/Birmingham.pdf},
}
@proceedings{02_100,
  title      = {Logic Based Program Synthesis and Transformation, Proceedings of
                LOPSTR'02, Revised Selected Papers},
  editor     = {Michael Leuschel},
  series     = {Lecture Notes in Computer Science},
  volume     = {2664},
  ISSN       = {0302-9743},
  ISBN       = {3-540-40438-4},
  year       = {2002},
}
@proceedings{02_101,
  title      = {Proceedings of the ACM Sigplan International Workshop on Verification
                and Computational Logic (VCL'2002)},
  editor     = {Michael Leuschel and Ultes-Nitsche, Ulrich},
  year       = {2002},
}
@inproceedings{Ha02_293,
  author     = {Stefan Hallerstede and Michael Butler},
  title      = {A Performance-oriented Refinement Assistant},
  booktitle  = {RCS '02: International Workshop on Refinement of Critical Systems:
                Methods, Tools and Experience},
  abstract   = {Stepwise refinement transforms an abstract specification into a more
    deterministic concrete specification. Ultimately one arrives at a
    specification that is implementable. At the various stages in the
    refinement process decisions are made that determine how the final
    implementation operates. Different implementations can be compared
    with respect to their expected performance within their environment.
    In this sense refinement poses an optimisation problem. We present a
    B-based language and a tool that can assist in solving this
    optimisation problem.},
  year       = {2002},
  stupsfile  = {http://www.stups.uni-duesseldorf.de/publications/rcs02-performanceoriented.pdf},
}



@inproceedings{AuFeGrLeNG03_24,
  author     = {Juan Carlos Augusto and Carla Ferreira and Andy M. Gravell and Michael
                Leuschel and Karen M.Y. Ng},
  title      = {The Benefits of Rapid Modelling for E-Business System Development},
  booktitle  = {ER (Workshops)},
  editor     = {Manfred A. Jeusfeld and Oscar Pastor},
  publisher  = {Springer Verlag},
  series     = {Lecture Notes in Computer Science},
  volume     = {2814},
  isbn       = {3-540-20257-9},
  pages      = {17--28},
  year       = {2003},
  stupsfile  = {http://www.stups.uni-duesseldorf.de/publications/ecomo.pdf},
}
@inproceedings{AuLeBuFe03_25,
  author     = {Juan Carlos Augusto and Michael Leuschel and Michael Butler and Carla
                Ferreira},
  title      = {Using the Extensible Model Checker {XTL} to Verify {StAC}
                Business Specifications},
  editor     = {Michael Leuschel and Stefan Gruner and Stephane Lo Presti},
  booktitle  = {AVoCS},
  pages      = {253--266},
  year       = {2003},
  stupsfile  = {http://www.stups.uni-duesseldorf.de/publications/avocs03.pdf},
}
@article{BuLeLoAlBeBoCuKi03_26,
  author     = {Michael Butler and Michael Leuschel and Stephane Lo Presti and David
                Allsopp and Patrick Beautement and Chris Booth and Mark Cusack and
                Mike Kirton},
  title      = {Towards a Trust Analysis Framework for Pervasive Computing Scenarios},
  abstract   = {We present a scheme for highlighting the trust issues of merit within
    pervasive computing, based on an analysis of scenarios from the
    healthcare domain.  The first scenario helps us define an analysis
    grid, where the human and technical aspects of trust are considered.
    The analysis is applied to a second scenario to examine its
    suitability.  We then discuss the various categories of the analysis
    grid in the light of this examination and of the literature on the
    subject of trust.  We believe that this approach could form the basis
    of a generalised trust analysis framework to support the design,
    procurement and use of pervasive computing. (The PDF is an extended version of the paper.)},
  year       = {2003},
  journal = {IEEE Computing},
  volume = 2,
  number = 3,
  page = {96},
  stupsfile  = {http://www.stups.uni-duesseldorf.de/publications/aamas-workshop03.pdf},
}
@inproceedings{CrLe03_27,
  author     = {Stephen Craig and Michael Leuschel},
  title      = {A Compiler Generator for Constraint Logic Programs},
  booktitle  = {Ershov Memorial Conference},
  abstract   = {The Cogen approach to program specialisation, writing a compiler
    generator instead of a specialiser, has been used with considerable
    success. This paper demonstrates that the Cogen approach is also
    applicable to the specialisation of constraint logic programs and
    leads to effective specialisers. We present the basic specialisation
    technique for CLP(Q) programs and show how we can handle
    non-declarative features as well. We present an implemented system
    along with experimental results.},
  editor     = {M. Broy and A. Zamulin},
  publisher  = {Springer-Verlag},
  series     = {Lecture Notes in Computer Science},
  volume     = {2890},
  year       = {2003},
  stupsfile  = {http://www.stups.uni-duesseldorf.de/publications/clp-final.ps},
}
@inproceedings{ElLeCo03_28,
  author     = {Daniel Elphick and Michael Leuschel and Simon Cox},
  title      = {Partial Evaluation of {MATLAB}},
  booktitle  = {Proceedings of GPCE 2003},
  abstract   = {We describe the problems associated with the creation of high
    performance code for mathematical computations. We discuss the
    advantages and disadvantages of using a high level language like
    MATLAB and then propose partial evaluation as a way of lessening the
    disadvantages at little cost. We then go on to describe the design of
    a partial evaluator for MATLAB and present results showing what
    performance increases can be achieved and the circumstances in which
    partial evaluation can provide these.},
  booktitle  = {GPCE},
  editor     = {Frank Pfenning and Yannis Smaragdakis},
  publisher  = {Springer-Verlag},
  series     = {Lecture Notes in Computer Science},
  ISSN       = {0302-9743},
  ISBN       = {3-530-20102-5},
  pages      = {344--363},
  year       = {2003},
  stupsfile  = {http://www.stups.uni-duesseldorf.de/publications/Paper.pdf},
}
@inproceedings{LeLe03_30,
  author     = {Helko Lehmann and Michael Leuschel},
  title      = {Inductive Theorem Proving by Program Specialisation:
    Generating proofs for {Isabelle} using {Ecce} (Invited talk)},
  abstract   = {In this paper we discuss the similarities between program
    specialisation and inductive theorem
    proving, and then show how program specialisation can be used to
    perform inductive theorem proving.
    We then study this relationship in more detail for a particular class
    of problems
    (verifying infinite state Petri nets) in order to establish a clear
    link between program specialisation and inductive theorem proving.
    In particular, we use the program specialiser Ecce  to generate
    specifications, hypotheses and proof scripts in the theory format of
    the proof assistant Isabelle.
    Then, in many cases, Isabelle can automatically execute these proof
    scripts and thereby verify the soundness of Ecce's verification
    process and of the correspondence between program specialisation
    and inductive theorem proving.},
  booktitle  = {LOPSTR},
  editor     = {Maurice Bruynooghe},
  pages      = {1--19},
  publisher  = {Springer-Verlag},
  series     = {Lecture Notes in Computer Science},
  volume     = {3018},
  ISBN       = {3-540-22174-3},
  year       = {2003},
  stupsfile  = {http://www.stups.uni-duesseldorf.de/publications/itp_lopstr03_final.pdf},
}
@inproceedings{LeBu03_32,
  author     = {Michael Leuschel and Michael Butler},
  title      = {{ProB}: A Model Checker for {B}},
  abstract   = {We present ProB, an animation and model checking tool for the B
    method.
    ProB's animation facilities allow users to gain confidence in
    their specifications, and unlike the animator provided by the
    B-Toolkit, the user does not have to guess the right values for the
    operation arguments or choice variables.
    ProB contains a model checker and a constraint-based checker,
    both of which can  be used to detect various
    errors in B specifications.
    We present our first experiences in using ProB on several
    case studies, highlighting that
    ProB  enables users to uncover errors that are not easily
    discovered by existing tools.},
  booktitle  = {FME},
  editor     = {Araki Keijiro and Stefania Gnesi and Mandrio Dino},
  publisher  = {Springer-Verlag},
  series     = {Lecture Notes in Computer Science},
  volume     = {2805},
  ISBN       = {3-540-40828-2},
  pages      = {855--874},
  year       = {2003},
  stupsfile  = {http://www.stups.uni-duesseldorf.de/publications/prob_fme03_final.pdf},
  stupskeywords={prob},
}
@techreport{LeCrBrVa03_33,
  author     = {Michael Leuschel and Stephen Craig and Maurice Bruynooghe and Wim
                Vanhoof},
  title      = {Specializing Interpreters using Offline Partial Deduction},
  abstract   = {We present the latest version of the logen partial evaluation
    system for logic programs. In particular we present new binding-types,
    and show how they can be used to effectively specialise a wide variety
    of interpreters.We show how to achieve Jones-optimality in a
    systematic way  for several interpreters. Finally, we present and
    specialise a non-trivial interpreter for a small functional
    programming language. Experimental results are also presented,
    highlighting that the logen system can be a good basis for
    generating compilers for high-level languages.},
  number     = {DSSE-TR-2003-5},
  institution = {ECS, University of Southampton},
  month      = {November},
  year       = {2003},
  dbslinks   = {University of Southampton: [http://eprints.ecs.soton.ac.uk/8567/|eprints]},
  stupsfile  = {http://www.stups.uni-duesseldorf.de/publications/DSSE_TR_2003_5.pdf},
}
@proceedings{LeGrLo03_34,
  editor     = {Michael Leuschel and Stefan Gruner and Stephane Lo Presti},
  title      = {Proceedings of the 3rd Workshop on Automated Verification of Critical
                Systems (AVoCS'03)},
  abstract   = {The aim of this workshop is to foster a research community in
    verification in and beyond the United Kingdom of Great Britain through
    encouraging communication among researchers. Specific objectives
    include efforts at integration as well as the transfer of methods
    between different groups from academia and industry. The topics are to
    be interpreted broadly and inclusively, and in particular cover all
    aspects of verification (model checking, theorem proving,
    specification and refinement proofs, etc) pertaining to various types
    of critical systems, be it safety-critical, business-critical, or
    performance-critical.<br/>
    The first meeting, AVoCS'01, was held in Oxford (UK), continuing in
    the tradition of the annual DERA/OUCL series.
    The second meeting, AVoCS'02, was held in Birmingham (UK). <br/>
    Similarly to previous years, the meeting will be informal, and will
    combine invited lectures with accepted submissions. This year we also
    want to aim for wider, European and international attention.<br/>
    Available online at:
    http://www.ecs.soton.ac.uk/~mal/avocs03/},
  month      = {April},
  year       = {2003},
  dbslinks   = {[http://www.ecs.soton.ac.uk/~mal/avocs03/|Online at University of Southampton]},
  stupsfile  = {http://www.stups.uni-duesseldorf.de/publications/http://eprints.ecs.soton.ac.uk/archive/00007198/01/},
}
@inproceedings{VaLeAl03_35,
  author     = {Mauricio Varea and Michael Leuschel and Bashir Al-Hashimi},
  title      = {Improving Compositional Verification of State-based Models by Reducing
                Modular Unbalance},
  abstract   = {Compositional Verification is a viable way to tackle the state
    explosion problem. However, the decomposition of
    a system into smaller parts is not a trivial problem, and dividing the
    specification into modules can be regarded
    as one of the main issues that concerns a compositional approach. This
    paper concentrates on the application of compositional verification to
    state-based models, in order to reduce the number of nodes assigned to
    memory, thus avoiding state explosion and speeding up the
    verification. Furthermore, we investigate and propose an estimation
    method that improves the compositional verification process in modular
    designs, such that the amount of memory required by the process is
    minimised. This method has been applied to a real-life embedded
    system, producing meaningful results without the need of data
    abstraction.},
  booktitle  = {Refinement of Critical Systems},
  address    = {Turku, Finland},
  year       = {2003},
  stupsfile  = {http://www.stups.uni-duesseldorf.de/publications/rcs03.pdf},
}
@proceedings{03_99,
  title      = {Proceedings of the 2003 ACM SIGPLAN Workshop on Partial Evaluation and
                Semantics-Based Program Manipulation (PEPM'03)},
  abstract   = {This volume contains the papers presented at PEPM'03, the ACM SIGPLAN
    Workshop on Partial Evaluation and Semantics-Based Program
    Manipulation. PEPM'03 was held June 7th 2003 in San Diego, California
    in conjunction with the Programming Language Design and Implementation
    conference PLDI'03 as part of the Federated Computing Research
    Conference FCRC 2003. Due to organizational constraints, PEPM'03 had
    to be held on a single day, restricting the number of talks that could
    be presented.Papers were judged on their appropriateness for the
    workshop, their originality, technical strength and clarity. One
    submission was deemed outside the scope of PEPM, and all the other
    submissions were reviewed by at least 3 referees, with some help from
    the following outside reviewers: Elvira Albert, Stephen Craig,
    Santiago Escobar, and Carla Piazza. The PC meeting was electronic and
    resulted in 8 submissions being judged of conference quality' and
    selected for presentation at the workshop and inclusion in the
    proceedings.},
  editor     = {Michael Leuschel},
  publisher  = {ACM Press},
  ISBN       = {1-58113-667-6},
  year       = {2003},
}
@inproceedings{Ha03_288,
  author     = {Stefan Hallerstede},
  title      = {Parallel Hardware Design in B},
  booktitle  = {ZB 2003},
  abstract   = {We present the design of a parallel synchronous hardware component
    from a purely functional description of its behaviour. Starting from
    an abstract specification of a linear time-invariant (LTI) system in
    Event-B a pipelined implementation is developed. The presented
    approach is applicable to LTI systems that can be represented as
    linear constant-coefficient difference equations.},
  publisher  = {Springer-Verlag},
  pages      = {101--102},
  year       = {2003},
  dbslinks = {[http://www.springerlink.com/content/clm566try2u5dnyb/|PDF]},
}
@article{Ha03_289,
  author     = {Stefan Hallerstede},
  title      = {Specification and Refinement of Hardware Components in B},
  journal    = {System Specification & Design Languages - Best of FDL '02},
  abstract   = {We use the B formalism to derive functionally correct synchronous
    circuits. To represent the circuit we employ the hardware description
    language VHDL. This article outlines the development of a circuit
    design starting from an initial abstract functional specification of a
    system component. We discuss some topics involved in the translation
    to synthesisable VHDL and demonstrate the approach by way of an
    example.},
  editor     = {Eugenio Villar and Jean Mermet},
  publisher  = {Kluwer},
  pages      = {315--325},
  year       = {2003},
  dbslinks = {[http://www.springerlink.com/content/w6t3741vuu7656t7/|PDF]},
}



@inproceedings{BaLeVa04_13,
  author     = {Steve Barker and Michael Leuschel and Mauricio Varea},
  title      = {Efficient and Flexible Access Control via Logic Program Specialisation},
  booktitle  = {PEPM},
  abstract   = {We describe the use of a flexible meta-interpreter for performing
    access control checks
    on deductive databases. The meta-program is implemented in Prolog
    and takes as
    input a database and an access policy specification.
    We then proceed to specialise the
    meta-program for a given access policy and intensional database
    by using  the Logen partial evaluation
    system. In addition to describing the programs
    involved in our approach, we give a
    number of performance measures for our implementation of an access
    control
    checker, and we discuss the
    implications of using this approach for access control on
    deductive databases. In particular, we show that by using our
    approach we get flexible access control with virtually zero overhead.},
  editor     = {Nevin Heintze and Peter Sestoft},
  publisher  = {ACM Press},
  ISBN       = {1-58113-835-0},
  pages      = {190--119},
  year       = {2004},
  stupsfile  = {http://www.stups.uni-duesseldorf.de/publications/pe-sigproc.pdf},
}
@inproceedings{BuLeLoTu04_14,
  author     = {Michael Butler and Michael Leuschel and Stephane Lo Presti and Phillip
                Turner},
  title      = {The Use of Formal Methods in the Analysis of Trust (Position Paper)},
  abstract   = {Security and trust are two properties of modern computing systems that
    are thefocus of much recent interest. They play an increasingly
    significant role in the requirements for modern computing systems.
    Security has been studied thoroughly for many years, particularly the
    sub-domain of cryptography. The use of computing science formal
    methods has facilitated cryptanalysis of security protocols. At the
    moment, trust is intensively studied, but not well understood. Here we
    present our approach based on formal methods for modelling and
    validating the notion of trust in computing science.},
  editor     = {Christian Jensen and Stefan Poslad and Theo Dimitrakos},
  booktitle  = {iTrust},
  publisher  = {Springer-Verlag},
  series     = {Lecture Notes in Computer Science},
  volume     = {2995},
  isbn       = {3-540-21312-0},
  pages      = {333--339},
  year       = {2004},
}
@inproceedings{CrGaLeHe04_15,
  author     = {Stephen Craig and John Gallagher and Michael Leuschel and Kim S.
                Henriksen},
  title      = {Fully Automatic Binding Time Analysis for {Prolog}},
  booktitle  = {LOPSTR},
  abstract   = {Offline partial evaluation techniques rely on an annotated version of
    the source program to control the specialisation process.  These
    annotations guide the specialisation and have to ensure termination of
    the partial evaluation.
    We present an algorithm for generating these annotations
    automatically.
    The algorithm uses state-of-the-art termination analysis techniques,
    combined with a new type-based abstract interpretation for propagating
    the binding types.
    This algorithm has been implemented as part of the Logen partial
    evaluation system, and we report on performance of the algorithm on a
    series of benchmarks.},
  editor     = {Sandro Etalle},
  publisher  = {Springer-Verlag},
  series     = {Lecture Notes in Computer Science},
  volume     = {3573},
  ISBN       = {3-540-26655-0},
  pages      = {53--68},
  year       = {2004},
  stupsfile  = {http://www.stups.uni-duesseldorf.de/publications/bta_lopstr_final.pdf},
}
@inproceedings{CrLe04_16,
  author     = {Stephen Craig and Michael Leuschel},
  title      = {{Lix}: An Effective Self-applicable Partial Evaluator for {Prolog}},
  booktitle  = {FLOPS},
  abstract   = {This paper presents a self-applicable partial evaluator for a
    considerable subset of full Prolog.
    The partial evaluator is shown to achieve non-trivial specialisation
    and be effectively self-applied.
    The attempts to self-apply partial evaluators for logic programs have,
    of yet, not been all that successful.
    Compared to earlier attempts, our LIX
    system is practically usable in terms
    of efficiency and can handle natural
    logic programming examples with partially static data structures,
    built-ins, side-effects, and some higher-order and meta-level features
    such as  call and   findall.<br/>
    The LIX system is derived from the development of the LOGEN
    compiler generator system. It achieves a similar kind of efficiency
    and
    specialisation, but can be used for other applications.
    Notably, we show first attempts at using the system for
    deforestation and tupling in an offline fashion.
    We will demonstrate that, contrary to earlier beliefs,
    declarativeness and
    the use of the ground representation is not the best way to achieve
    self-applicable partial evaluators.},
  editor     = {Yukiyoshi Kameyama and Peter J. Stuckey},
  publisher  = {Springer-Verlag},
  pages      = {85--99},
  year       = {2004},
  stupsfile  = {http://www.stups.uni-duesseldorf.de/publications/lix.pdf},
}
@article{Le04_17,
  author     = {Michael Leuschel},
  title      = {A Framework for the Integration of Partial Evaluation and Abstract
                Interpretation of Logic Programs},
  abstract   = {Recently the relationship between abstract interpretation and program
    specialization
    has received a lot of scrutiny, and the need has been identified
    to extend program specialization techniques so to make use of
    more refined abstract domains and operators.
    This paper clarifies this relationship in the context of logic programming,
    by expressing program specialization in terms of abstract interpretation.
    Based on this, a novel specialization framework,
    along with generic correctness results for computed answers and finite
    failure under SLD-resolution, is developed.<br/>

    This framework can be used to extend existing logic program
    specialization methods, such as partial deduction and conjunctive partial
    deduction, to make use of more refined abstract domains.
    It is also shown how this opens up the way for new optimizations.
    Finally, as shown in the paper,
    the framework also enables one to prove correctness of new or existing
    specialization techniques in a simpler manner.<br/>
    The framework has already been applied in the literature to develop
    and prove
    correct specialization algorithms using regular types, which in turn
    have been
    applied to the verification of infinite state process algebras.},
  journal    = {ACM Transactions on Programming Languages and Systems (TOPLAS)},
  volume     = {26},
  number     = {3},
  publisher  = {ACM},
  month      = {May},
  pages      = {413--463},
  year       = {2004},
  stupsfile  = {http://www.stups.uni-duesseldorf.de/publications/apd-toplas_final.pdf},
}
@inproceedings{Le04_18,
  author     = {Michael Leuschel},
  title      = {{ProB}: Un outil de mod{\'e}lisation formelle (Invited Talk)},
  abstract   = {The development of formal models is often a key step when developing
    safety or mission critical software.
    In this setting it is vital to formally check and validate these
    formal models before
    translating them into code.
    I will present ProB, a toolset for the B
    method which was developed using constraint logic programming
    technology.
    ProB allows fully automatic animation of B models, and can be used to
    systematically check a B
    model for errors.
    ProB supports B features such as non-deterministic operations,
    ANY statements, operations with complex arguments, sets, sequences,
    functions, lambda abstractions, set comprehensions, constants and
    properties, and many more.
    ProB's animation facilities allow users to gain confidence in
    their specifications, and unlike other animators,
    the user does not have to guess the right values for the
    operation arguments or choice variables.
    This is achieved by using co-routining and finite domain constraint
    solving.
    On top of the animation features,
    ProB contains a temporal model checker
    and a constraint-based model checker, both of which can  be used to
    detect various
    errors in B specifications.},
  booktitle  = {JFPLC},
  editor     = {Fred Mesnard},
  publisher  = {Hermes Science Publications, Lavoisier},
  ISBN       = {2-7462-0937-3},
  pages      = {13--13},
  year       = {2004},
  stupsfile  = {http://www.stups.uni-duesseldorf.de/publications/i1-Leuschen.pdf},
}
@inproceedings{LeCrBrVa04_19,
  author     = {Michael Leuschel and Stephen Craig and Maurice Bruynooghe and Wim
                Vanhoof},
  title      = {Specializing Interpreters using Offline Partial Deduction},
  booktitle  = {Program Development in Computational Logic},
  abstract   = {We present the latest version of the Logen partial evaluation system
    for logic programs. In particular we present new binding-types, and
    show how they can be used to effectively specialise a wide variety of
    interpreters.We show how to achieve Jones-optimality in a systematic
    way  for several interpreters. Finally, we present and specialise a
    non-trivial interpreter for a small functional programming language.
    Experimental results are also presented, highlighting that the Logen
    system can be a good basis for generating compilers for high-level
    languages.},
  editor     = {Maurice Bruynooghe and Kung-Kiu Lau},
  publisher  = {Springer-Verlag},
  series     = {Lecture Notes in Computer Science},
  volume     = {3049},
  month      = {November},
  pages      = {341--376},
  year       = {2004},
  stupsfile  = {http://www.stups.uni-duesseldorf.de/publications/leuschel.pdf},
}
@article{LeJoVaBr04_20,
  author     = {Michael Leuschel and Jesper J{\o}rgensen and Wim Vanhoof and Maurice
                Bruynooghe},
  title      = {Offline Specialisation in {Prolog} Using a Hand-Written Compiler
                Generator},
  abstract   = {The so called "cogen" approach'' to program
    specialisation, writing a compiler generator instead of a
    specialiser, has been used with considerable success in partial
    evaluation of both functional and imperative languages.  This paper
    demonstrates that the "cogen" approach is also applicable
    to the specialisation of logic programs (called partial deduction
    when applied to pure logic programs) and leads to effective
    specialisers. Moreover, using good binding-time annotations,
    the speed-ups of the specialised programs are comparable to the speed-ups
    obtained with online specialisers.<br/>

    The paper first develops a generic approach to offline partial
    deduction and then a specific offline partial deduction method,
    leading to the offline system LIX for pure logic programs.
    While this is a usable specialiser by itself, its specialisation
    strategy is used to develop the "cogen" system LOGEN.
    Given a program, a specification of what inputs will be static, and
    an annotation specifying which calls should be unfolded, LOGEN
    generates a specialised specialiser for the program at hand. Running
    this specialiser with particular values for the static inputs
    results in the specialised program. While this requires two steps
    instead of one, the efficiency of the specialisation process is
    improved in situations where the same program is specialised
    multiple times.<br/>

    The paper also presents and evaluates an automatic binding-time
    analysis  that is able to derive the annotations. While the derived
    annotations are still suboptimal compared to hand-crafted ones,
    they enable non-expert users to use the LOGEN system
    in a fully automated way.<br/>

    Finally, LOGEN is extended so as to directly support a large
    part of Prolog's declarative and non-declarative features and so as
    to be able to perform so called mixline specialisations.
    In mixline specialisation some unfolding decisions depend on the
    outcome of tests performed at specialisation time instead of being
    hardwired into the specialiser.},
  journal    = {TPLP},
  volume     = {4},
  number     = {1--2},
  publisher  = {Cambridge University Press},
  pages      = {139--191},
  year       = {2004},
  stupsfile  = {http://www.stups.uni-duesseldorf.de/publications/cogen-journal4b.pdf},
}
@techreport{LeTu04_21,
  author     = {Michael Leuschel and Edd Turner},
  title      = {Visualising Larger State Spaces in {ProB}},
  abstract   = {ProB is an animator and model checker for the B method.
    It also allows to visualise the state space of a B machine in
    graphical way.
    This is often very useful and allows users to quickly spot whether the
    machine behaves as expected.
    However, for larger state spaces the visualisation quickly becomes
    difficult to
    grasp by users (and the computation of the graph layout takes
    considerable time).
    In this paper we present two relatively simple algorithms to often
    considerably reduce the
    complexity of the graphs, while still keeping relevant information.
    This makes it possible to visualise much larger state spaces and gives
    the user immediate feedback about the overall behaviour of a machine.
    The algorithms have been implemented within the ProB toolset and we
    highlight their potential on several examples.
    We also conduct a thorough experimentation of the algorithm on 47 B
    machines and analyse the results.},
  month      = {November},
  institution = {ECS, University of Southampton},
  year       = {2004},
  stupsfile  = {http://www.stups.uni-duesseldorf.de/publications/prob_visualise.pdf},
  dbslinks   = {[http://eprints.ecs.soton.ac.uk/10105|Website University of Southampton]},
}
@techreport{LoBuLeSnTu04_22,
  author     = {Stephane Lo Presti and Michael Butler and Michael Leuschel and Colin
                Snook and Phillip Turner},
  title      = {Formal Modelling and Verification of Trust in a Pervasive Application},
  abstract   = {This report is deliverable WP4-01 of the project ??Trusted Software
    Agents and Services for Pervasive Information Environments.? The
    deliverable reports on the activities of formal modelling and
    verification of a pervasive application which follows from previous
    results in the project.<br/>

    The pervasive application is based on several pervasive scenarios
    already devised and is centred on the user location. This
    location-based system is first architecturally simplified, while trust
    requirements are derived from the Trust Analysis Framework presented
    in the deliverable WP2-01.<br/>

    This first abstraction is then completed by formal modelling of the
    system in the B formal method. These models enable us to clarify the
    decision decisions leading to fulfil the trust requirements. We show
    that the system policy structure is influenced by the priorities given
    to the system operations and that a sufficiently high level of
    abstraction is required to model trust properties.<br/>

    The modelling activity is completed by formal verification using the
    ProB model-checker to automate part of this process. Several models
    are checked successfully, while detection of errors in other models
    enables us to understand better the behaviour of the system. In
    particular, issues relative to the dynamicity of modelled elements are
    highlighted.<br/>

    The overall methodology followed during these activities proved useful
    at helping us specifying accurately the trust requirements, so that
    the pervasive application can be completed in consequence, and is as
    follows:<br/>
    1) Model important features of the system First vaguely type the
    variables; then write a set of operations corresponding to
    complementary features while (possibly) modifying the variable types
    to ease this writing; consider the variables by group of similar
    dynamic properties;<br/>
    2a) Model-check the model<br/>
    2a.a) Property violation detected Examine the various aspects of the
    model (variables, enabled operations, history of operations) to see
    what part of the property is ??false?; Correct the model
    accordingly;<br/>
    2a.b) No property violation detected Go back to 2a until coverage rate
    is enough; possible changes to the model include: modify the
    initialisation to test other situations (in B use ??choice by
    predicate?); add inconsistencies in the model;<br/>
    2b) Animate the model<br/>
    2b.a) Execute the desired sequence of operations (validation);<br/>
    2b.b) Find an interesting state, then 2a.a or 2a.b applies;<br/>
    2b.c) Backtrack from a state where the invariant is violated;<br/>
    3) Go back to 1 (complete the model) or refine the model.},
  month      = {June},
  year       = {2004},
  institution = {DSSE, University of Southampton},
  stupsfile  = {http://www.stups.uni-duesseldorf.de/publications/TSAS_-_WP4-01_v1.pdf},
}
@inproceedings{VaBrLe04_23,
  author     = {Wim Vanhoof and Maurice Bruynooghe and Michael Leuschel},
  title      = {Binding-Time Analysis for {Mercury}},
  booktitle  = {Program Development in Computational Logic},
  editor     = {Maurice Bruynooghe and Kung-Kiu Lau},
  publisher  = {Springer-Verlag},
  series     = {Lecture Notes in Computer Science},
  volume     = {3049},
  pages      = {189--232},
  isbn       = {3-540-22152-2},
  year       = {2004},
  stupsfile  = {http://www.stups.uni-duesseldorf.de/publications/vanhoof.pdf},
}
@inproceedings{FaLe04_29,
  author     = {Berndt Farwer and Michael Leuschel},
  title      = {Model Checking of {Object Petri Nets} in {Prolog}},
  abstract   = {Object Petri nets (OPNs) provide a natural and modular method for the
    modelling of many real-world systems.
    We give a structure-preserving translation of OPNs to Prolog, avoiding
    the need for an unfolding to a flat Petri net. The translation
    provides support for reference and value semantics, and even allows
    different objects to be treated as copyable or non-copyable,
    respectively.  The method is developed for OPNs with arbitrary
    nesting. <br/>
    We then apply logic programming tools to animate, compile and model
    check OPNs. In particular, we use the partial evaluation system LOGEN
    to produce an OPN compiler, and we use the model checker XTL to verify
    CTL formulas. We also use LOGEN to produce special purpose model
    checkers. <br/>
    We present two case studies, along with experimental results. A
    comparison to OPN translations to MAUDE specifications and model
    checking is given, showing that our approach is roughly twice as fast
    for larger systems.  We also tackle infinite state model checking
    using the ECCE system.},
  booktitle  = {PPDP},
  publisher  = {ACM Press},
  month      = {November},
  pages      = {20--31},
  editor     = {Eugenio Moggi and David Scott Warren},
  isbn       = {1-58113-819-9},
  year       = {2004},
  stupsfile  = {http://www.stups.uni-duesseldorf.de/publications/PPDP04_opn2xtl.pdf},
}

@article{CaHaZi04_275,
  author     = {Dominique Cansell and Stefan Hallerstede and Yann Zimmermann},
  title      = {Construction sûre de systèmes électroniques},
  journal    = {Génie Logiciel},
  number     = {67},
  abstract   = {Le développement de systèmes à l'aide du raffinement est une méthode
    formelle qui permet de gérer la complexité d'un système et de sa
    preuve de correction en permettant l'introduction des détails du
    système pas à pas. A partir d'un système abstrait, chaque pas de
    raffinement est prouvé correct jusqu'au niveau d'implantation. La
    méthode B est basée sur le raffinement, mais elle aide aussi à gérer
    les obligations de preuve qui se présentent à chaque pas. La méthode B
    est l'une des méthodes qui possdent le plus d'outils support pour
    être utilisée en pratique.
    Les systèmes électroniques deviennent de plus en plus complexes,
    l'approche traditionnelle qui consiste à garantir la correction par la
    simulation ne suffit plus. Par ailleurs, les systèmes électroniques
    sont de plus en plus présents dans les systmes de toute nature et
    l'exigence en qualité est de plus en plus forte. Les méthodes
    formelles sont les seules à pouvoir faire face à cette complexité
    croissante. Nous présentons dans cet article comment la méthode B peut
    être utilisée pour la conception des systèmes électroniques.},
  month      = {Juin},
  pages      = {38--44},
  year       = {2004},
}
@article{VoSnHaMa04_274,
  author     = {Nikolaos S. Voros and Colin Snook and Stefan Hallerstede and
                Konstantinos Masselos},
  title      = {Embedded System Design Using Formal Model Refinement: An Approach
                Based on the Combined Use of UML and the B Language},
  journal    = {Design Automation for Embedded Systems},
  volume     = {9},
  number     = {2},
  abstract   = {The approach proposed in this paper introduces a hardware/software
    co-design framework for developing complex embedded systems. The
    method relies on formal proof of system properties at every phase of
    the co-design cycle. The key concept is the combined use of UML and
    the B language for system modeling and design, and the seamless
    transition from UML specifications to system descriptions in B. The
    final system prototype emerges from correct-by-construction subsystems
    described in the B language; the hardware components are translated in
    VHDL/SystemC, while for the software components C/C++ is used. The
    outcome is a formally proven correct system implementation. The
    efficiency of the proposed method is exhibited through the design of a
    case study from the telecommunication domain.},
  publisher  = {Springer-Verlag},
  pages      = {67--99},
  year       = {2004},
  dbslinks = {[http://www.springerlink.com/content/q442635g78m04887/|PDF]},
}
@article{HaBu04_263,
  author     = {Stefan Hallerstede and Michael Butler},
  title      = {Performance analysis of probabilistic action systems},
  journal    = {Formal Aspects of Computing},
  volume     = {16},
  number     = {4},
  abstract   = {Formal notations like B or action systems support a notion of
    refinement.
    Refinement relates an abstract specification AA to a more
    deterministic
    concrete specification CC. Knowing AA and CC one proves CC refines, or

    implements, specification AA. In this study we consider specification
    AA as
    given and concern ourselves with a way to find a good candidate for
    implementation CC. To this end we classify all implementations of an
    abstract specification according to their performance. We distinguish
    performance from correctness. Concrete systems that do not meet the
    abstract
    specification correctly are excluded. Only the remaining correct
    implementations CC are considered with respect to their performance. A
    good
    implementation of a specification is identified by having some optimal

    behaviour in common with it. In other words, a good refinement
    corresponds
    to a reduction of non-optimal behaviour. This also means that the
    abstract
    specification sets a boundary for the performance of any
    implementation.

    We introduce the probabilistic action system formalism which combines
    refinement with performance. In our current study we measure
    performance in
    terms of long-run expected average-cost. Performance is expressed by
    means
    of probability and expected costs. Probability is needed to express
    uncertainty present in physical environments. Expected costs express
    physical or abstract quantities that describe a system. They encode
    the
    performance objective. The behaviour of probabilistic action systems
    is
    described by traces of expected costs. A corresponding notion of
    refinement
    and simulation-based proof rules are introduced. Probabilistic action
    systems are based on discrete-time Markov decision processes.
    Numerical
    methods solving the optimisation problems posed by Markov decision
    processes
    are well-known, and used in a software tool that we have developed.
    The tool
    computes an optimal behaviour of a specification AA thus assisting in
    the
    search for a good implementation CC.},
  publisher  = {Springer-Verlag},
  pages      = {313--331},
  year       = {2004},
  dbslinks = {[http://eprints.ecs.soton.ac.uk/8925/|PDF]},
}
@inproceedings{HaZi04_287,
  author     = {Stefan Hallerstede and Yann Zimmermann},
  title      = {Circuit Design by Refinement in Event-B},
  booktitle  = {Proceedings of the Forum on Specification and Design Languages
                (FDL'04)},
  abstract   = {We present the design of a parallel synchronous hardware component
    from a purely
    functional description of its behaviour. Starting from an abstract
    specification of a
    linear time-invariant (LTI) system in Event-B a pipelined
    implementation is developed.
    The presented approach is applicable to LTI systems that can be
    represented as
    linear constant-coefficient difference equations.
    Scheduling and allocation can be conveniently expressed in the Event-B
    formalism.
    },
  year       = {2004},
}
@incollection{VoSnHaLe04_294,
  author     = {Nikolaos S. Voros and Colin Snook and Stefan Hallerstede and Thierry
                Lecomte},
  title      = {Embedded System Design Using the PUSSEE Method},
  booktitle    = {UML-B Specification for Proven Embedded Systems Design},
  abstract   = {The approach presented in this book relies on the unification of
    system specification environments for developing electronic systems
    that are formally proven to be correct (correct-by-construction
    systems). The key concept conveyed is the formal proof of system
    properties, which is carried out at every phase of the co-design
    cycle. The main idea is to build fully functional system models that
    are formally proven to be correct, and based on them to produce
    automatically the hardware and the software parts of the system. The
    approach presented relies on the combined use of UML and B language.},
  editor     = {J. Mermet},
  publisher  = {Kluwer},
  pages      = {37--52},
  year       = {2004},
  dbslinks = {[http://www.springer.com/engineering/electronics/book/978-1-4020-2866-3|Book]},
}
@incollection{Ha04_295,
  author     = {Stefan Hallerstede},
  title      = {BHDL},
  booktitle    = {UML-B Specification for Proven Embedded Systems Design},
  chapter = 7,
  abstract   = {In this chapter we discuss modeling of hardware and translation to
    VHDL. Translation to SystemC or Verilog is similar. However VHDL is
    easier to read and we use VHDL synthesis tools. Translation is
    important to provide a complete path from formal models to a circuit.
    Equally important we need a refinement method to arrive at a formal
    circuit description that can be translated. This method has some
    significant differences to the refinement method for software. As one
    would expect, they are virtually not present at system level but
    become more and more visible as an actual implementation is
    approached. This means that the initial refinement steps used in
    hardware are, in principle, also applicable to software, and vice
    versa.
    The subset of the B-language that serves to describe hardware is
    called BHDL. The definition of the BHDL subset is oriented at the
    register transfer level for hardware description.
    },
  editor     = {J. Mermet },
  publisher  = {Kluwer},
  pages      = {109--120},
  year       = {2004},
  dbslinks = {[http://www.springer.com/engineering/electronics/book/978-1-4020-2866-3|Book]},
}
@incollection{ZiHaCa04_296,
  author     = {Yann Zimmermann and Stefan Hallerstede and Dominique Cansell},
  title      = {Formal Modelling of Electronic Circuits Using Event-B, Case Study: SAE
                J1708 Serial Communication Link},
  booktitle    = {UML-B Specification for Proven Embedded Systems Design},
  abstract   = {This chapter presents a study of the SAE J1708 Serial Communication
    link. The study is carried out in Event-B, an extension of the B
    method. The system is implemented and decomposed using step-wise
    refinement. We present how to derive with this method a cycle-accurate
    hardware model. The model of the communication link system is composed
    of an arbitrary finite number of identical components that run
    concurrently. The model contains synchronisation of these components
    required to control access to the communication link. At the end of
    the refinement we obtain an implementable model of the components
    which is translated into VHDL. The generated VHDL design is
    synthesizable, meaning that the implementable B model is synthesizable
    as well.},
  editor     = {J. Mermet },
  publisher  = {Kluwer},
  pages      = {211--226},
  year       = {2004},
  dbslinks = {[http://www.springer.com/engineering/electronics/book/978-1-4020-2866-3|Book]},
}
@incollection{CaHaOl04_297,
  author     = {Dominique Cansell and Stefan Hallerstede and Ian Oliver},
  title      = {UML-B Specification and Hardware Implementation of a Hamming
                Coder/Decoder},
  booktitle    = {UML-B Specification for Proven Embedded Systems Design},
  abstract   = {Formal refinement as offered by the B method has been shown to be
    applicable in practice and to scale up. However, it has been
    recognised that it is difficult communicate a formal B model with
    customers. Recently, the UML has been investigated as an interface to
    rigorous formal B models to facilitate this communication. The UML is
    generally accepted as being a good vehicle for communicating models of
    systems. Availability of this interface to the B method addresses a
    major problem faced by most formal methods: How to validate a formal
    model with a customer who is not formal methods expert? In this
    chapter we present an approach to the development of a formally
    verified circuit implementing a Hamming encoder/decoder. The UML-B is
    used as a formal specification language and the B method is used to
    prove refinements until the implementation level at which we can
    translate into VHDL.},
  editor     = {J. Mermet },
  publisher  = {Kluwer},
  pages      = {261--278},
  year       = {2004},
  dbslinks = {[http://www.springer.com/engineering/electronics/book/978-1-4020-2866-3|Book]},
}



@inproceedings{LeBu05_1,
  author     = {Michael Leuschel and Michael Butler},
  title      = {Combining {CSP} and {B} for Specification and Property Verification},
  booktitle  = {FM'2005},
  editor     = {John Fitzgerald and Ian Hayes and Andrzej Tarlecki},
  publisher  = {Springer-Verlag},
  series     = {Lecture Notes in Computer Science},
  volume     = {3582},
  month      = {January},
  ISSN       = {0302-9743},
  pages      = {221--236},
  year       = {2005},
  stupsfile  = {http://www.stups.uni-duesseldorf.de/publications/csp_prob-2.pdf},
  stupskeywords={prob},
}
@inproceedings{BuLeSn05_2,
  author     = {Michael Butler and Michael Leuschel and Colin Snook},
  title      = {Tools for system validation with {B} abstract machines},
  booktitle  = {12th International Workshop on Abstract State Machines},
  abstract   = {In this paper we give an overview of some tools that we have
    developed to support the application of the B Method. ProB  is an
    animation and model checking tool for the B method. ProB's
    animation facilities allow users to gain confidence in their
    specifications. ProB contains a temporal and a state-based model
    checker, both of which can  be used to detect various errors in B
    specifications. We also overview a recent extension of ProB that
    supports checking of specifications written in a combination of
    CSP and B. Finally we describe the UML-B profile and associated
    U2B tool that allows UML and B to be combined and is intended to
    make modelling with B more appealing to software engineers.
    },
  month      = {March},
  pages      = {57--69},
  year       = {2005},
  stupsfile  = {http://www.stups.uni-duesseldorf.de/publications/mjb.pdf},
}
@article{Le05_4,
  author     = {Michael Leuschel},
  title      = {Guest Editorial -- Special Issue on Automated Verification of Critical
                Systems},
  journal    = {Formal Aspects of Computing},
  volume     = {17},
  number     = {2},
  publisher  = {Springer-Verlag},
  month      = {August},
  pages      = {91-92},
  year       = {2005},
}
@inproceedings{LeBu05_5,
  author     = {Michael Leuschel and Michael Butler},
  title      = {Automatic Refinement Checking for {B}},
  booktitle  = {Proceedings ICFEM},
  editor     = {Kung-Kiu Lau and Richard Banach},
  publisher  = {Springer-Verlag},
  month      = {May},
  series     = {Lecture Notes in Computer Science},
  volume     = {3785},
  pages      = {345--359},
  year       = {2005},
  stupsfile  = {http://www.stups.uni-duesseldorf.de/publications/refchecker.pdf},
  stupskeywords={prob},
}
@inproceedings{LeCr05_7,
  author     = {Michael Leuschel and Stephen Craig},
  title      = {A Reconstruction of the {Lloyd-Topor} Transformation using
                Partial Evaluation},
  booktitle  = {Pre-Proceedings of LOPSTR'05},
  abstract   = {The Lloyd-Topor transformation is a classical transformation that
    translates extended logic programs with logical connectives and
    explicit quantifiers  into normal logic programs.
    In this paper we show that this translation can be achieved in a
    natural way by specialising a meta-interpreter for extended logic
    programs.
    For this we use the Logen partial evaluation system, extended to
    handle coroutining.},
  editor     = {Pat Hill},
  year       = {2005},
  month      = {September},
  stupsfile  = {http://www.stups.uni-duesseldorf.de/publications/prelopstr_lloyd_topor.pdf},
}
@inproceedings{LeTu05_8,
  author     = {Michael Leuschel and Edd Turner},
  title      = {Visualising Larger State Spaces in {ProB}},
  booktitle  = {ZB},
  abstract   = {ProB is an animator and model checker for the B method.
    It also allows to visualise the state space of a B machine in
    graphical way.
    This is often very useful and allows users to quickly spot whether the
    machine
    behaves as expected.
    However, for larger state spaces the visualisation quickly becomes
    difficult to
    grasp by users (and the computation of the graph layout takes
    considerable time).
    In this paper we present two relatively simple algorithms to often
    considerably reduce the
    complexity of the graphs, while still keeping relevant information.
    This makes it possible to visualise much larger state spaces and gives
    the user
    immediate feedback about the overall behaviour of a machine.
    The algorithms have been implemented within the ProB toolset and we
    highlight their potential on several examples.
    We also conduct a thorough experimentation of the algorithm on 47 B
    machines
    and analyse the results.},
  editor     = {Helen Treharne and Steve King and Martin Henson and Steve Schneider},
  publisher  = {Springer-Verlag},
  month      = {November},
  pages      = {6--23},
  series     = {Lecture Notes in Computer Science},
  volume     = {3455},
  isbn       = {3-540-25559-1},
  year       = {2005},
  stupsfile  = {http://www.stups.uni-duesseldorf.de/publications/prob_visualise.pdf},
}
@inproceedings{LeVi05_9,
  author     = {Michael Leuschel and Germ{\'a}n Vidal},
  title      = {Forward Slicing by Conjunctive Partial Deduction and Argument
                Filtering},
  abstract   = {Program slicing is a well-known methodology that aims at identifying
    the program statements that (potentially) affect the values computed
    at some point of interest. Within
    imperative programming, this technique has been successfully applied
    to debugging, specialization, merging, reuse, maintenance, etc. Due
    to its declarative nature, adapting the slicing notions and
    techniques to a logic programming setting is not an easy task. In
    this work, we define the first, semantics-preserving, forward
    slicing technique for logic programs. Our approach relies on the
    application of a conjunctive partial deduction algorithm for a precise
    propagation of information between calls. <br/>
    We do not
    distinguish between static and dynamic slicing since partial
    deduction can naturally deal with both static and dynamic data.
    Furthermore, this approach can quite easily
    be implemented by
    adding a new code generator on top of existing partial
    deduction systems. A slicing tool has been implemented in
    ECCE, where a post-processing transformation to remove redundant
    arguments has been added.  Experiments conducted on a wide variety
    of programs are encouraging and demonstrate the usefulness of our
    approach, both as a classical slicing method and as a technique
    for code size reduction.},
  editor     = {Mooly Sagiv},
  booktitle  = {ESOP},
  year       = {2005},
  pages      = {61--76},
  series     = {Lecture Notes in Computer Science},
  volume     = {3444},
  publisher  = {Springer-Verlag},
  ISBN       = {3-540-25435-8},
  year       = {2005},
  stupsfile  = {http://www.stups.uni-duesseldorf.de/publications/slicing_esop05_final2.pdf},
}
@inproceedings{LoBuLeBo05_10,
  author     = {Stephane Lo Presti and Michael Butler and Michael Leuschel and Chris
                Booth},
  title      = {A Trust Analysis Methodology for Pervasive Computing Systems},
  booktitle  = {Trusting Agents for trusting Electronic Societies},
  abstract   = {We present an analysis Trust Analysis Methodology for finding trust
    issues within pervasive computing systems. It is based on a systematic
    analysis of scenarios that describe the typical use of the pervasive
    system by using a Trust Analysis Grid. The Trust Analysis Grid is
    composed of eleven Trust Issue Categories that cover the various
    aspects of the concept of trust in pervasive computing systems. The
    Trust Analysis Grid is then used to guide the design of the pervasive
    computing system.},
  editor     = {R Falcone and S Barber and J Sabater and M Singh},
  publisher  = {Springer-Verlag},
  series     = {Lecture Notes in Computer Science},
  volume     = {3577},
  isbn       = {978-3-540-28012-5},
  year       = {2005},
  stupsfile  = {http://www.stups.uni-duesseldorf.de/publications/LBLB-lnai05.pdf},
}
@article{SaLeBu05_11,
  author     = {Manoranjan Satpathy and Michael Leuschel and Michael Butler},
  title      = {{ProTest}: An Automatic Test Environment for {B}  Specifications},
  journal    = {Electronic Notes in Theroretical Computer Science},
  volume     = {111},
  abstract   = {We present ProTest, an automatic test environment for B
    specifications. B is a model-oriented notation where systems are
    specified in terms of  abstract states and operations on abstract
    states. ProTest first generates a state coverage graph of a B
    specification through exhaustive model checking, and the coverage
    graph is traversed to generate a set of test cases, each being a
    sequence of B operations. For the model checking to be exhaustive,
    some transformations are applied to the sets used in the B machine.
    The approach also works if it is not exhaustive; one can stop at any
    point in time during the state space exploration and generate test
    cases
    from the coverage graph obtained so far. ProTest then simultaneously
    performs animation of the B machine and
    the execution of the corresponding implementation in Java, and assign
    verdicts on the test results. With some restrictions imposed on the B
    operations, the whole of the testing process is performed
    mechanically. We  demonstrate the efficacy of our test environment by
    performing a small case study from industry. Furthermore,
    we present a solution to the problem of handling non-determinism in B
    operations.},
  editor     = {Yuri Gurevich and Alexander K. Petrenko and Alexander Kossatchev},
  publisher  = {Elsevier},
  month      = {January},
  ISSN       = {1571-0661},
  pages      = {113--136},
  year       = {2005},
  stupsfile  = {http://www.stups.uni-duesseldorf.de/publications/test-nov30.pdf},
}
@inproceedings{WaGuLe05_12,
  author     = {Qian Wang and Gopal Gupta and Michael Leuschel},
  title      = {Towards Provably Correct Code Generation via Horn Logical Continuation
                Semantics},
  booktitle  = {PADL},
  abstract   = {Provably correct compilation is an important aspect
    in development of high assurance software systems.
    In this paper we explore approaches to provably correct
    code generation based on programming
    language semantics, particularly Horn logical semantics,
    and partial evaluation. We show that the definite clause
    grammar (DCG) notation can be used for specifying both the
    syntax and semantics of imperative languages.
    We next show that continuation semantics can also be
    expressed in the Horn logical framework. },
  editor     = {Manuel Hermengildo and Daniel Cabeza},
  publisher  = {Springer-Verlag},
  series     = {Lecture Notes in Computer Science},
  volume     = {3350},
  isbn       = {3-540-24362-3},
  pages      = {98--112},
  year       = {2005},
  stupsfile  = {http://www.stups.uni-duesseldorf.de/publications/padl05fv3.pdf},
}
@inproceedings{CrLe05_222,
  author     = {Stephen Craig and Michael Leuschel},
  title      = {Self-Tuning Resource Aware Specialisation for {Prolog}},
  booktitle  = {Proceedings PPDP'2005},
  abstract   = {The paper develops a self-tuning resource aware partial evaluation
    technique for Prolog programs, which derives its own control
    strategies tuned for the underlying computer architecture and Prolog
    compiler using a genetic algorithm approach.
    The algorithm is based on mutating the annotations of offline partial
    evaluation.<br/>
    Using a set of representative sample queries it decides upon the
    fitness of annotations, controlling the trade-off between code
    explosion, speedup gained and specialisation time.  The user can
    specify the importance of each of these factors in determining the
    quality of the produced code, tailoring the specialisation to the
    particular problem at hand. <br/>
    We present experimental results for our implemented technique on a
    series of benchmarks.  The results are compared against the aggressive
    termination based binding-time analysis and optimised using different
    measures for the quality of code. We also show that our technique
    avoids some classical pitfalls of partial evaluation.},
  publisher  = {ACM Press},
  pages      = {23--34},
  year       = {2005},
  stupsfile  = {http://www.stups.uni-duesseldorf.de/publications/ppdp05_final.pdf},
}
@techreport{Ha05_298,
  author     = {Stefan Hallerstede},
  title      = {The Event-B Proof Obligation Generator},
  institution = {Information Security, ETH Zürich},
  abstract   = {This text describes a proof obligation generator for EventB. Most of
    the document describes
    the actual generated proof obligations and justification of their
    correctness. The algorithm
    for their generation is very simple.
    We distinguish generated proof obligations from theoretical ones.
    Theoretical proof obligations
    are well-suited for hand-written mathematical proofs but less suited
    for machine-assisted
    proof. In particular, generated proof obligations have be obtained by
    decomposing theoretical
    proof obligations as far as possible so that they are as simple as
    possible; and hopefully
    provable by an automatic prover. Substitutions produced by the proof
    obligation generator
    are left unevaluated. These are applied in a preprocessing step of the
    proof manager. The
    reason for this is to keep the design of the proof obligation
    generator distinct from the actual
    provers. By using witnesses in models a part of the proof has been
    moved into modelling
    itself. The price to pay is that one has to think about proving while
    modelling. The advantage
    is that proofs are decomposed and almost all existential quantifiers
    are removed from
    the consequents of proof obligations.
    There are three main sections on contexts, initial models, and refined
    models. Each of
    these contains three subsections: the description subsection
    introduces the notation used in
    the section; the theory subsection presents the theoretical proof
    obligations and derives the
    generated proof obligations by proof; the generated proof obligations
    subsection contains the
    list of proof obligations to be generated by the proof obligation
    generator. This last section
    also contains proof obligations for well-definedness. On first reading
    well-definedness proof
    obligations should be ignored. These are necessary but are actually
    not derived from the
    theoretical proof obligations.},
  year       = {2005},
  stupsfile  = {http://www.stups.uni-duesseldorf.de/publications/pog-spec-06.pdf},
}
@article{HaVo05_299,
  author     = {Stefan Hallerstede and Laurent Voisin},
  title      = {The Event-B Static Checker},
  journal    = {Rodin Deliverable D10},
  abstract   = {All modelling items used in a formal B development are kept in the
    database kernel-component. This database is analysed by the static
    checker with respect to various properties the collection of modelling
    items must satisfy. When the static checker has accepted the database
    as being consistent, its items can be submitted to proof obligation
    generation and subsequent proof. In addition to marking modelling
    items as consistent the static checker computes auxiliary data
    structures to improve performance of all tasks that involve using
    items stored in the database.},
  year       = {2005},
}



@inproceedings{LeElVaCrFo06_140,
  author     = {Michael Leuschel and Daniel Elphick and Mauricio Varea and Stephen
                Craig and Marc Fontaine},
  title      = {The {Ecce} and {Logen} Partial Evaluators and their Web Interfaces},
  booktitle  = {Proceedings PEPM 06},
  abstract   = {We present Ecce and Logen, two partial evaluators for Prolog using the
    online and offline approach respectively.
    We briefly present the foundations of these tools and  discuss various
    applications.
    We also present
    new implementations of these tools, carried out in Ciao Prolog.
    In addition to a command-line interface
    new user-friendly web interfaces were developed.
    These enable non-expert users to specialise logic programs using a web
    browser,
    without the need for a local installation.},
  editor     = {John Hatcliff and Frank Tip},
  publisher  = {IBM Press},
  month      = {Januar},
  pages      = {88--94},
  year       = {2006},
  stupsfile  = {http://www.stups.uni-duesseldorf.de/publications/ecce_logen_tool.pdf},
}
@inproceedings{LeCrEl06_199,
  author     = {Michael Leuschel and Stephen Craig and Daniel Elphick},
  title      = {Supervising Offline Partial Evaluation of Logic Programs using Online
                Techniques},
  booktitle  = {Proceedings LOPSTR'06},
  series     = {Lecture Notes in Computer Science},
  volume     = {4407},
  editor     = {German Puebla},
  publisher  = {Springer-Verlag},
  pages      = {43--59},
  year       = {2006},
  stupsfile  = {http://www.stups.uni-duesseldorf.de/publications/semi_watch_lopstr06.pdf},
}
@incollection{LoBuLeBo06_200,
  author     = {Stephane Lo Presti and Michael Butler and Michael Leuschel and Chris
                Booth},
  title      = {Holistic Trust Design of E-Services},
  editor     = {Ronggong Song and Larry Korba and George Yee},
  booktitle  = {Trust in E-services: Technologies, Practices and Challenges},
  pages      = {113--139},
  publisher  = {IGI Global},
  year       = {2006},
}
@inproceedings{LeBe06_206,
  author     = {Michael Leuschel and Jens Bendisposto},
  title      = {Animating and Model Checking B Specifications with Higher-Order
                Recursive Functions},
  booktitle  = {Dagstuhl Seminar 06191 "Rigorous Methods for Software Construction and
                Analysis"},
  editor     = {J. Abrial, U. Glässer},
  month      = {May},
  year       = {2006},
}

@inproceedings{AbBuHaVo06_286,
  author     = {Jean-Raymond Abrial and Michael Butler and Stefan Hallerstede and
                Laurent Voisin},
  title      = {An open extensible tool environment for Event-B},
  booktitle  = {ICFEM 2006},
  abstract   = {We consider modelling indispensable for the development of complex
    systems.  Modelling must be carried out in a formal notation to reason
    and make meaningful conjectures about a model.  But formal modelling
    of complex systems is a difficult task.  Even when theorem provers
    improve further and get more powerful, modelling will remain
    difficult. The reason for this that modelling is an exploratory
    activity that requires ingenuity in order to arrive at a meaningful
    model. We are aware that automated theorem provers can discharge
    most of the onerous trivial proof obligations that appear when
    modelling systems. In this article we present a modelling tool that
    seamlessly integrates modelling and proving similar to what is
    offered today in modern integrated development environments for
    programming. The tool is extensible and configurable so that it can
    be adapted more easily to different application domains and
    development methods.},
  publisher  = {Springer-Verlag},
  series     = {Lecture Notes in Computer Science},
  pages      = {49--63},
  year       = {2006},
  dbslinks = {[http://eprints.ecs.soton.ac.uk/12711/|PDF]},
}



@inproceedings{BoDoLeMa07_220,
  author     = {Dragan Bosnacki and Alastair F. Donaldson and Michael Leuschel and
                Thierry Massart},
  title      = {Efficient Approximate Verification of {Promela} Models via Symmetry
                Markers},
  booktitle  = {ATVA},
  abstract   = {We present a new verification technique for Promela which exploits
    state-space symmetries induced by scalarset values used in a model.
    The technique involves efficiently computing a marker for each state
    encountered during search.  We propose a complete verification method
    which only partially exploits symmetry, and an approximate
    verification method which fully exploits symmetry.  We describe how
    symmetry markers can be efficiently computed and integrated into the
    Spin  tool, and provide an empirical evaluation of our technique using
    the Topspin symmetry reduction package, which shows very good
    performance results and a high degree of precision for the
    approximate method (i.e. very few non-symmetric states receive the
    same marker).  We also identify a class of models for which the
    approximate technique is precise.},
  publisher  = {Springer-Verlag},
  series     = {Lecture Notes in Computer Science},
  volume     = {4762},
  pages      = {300--315},
  isbn       = {978-3-540-75595-1},
  year       = {2007},
  stupsfile  = {http://www.stups.uni-duesseldorf.de/publications/spin_symmarker.pdf},
}
@inproceedings{BeLe07_207,
 author    = {Jens Bendisposto and
               Michael Leuschel},
  title     = {{BE4}: The B Extensible Eclipse Editing Environment},
  booktitle = {Proceedings of B 2007},
  year      = {2007},
  pages     = {270-273},
  editor    = {Jacques Julliand and Olga Kouchnarenko},
  publisher = {Springer},
  series    = {Lecture Notes in Computer Science},
  volume    = {4355},
  isbn      = {3-540-68760-2},
  abstract   = {The open-source Eclipse platform has become hugely popular as an
    integrated development environment for Java, and a considerable number
    of plug-ins have been developed for other programming languages (e.g.,
    C++,PHP, Eiffel, Python, Fortran, etc.). In this paper we present a
    new plug-in for Eclipse, supporting the B-method and B's abstract
    machine notation (AMN).
    In addition to providing editing and syntax highlighting, the plug-in
    displays syntax and structural errors in the B source code, as well as
    suggesting fixes for those errors.},
    stupsfile  = {http://www.stups.uni-duesseldorf.de/publications/be4.pdf},
}
@inproceedings{KlOsLe07_211,
  author     = {Karl Klose and Klaus Ostermann and Michael Leuschel},
  title      = {Partial Evaluation of Pointcuts},
  booktitle  = {Practical Applications of Declarative Languages (PADL'07)},
  abstract   = {In aspect-oriented programming, pointcuts are usually compiled by
    identifying a set of shadows - that is, places
    in the code whose execution is potentially relevant for a pointcut -
    and inserting dynamic checks at these places for those parts of the
    pointcut that cannot be evaluated statically. Today, the algorithms
    for shadow and check computation are specific for every pointcut
    designator. This makes it very tedious to extend the pointcut
    language.

    We propose the use of declarative languages, together with associated
    analysis and specialisation tools, to implement powerful and
    extensible pointcut languages.
    More specifically, we propose to synthesize (rather than program
    manually) the shadow and dynamic check algorithms.
    With this approach, it becomes easier to implement powerful pointcut
    languages efficiently and to keep pointcut languages open for
    extension.},
  publisher  = {Springer-Verlag},
  month      = {January},
  series     = {Lecture Notes in Computer Science},
  pages      = {320--334},
  isbn       = {978-3-540-69608-7},
  year       = {2007},
}
@inproceedings{BeLe07_210,

  abstract   = {Writing a formal specification for real-life, industrial problems is a
    difficult and error prone task, even for experts in formal methods. In
    the process of specifying a formal model for later refinement and
    implementation it is crucial to get approval and feedback from domain
    experts to avoid the costs of changing a specification at a late point
    of the development. But understanding formal models written in a
    specification language like B requires mathematical knowledge a domain
    expert might not have. In this paper we present a new tool to
    visualize B Machines using the ProB animator and Macromedia Flash. Our
    tool offers an easy way for specifiers to build a domain specific
    visualization that can be used by domain experts to check whether a B
    specification corresponds to their expectations.},
  author    = {Jens Bendisposto and
               Michael Leuschel},
  title     = {A Generic Flash-Based Animation Engine for ProB},
  booktitle = {Proceedings of B 2007},
  year      = {2007},
  pages     = {266-269},
  editor    = {Jacques Julliand and
               Olga Kouchnarenko},
  publisher = {Springer},
  series    = {Lecture Notes in Computer Science},
  volume    = {4355},
  isbn      = {3-540-68760-2},


 }
@inproceedings{LeBuSpTu07_209,
  author     = {Michael Leuschel and Michael Butler and Corinna Spermann and Edd
                Turner},
  title      = {Symmetry Reduction for {}B by Permutation Flooding},
  booktitle  = {Proceedings B'2007},
  abstract   = {Symmetry reduction is an established method for limiting the amount of
    states that have to be checked during exhaustive model checking. The
    idea is to only verify a single representative of every class of
    symmetric states. However, computing this representative can be
    nontrivial,
    especially for a language such as B with its involved data structures
    and operations. In this paper, we propose an alternate approach,
    called permutation flooding. It works by computing permutations of
    newly encountered states, and adding them to the state space. This
    turns out to be relatively unproblematic for B?s data structures and
    we have implemented the algorithm inside the ProB model checker.
    Empirical results
    confirm that this approach is effective in practice; speedups exceed
    an order of magnitude in some cases. The paper also contains
    correctness results of permutation flooding, which should also be
    applicable for classical symmetry reduction in B.},
  publisher  = {Springer-Verlag},
  series     = {Lecture Notes in Computer Science},
  volume     = {4355},
  pages      = {79--93},
  year       = {2007},
  stupsfile  = {http://www.stups.uni-duesseldorf.de/publications/poor_mansym_B2007_final.pdf},
}
@inproceedings{LeMa07_212,
  author     = {Michael Leuschel and Thierry Massart},
  title      = {Efficient Approximate Verification of {B} via Symmetry Markers},
  booktitle  = {Proceedings International Symmetry Conference},
  pages      = {71--85},
  month      = {January},
  year       = {2007},
  address    = {Edinburgh, UK},
  stupsfile  = {http://www.stups.uni-duesseldorf.de/publications/final-symmetry.pdf},
}

@inproceedings{SaBuLeRa07_215,
  author     = {Manoranjan Satpathy and Michael Butler and Michael Leuschel and S.
                Ramesh},
  title      = {Automatic Testing from Formal Specifications},
  booktitle  = {Tests and Proofs (TAP 2007)},
  pages      = {95--113},
  month      = {Feb},
  publisher  = {Springer-Verlag},
  series     = {Lecture Notes in Computer Science},
  volume     = {4454},
  isbn       = {978-3-540-73769-8},
  year       = {2007},
}
@inproceedings{TuLeSpBu07_217,
  author     = {Edd Turner and Michael Leuschel and Corinna Spermann and Michael
                Butler},
  title      = {Symmetry Reduced Model Checking for {B}},
  booktitle  = {Proceedings TASE 2007},
  abstract   = {Symmetry reduction is a technique that can help alleviate the problem
    of state space explosion in model checking. The idea is to verify only
    a subset of states from each class (orbit) of symmetric states. This
    paper presents a framework for symmetry reduced model checking of B
    machines, which verifies a unique representative from each orbit.
    Symmetries are induced by the deferred set; a key component of the B
    language. This contrasts with strategies that require the introduction
    of a special data type into a language, to indicate symmetry. An
    extended version of the graph isomorphism program, textitnauty, is
    used to detect symmetries, and the symmetry reduction package has been
    integrated into the ProB model checker. Experimental results
    illustrate the effectiveness of the method, where exponential speedups
    are sometimes possible. Relevant algorithms are presented, and there
    is a comparison with an alternate symmetry reduction strategy, called
    permutation flooding.},
  publisher  = {IEEE},
  pages      = {25--34},
  year       = {2007},
  stupsfile  = {http://www.stups.uni-duesseldorf.de/publications/turner-SymmetryReductionInB.pdf},
}
@inproceedings{proz07,
  author     = {Daniel Plagge and Michael Leuschel},
  title      = {Validating {Z} Specifications using the {ProB} Animator and Model Checker},
  booktitle  = {Integrated Formal Methods},
  series     = {Lecture Notes in Computer Science},
  volume     = {4591},
  abstract   = {We present the architecture and implementation of the ProZ tool to
    validate high-level Z specifications. The tool was integrated into
    ProB, by providing a translation of Z into B and by extending the
    kernel of ProB to accommodate some new syntax and data types. We
    describe the challenge of going from the tool friendly formalism B to
    the more specification-oriented formalism Z, and show how many Z
    specifications can be systematically translated into B. We describe
    the extensions, such as record types and free types, that had to be
    added to the kernel to support a large subset of Z. As a side-effect,
    we provide a way to animate and model check records in ProB. By
    incorporating ProZ into ProB, we have inherited many of the recent
    extensions developed for B, such as the integration with CSP or the
    animation of recursive functions. Finally, we present a successful
    industrial application, which makes use of this fact, and where ProZ
    was able to discover several errors in Z specifications containing
    higher-order recursive functions.},
  editor     = {J. Davies and J. Gibbons},
  publisher  = {Springer-Verlag},
  pages      = {480--500},
  year       = {2007},
  stupsfile  = {http://www.stups.uni-duesseldorf.de/publications/proz.pdf},
}
@article{LiBeLe07_219,
  author     = {Olivier Ligot and Jens Bendisposto and Michael Leuschel},
  title      = {Debugging Event-B Models using the ProB Disprover Plug-in},
  journal    = {Proceedings AFADL'07},
  abstract   = {The B-method, as well as its offspring Event-B, are both
    tool-supported formal methods used for the development of computer
    systems whose correctness is formally proven.
    However, the more complex the specification becomes, the more proof
    obligations need to be discharged.
    While many proof obligations can be discharged automatically by recent
    tools such as the Rodin platform,
    a considerable number still have to be proven interactively.
    This can be either because the required proof is too complicated or
    because the B model is erroneous.
    In this paper we describe a disprover plugin for Rodin that utilizes
    the ProB animator and model checker to  automatically find
    counterexamples for a given problematic proof obligation.
    In case the disprover finds a counterexample, the user can directly
    investigate the source of the problem (as pinpointed by the
    counterexample) and should not attempt to prove the proof obligation.
    We also discuss under which circumstances our plug-in can be used as a
    prover, i.e., when the absence of
    a counterexample actually is a proof of the proof obligation.},
  month      = {Juni},
  year       = {2007},
  stupsfile  = {http://www.stups.uni-duesseldorf.de/publications/afadl07_reduced.pdf},
}
@inproceedings{BoRi07_223,
  author     = {Carl Friedrich Bolz and Armin Rigo},
  title      = {How to not write Virtual Machines for Dynamic Languages},
  booktitle  = {Proceeding of Dyla 2007},
  abstract   = {Typical modern dynamic languages have a growing number of
    implementations. We explore the reasons for this situation, and the
    limitations it imposes on open source or academic communities that
    lack the resources to fine-tune and maintain them all. It is sometimes
    proposed that implementing dynamic languages on top of a standardized
    general-purpose ob ject-oriented virtual machine (like Java or .NET)
    would help reduce this burden. We propose a complementary alternative
    to writing custom virtual machine (VMs) by hand, validated by the PyPy
    pro ject: flexibly generating VMs from a high-level ?specification?,
    inserting features and low-level details automatically ? including
    good just-in-time compilers tuned to the dynamic language at hand.
    We believe this to be ultimately a better investment of efforts than
    the development of more and more advanced general-purpose object
    oriented VMs. In this paper we compare these two approaches in detail.},
  year       = {2007},
  stupsfile  = {http://www.stups.uni-duesseldorf.de/publications/dyla07-HowToNotWriteVMs.pdf},
}
@techreport{LePl07ltltechrep,
  author     = {Michael Leuschel and Daniel Plagge},
  title      = {Seven at one stroke: {LTL} model checking for High-level Specifications
                in {B}, {Z}, {CSP}, and more},
  number     = {STUPS/2007/02},
  institution= {Institut für Informatik, Heinrich-Heine-Universität Düsseldorf},
  year       = {2007},
  stupsfile  = {http://www.stups.uni-duesseldorf.de/publications/ltl-technical-report.pdf},
  abstract   = {This technical report is an extension to the conference
    paper with the same name. It contains the proofs that were omitted
    in the conference paper.},
}
@inproceedings{LeuschelPlagge2007ltl,
  author    = {Michael Leuschel and Daniel Plagge},
  title     = {Seven at one stroke: {LTL} model checking for High-level
               Specifications in {B}, {Z}, {CSP}, and more},
  booktitle = {ISoLA},
  year      = {2007},
  pages     = {73--84},
  editor    = {Yamine A\"{\i}t Ameur and
               Fr{\'e}d{\'e}ric Boniol and
               Virginie Wiels},
  publisher = {C{\'e}padu{\`e}s-{\'E}ditions},
  series    = {Revue des Nouvelles Technologies de l'Information},
  volume    = {RNTI-SM-1},
  year      = {2007},
  isbn      = {978-2-85428-814-8},
  abstract  = {The size of formal models is steadily increasing and there is
    a demand from industrial users to be able to use expressive temporal
    query languages for validating and exploring high-level formal
    specifications. We present an extension of LTL, which is well adapted
    for validating B, Z and CSP specifications.<br/>We present a generic,
    flexible LTL model checker, implemented inside the ProB tool, that can be
    applied to a multitude of formalisms such as B, Z, CSP, B CSP,
    as well as Object Petri nets, compensating CSP, and dSL.
    Our algorithm can deal with deadlocking states, partially explored
    state spaces, past operators, and can be combined with existing
    symmetry reduction techniques of ProB. We establish correctness of our
    algorithm in general, as well as combined with symmetry reduction.<br/>
    Finally, we present various applications and empirical results of our
    tool, showing that it can be applied successfully in practice.},
}
@article{AbHa07_273,
  author     = {Jean-Raymond Abrial and Stefan Hallerstede},
  title      = {Refinement, Decomposition, and Instantiation of Discrete Models:
                Application to Event-B},
  journal    = {Fundamenta Informaticae},
  volume     = {77},
  number     = {1-2},
  abstract   = {We argue that formal modeling should be the starting point for any
    serious development of computer systems. This claim poses a
    challenge for modeling: at first it must cope with the constraints
    and scale of serious developments.  Only then it is a suitable
    starting point. We present three techniques, refinement,
    decomposition, and instantiation, that we consider indispensable for
    modeling large and complex systems. The vehicle of our presentation
    is Event-B, but the techniques themselves do not depend on it.},
  pages      = {1--28},
  year       = {2007},
}
@inproceedings{HaHo07_284,
  author     = {Stefan Hallerstede and Thai Son Hoang},
  title      = {Qualitative Probabilistic Modelling in Event-B},
  booktitle  = {IFM 2007},
  abstract   = {Event-B is a notation and method for discrete systems modelling by
    refinement. We introduce a small but very useful construction:
    qualitative probabilistic choice. It extends the expressiveness of
    Event-B allowing us to prove properties of systems that could not be
    formalised in Event-B before. We demonstrate this by means of a
    small example, part of a larger Event-B development that could not
    be fully proved before. An important feature of the introduced
    construction is that it does not complicate the existing Event-B
    notation or method, and can be explained without referring to the
    underlying more complicated probabilistic theory. The necessary
    theory itself is briefly outlined in
    this article to justify the soundness of the proof obligations
    given. We also give a short account of alternative constructions
    that we explored, and rejected.},
  editor     = {J. Davies and J. Gibbons},
  publisher  = {Springer-Verlag},
  series     = {Lecture Notes in Computer Science},
  pages      = {293--312},
  year       = {2007},
}
@inproceedings{Ha07_285,
  author     = {Stefan Hallerstede},
  title      = {Justifications for the Event-B Modelling Notation},
  booktitle    = {B 2007},
  series      = {Lecture Notes in Computer Science},
  volume     = {4591},
  abstract   = {Event-B is a notation and method for discrete systems modelling by
    refinement. The notation has been carefully designed to be simple
    and easily teachable. The simplicity of the notation takes also into
    account the support by a modelling tool. This is important because
    Event-B is intended to be used to create complex models. Without
    appropriate tool support this would not be possible. This article
    presents justifications and explanations for the choices that have
    been made when designing the Event-B notation.},
  editor     = {J. Julliand and O. Kouchnarenko},
  publisher  = {Springer-Verlag},
  pages      = {293--312},
  year       = {2007},
}
@inproceedings{BuHa07_292,
  author     = {Michael Butler and Stefan Hallerstede},
  title      = {The Rodin Formal Modelling Tool},
  booktitle  = {BCS-FACS Christmas 2007 Meeting},
  abstract   = {We present a software tool, the Rodin tool, for formal modelling in
    Event-B.  Event-B is a notation and method developed from the
    B-Method and is intended to be used with an incremental style of
    modelling. The idea of incremental modelling has been taken from
    programming: modern programming languages come with integrated
    development environments that make it easy to modify and improve
    programs. The Rodin tool provides such an environment for Event-B.

    The two main characteristics of the Rodin tool are its ease of use
    and its extensibility. The tool focuses on modelling. It is easy to
    modify models and try out variations of a model. The tool can also
    be extended easily. This will make it possible to adapt the tool
    specific needs. So the tool can be adapted to fit into existing
    development processes instead demanding the opposite. We believe
    that these two characteristics are major points for industrial
    uptake.},
  year       = {2007},
}




@article{LeBu08_225,
  author     = {Michael Leuschel and Michael Butler},
  title      = {{ProB}: An Automated Analysis Toolset for the {B} Method},
  journal    = {Software Tools for Technology Transfer (STTT)},
  volume     = {10},
  number     = {2},
  abstract   = {We present ProB, a validation toolset for the B
    method. ProB's automated animation facilities allow users to gain
    confidence in their specifications.
    ProB also contains a model checker and a refinement checker, both of
    which can  be used to detect various errors in B specifications. We
    describe the underlying methodology of ProB, and present the important
    aspects of the implementation.
    We also present empirical evaluations as well as several
    case studies, highlighting that ProB enables users to uncover errors
    that are not easily discovered by existing tools.},
  publisher  = {Springer-Verlag},
  pages      = {185--203},
  year       = {2008},
  stupsfile  = {http://www.stups.uni-duesseldorf.de/publications/overview_final.pdf},
  stupskeywords={prob},
}
@inproceedings{LeSaBeLu08_228,
  author     = {Michael Leuschel and Mireille Samia and Jens Bendisposto and Li Luo},
  title      = {Easy Graphical Animation and Formula Viewing for Teaching {B}},
  booktitle    = {The B Method: from Research to Teaching},
  editor     = {C. Attiogbé and H. Habrias},
  publisher  = {Lina},
  pages      = {17--32},
  year       = {2008},
  stupsfile  = {http://www.stups.uni-duesseldorf.de/publications/EasyGraphAnimFormVis_forTeachingB_Nantes.pdf},
}
@inproceedings{SpLe08_229,
  author     = {Corinna Spermann and Michael Leuschel},
  title      = {{ProB} gets {Nauty}: Effective Symmetry Reduction for {B} and {Z} Models},
  booktitle  = {Proceedings TASE 2008},
  publisher  = {IEEE},
  month      = {June},
  pages      = {15--22},
  year       = {2008},
  stupskeywords={prob},
  abstract = {Symmetry reduction holds great promise to counter the state explosion problem.
However, currently it is ``conducting a life on the fringe'', and is not widely applied, mainly due to the restricted applicability of many of the techniques.
In this paper we propose a symmetry reduction technique applied to high-level
formal specification languages (B and Z).
Not only does symmetry arise naturally in most models, it can also be exploited
without restriction by our method.
This method translates states of a formal model into directed graphs, and then
uses graph canonicalisation to detect symmetries.
We use the tool nauty to efficiently perform
graph canonicalisation, which we have interfaced with the model checker ProB.

In this paper we present the general technique, show how states can be translated first into
 vertex-coloured graphs suitable for nauty.
We present empirical results, showing the effectiveness of our method as well as analysing the cost of graph canonicalisation.}
}
@inproceedings{Leuschel08highroad,
  author     = {Michael Leuschel},
  title      = {The High Road to Formal Validation: Model Checking High-Level versus
                Low-Level Specifications},
  booktitle  = {ABZ 2008},
  abstract   = {In this paper we examine the difference between model checking
    high-level and low-level models.
    In particular, we compare the ProB model checker for the B-method and
    the Spin model checker for Promela.
    While Spin has a dramatically more efficient model checking engine, we
    show that in practice the performance can be disappointing compared to
    model checking high-level specifications with ProB.
    We investigate the reasons for this behaviour, examining expressivity,
    granularity and Spin's search algorithms.
    We also show that certain types of information (such as symmetry) can
    be more easily inferred and exploited in high-level models, leading to
    a considerable reduction in model checking time.},
  publisher  = {Springer-Verlag},
  month      = {September},
  series     = {Lecture Notes in Computer Science},
  volume     = {5238},
  pages      = {4--23},
  year       = {2008},
  stupsfile  = {http://www.stups.uni-duesseldorf.de/publications/abz08_invited.pdf},
}
@inproceedings{Le08_233,
  author     = {Michael Leuschel},
  title      = {Declarative Programming for Verification: Lessons and Outlook},
  booktitle  = {Proceedings PPDP'2008},
  abstract   = {This paper summarises roughly ten years of experience using
    declarative programming for
    developing tools to validate formal specifications.
    More precisely, we present  insights gained and lessons learned while
    implementing animators and model checkers in Prolog for various
    specification languages,
    ranging from process algebras such as CSP to model-based
    specifications such as Z and B.},
  publisher  = {ACM Press},
  month      = {July},
  pages      = {1--7},
  year       = {2008},
  stupsfile  = {http://www.stups.uni-duesseldorf.de/publications/ppdp8k-leuschel.pdf},
}
@inproceedings{LeVi08_234,
  author     = {Michael Leuschel and Germán Vidal},
  title      = {Fast Offline Partial Evaluation for Large Logic Programs},
  booktitle  = {Proceedings LOPSTR'08},
  editor     = {Michael Hanus},
  series     = {Lecture Notes in Computer Science},
  volume     = {5438},
  year       = {2008},
  pages = {119--134},
  stupsfile  = {http://www.stups.uni-duesseldorf.de/publications/size_change_bta_paper_cr.pdf},
  abstract   = {In this paper, we present a fast binding-time analysis (BTA) by
integrating a size-change analysis, which is independent of a
selection rule, into a classical BTA for offline partial evaluation
of logic programs. In contrast to previous approaches, the new BTA
is conceptually simpler and considerably faster, scaling to
medium-sized or even large examples and, moreover, it ensures both
the so called local and global termination.
We also show that through the use of selective hints, we can achieve both good specialisation results and a fast BTA and specialisation process.},
}

@inproceedings{LeLlOlSiTa08_236,
  author     = {Michael Leuschel and Marisa Llorens and Javier Olivier and Josep Silva
                and Salvador Tamarit},
  title      = {Static Slicing of CSP Specifications},
  booktitle  = {Preproceedings LOPSTR'08},
  abstract   = {This work presents a static slicing based technique to slice
    CSP specifications. Given a particular event in a CSP
    specification, our
    technique allows us to know what parts of the specification must
    necessarily be executed before this event, and what parts of the
    specification
    could be executed before it in some execution. Our technique is based
    on a new data structure which extends the synchronized CFG. We show
    that this new data structure improves the synchronized CFG by taking
    into account the context in which processes are called and, thus,
    makes the slicing process more precise.},
  editor     = {Michael Hanus},
  series     = {Lecture Notes in Computer Science},
  volume     = {5438},
  pages      = {103--118},
  year       = {2008},
  stupsfile  = {http://www.stups.uni-duesseldorf.de/publications/paper.pdf},
}
@article{LeFo08_237,
  author     = {Michael Leuschel and Marc Fontaine},
  title      = {Probing the Depths of CSP-M: A new FDR-compliant Validation Tool},
  journal    = {ICFEM 2008},
  abstract   = {We present a new animation and model checking tool for CSP.
    The tool covers the CSP-M language, as supported by existing
    tools such as fdr and probe.
    Compared to those tools, it
    provides visual feedback in the source code,
    has an LTL model checker and can be used for combined CSP||B
    specifications.
    During the development of the tool some intricate issues were
    uncovered with
    the CSP-M language.
    We discuss those issues, and provide suggestions for improvement.
    We also explain how we have ensured conformance with fdr, by using fdr
    itself
    to validate our tool's output.
    We also provide empirical evidence on the performance of our tool
    compared to fdr,
    showing that it can be used on industrial-strength specifications.},
  publisher  = {Springer-Verlag},
  year       = {2008},
  pages      = {278--297},
  stupsfile  = {http://www.stups.uni-duesseldorf.de/publications/main.pdf},
}
@inproceedings{BeEnLeSc08_240,
  author     = {Jens Bendisposto and Ian Endrijautzki and Michael Leuschel and David
                Schneider},
  title      = {A Semantics-Aware Editing Environment for Prolog in Eclipse},
  booktitle  = {Proceedings of the 18th Workshop on
Logic-based methods in Programming Environments, WLPE},
  abstract = {In this paper we present a Prolog plugin for Eclipse based upon BE4, and providing many features such as semantic-aware syntax highlighting, outline view, error marking, content assist, hover information, documentation generation, and quick fixes. The plugin makes use of a Java parser for full Prolog with an inte- grated Prolog engine, and can be extended with further semantic analyses, e.g., based on abstract interpretation.},
  year       = {2008},
  stupsfile  = {http://www.stups.uni-duesseldorf.de/publications/prolog_eclipse_wlpe.pdf},
}
@inproceedings{BoKuMaLiNiReRiVe08_245,
  author     = {Carl Friedrich Bolz and Adrian Kuhn and Nicholas Matsakis and Adrian
                Lienhard and Oscar Nierstrasz and Lukas Renggli and Armin Rigo and
                Toon Verwaest},
  title      = {Back to the Future in One Week – Implementing a Smalltalk VM in PyPy},
  booktitle  = {Self-Sustaining Systems},
  abstract   = {We report on our experiences with the Spy project, including
    implementation details and benchmark results. Spy is a
    re-implementation of the Squeak (i.e. Smalltalk-80) VM using the PyPy
    toolchain. The PyPy project allows code written in RPython, a subset
    of Python, to be translated
    to a multitude of different backends and architectures. During the
    translation, many aspects of the implementation can be
    independently tuned, such as the garbage collection algorithm or
    threading implementation. In this way, a whole host of interpreters
    can be derived from one abstract interpreter definition. Spy aims to
    bring these benefits to Squeak, allowing for greater portability and,
    eventually, improved performance. The current
    Spy codebase is able to run a small set of benchmarks that demonstrate
    performance superior to many similar Smalltalk VMs, but
    which still run slower than in Squeak itself. Spy was built from
    scratch over the course of a week during a joint Squeak-PyPy Sprint in
    Bern last autumn.},
  publisher  = {Springer},
  series     = {Lecture Notes in Computer Science},
  pages      = {123--139},
  year       = {2008},
  stupsfile  = {http://www.stups.uni-duesseldorf.de/publications/spy-s3-final-submission.pdf},
}
@inproceedings{Ha08_281,
  author     = {Stefan Hallerstede},
  title      = {Incremental system modelling in Event-B},
  booktitle  = {FMCO 2008},
  abstract   = {A reasonable approach to formal modelling is to start with a
    specification that captures the requirements of a system and then use
    formal refinement to implement it.

    The problem with this approach is that for complex systems the
    specification itself is complex. It becomes a challenge to say whether
    the specification is the right one for the given requirements.
    Sometimes requirements also concern features of a system closely
    related to its implementation. This would make an abstract
    specification necessarily incomplete.

    We believe that it is better not to follow the rigid approach to
    modelling described above. Instead, we argue that the specification
    itself should be elaborated by refinement. Ultimately, the distinction
    between specification and implementation is no longer made in the
    strict sense above. There is only one model of the system that is
    connected by successive refinements. Using Event-B, we demonstrate how
    this can be applied to cope with the complexity of specifications. On
    the one hand we benefit from the reduced number of detail to consider
    at different times. On the other hand we are encouraged to reason
    about the formal model since the beginning and to rethink it
    occasionally to capture better its intended behaviour and match the
    requirements.},
  publisher  = {Springer-Verlag},
  series     = {Lecture Notes in Computer Science},
  pages      = {139--158},
  year       = {2008},
}
@inproceedings{AbBuHaVo08_282,
  author     = {Jean-Raymond Abrial and Michael Butler and Stefan Hallerstede and
                Laurent Voisin},
  title      = {A roadmap for the Rodin Toolset},
  booktitle  = {ABZ 2008},
  abstract   = {Event-B is a formal method for system-level modelling and analysis.
    Key features of Event-B are the use of set theory as a modelling
    notation, the use of refinement to represent systems at different
    abstraction levels and the use of mathematical proof to verify
    consistency between refinement levels.
    The continued development of the Rodin toolset is funded by the EU
    research project ICT 214158 DEPLOY (Industrial deployment of system
    engineering methods providing high dependability and productivity)
    www.deploy-project.eu. The toolset was originally developed as part of
    the project IST 511599 RODIN (Rigorous Open Development Environment
    for Complex Systems).},
  publisher  = {Verlag},
  series     = {Lecture Notes in Computer Science},
  pages      = {347--347},
  year       = {2008},
  dbslinks = {[http://eprints.ecs.soton.ac.uk/16769/|PDF]},
}
@inproceedings{Ha08_283,
  author     = {Stefan Hallerstede},
  title      = {On the Purpose of Event-B Proof Obligations},
  booktitle  = {ABZ 2008},
  abstract   = {Event-B is a formal modelling method which is claimed to be suitable
    for diverse modelling domains, such as reactive systems and sequential
    program development. This claim hinges on the fact that any particular
    model has an appropriate semantics. In Event-B this semantics is
    provided implicitly by proof obligations associated with a model.
    There is no fixed semantics though. In this article we argue that this
    approach is beneficial to modelling because we can use similar proof
    obligations across a variety of modelling domains. By way of two
    examples we show how similar proof obligations are linked to different
    semantics.  A small set of proof obligations is thus suitable for a
    whole range of modelling problems in diverse modelling domains.},
  publisher  = {Springer-Verlag},
  series     = {Lecture Notes in Computer Science},
  pages      = {125--138},
  year       = {2008},
}

@article{DBLP:journals/tsi/BendispostoLLS08,
  author    = {Jens Bendisposto and
               Michael Leuschel and
               O. Ligot and
               Mireille Samia},
  title     = {La validation de mod{\`e}les Event-B avec le plug-in
               ProB pour RODIN},
  journal   = {Technique et Science Informatiques},
  volume    = {27},
  number    = {8},
  year      = {2008},
  pages     = {1065-1084},
  ee        = {http://tsi.revuesonline.com/article.jsp?articleId=12371},
  bibsource = {DBLP, http://dblp.uni-trier.de},
}
@article{BaLeVa07_198,
  author     = {Steve Barker and Michael Leuschel and Mauricio Varea},
  title      = {Efficient and Flexible Access Control via {Jones}-Optimal Logic Program
                Specialisation},
  journal    = {Higher-Order and Symbolic Computation},
  abstract   = {We describe the use of a flexible meta-interpreter for performing
    access control checks on deductive databases. The meta-program is
    implemented in Prolog and takes as input a database and an access
    policy specification. For processing access control requests we
    specialise the meta-program for a given access policy and database by
    using  the Logen partial evaluation system. The resulting specialised
    control checking program is dependent solely upon dynamic information
    that can only be known at the time of actual access request
    evaluation.
    In addition to describing our approach, we give a number of
    performance measures for our implementation of an access control
    checker. In particular, we show that by using our approach we get
    flexible access control with virtually no overhead, satisfying the
    Jones optimality criterion. The paper also shows how to satisfy the
    Jones optimality criterion more generally for interpreters written in
    the non-ground representation.},
  volume     = {21},
  number     = {1--2},
  pages      = {5--35},
  year       = {2008},
  stupsfile  = {http://www.stups.uni-duesseldorf.de/publications/pe-hosc_final.pdf},
}




@inproceedings{LeCaBu09_221,
  author     = {Michael Leuschel and Dominique Cansell and Michael Butler},
  title      = {Validating and Animating Higher-Order Recursive Functions in {B}},
  booktitle  = {Festschrift for Egon Börger},
  abstract   = {ProB is an animation and model checking tool for the B Method, which
    can deal with many interesting  specifications.
    Some specifications, however, contain complicated functions which
    cannot be represented explicitly by a tool.
    We present a scheme with which higher-order recursive functions can be
    encoded in B, and establish soundness of this scheme.
    We then describe a symbolic representation for such functions.
    This representation enables ProB to successfully animate and model
    check a new class of relevant specifications, where animation is
    especially important due to the involved nature of the specification.},
  editor     = {Jean-Raymond Abrial and Uwe Glässer},
  publisher  = {Springer-Verlag},
  series     = {Lecture Notes in Computer Science},
  volume     = {5115},
  year       = {2009},
  stupsfile  = {http://www.stups.uni-duesseldorf.de/publications/festschrift_closures_final.pdf},
  stupsfile  = {http://www.stups.uni-duesseldorf.de/publications/festschrift_closures_final.pdf},
  stupskeywords={prob},
}
@inproceedings{BoLeRi09_235,
  author     = {Carl Friedrich Bolz and Michael Leuschel and Armin Rigo},
  title      = {Towards Just-In-Time Partial Evaluation of {Prolog}},
  abstract   = {We introduce a just-in-time specializer for Prolog.
    Just-in-time specialization attempts to unify of the concepts and
    benefits of partial evaluation (PE) and
    just-in-time (JIT) compilation.  It is a variant of PE
    that occurs purely at runtime, which lazily generates residual code
    and is constantly driven by runtime feedback.

    Our prototype is an on-line just-in-time partial evaluator.
    A major focus of our work is to remove the overhead incurred when
    executing an interpreter written in Prolog.
    It improves over classical offline PE by requiring almost no
    heuristics nor hints from the author of the interpreter; it also
    avoids most termination
    issues due to interleaving execution and specialization.
    We evaluate the performance of our prototype on a small number of
    benchmarks.},
  year       = {2009},
  pages = {158-172},
  booktitle = {Logic-Based Program Synthesis and Transformation, 19th International Symposium, LOPSTR 2009, Coimbra, Portugal, September 2009, Revised Selected Papers},
  editor = {Danny De Schreye},
  volume = {6037},
  series = {Lecture Notes in Computer Science},
  publisher = {Springer},
  isbn = {978-3-642-12591-1},

  stupsfile  = {http://www.stups.uni-duesseldorf.de/publications/bolz-jit-pe-prolog.pdf},

}
@inproceedings{LeLlOlSiTa09_241,
  author     = {Michael Leuschel and Marisa Llorens and Javier Olivier and Josep Silva
                and Salvador Tamarit},
  title      = {{SOC}: A Slicer for {CSP} Specifications},
  booktitle  = {PEPM 2009},
  abstract   = {This paper describes SOC, a program slicer for CSP
    specifications. In order to increase the precision of
    program slicing, SOC uses a new data structure
    called Context-sensitive Synchronized Control Flow Graph (CSCFG).
    Given a CSP specification, SOC generates its associated CSCFG
    and produces from it two different kinds of slices; which correspond
    to two
    different static analyses. We present the tool's architecture,
    its main applications and the results obtained from
    experiments conducted in order to measure the performance of the tool.},
  publisher  = {ACM Press},
  year       = {2009},
  stupsfile  = {http://www.stups.uni-duesseldorf.de/publications/paper.pdf},
}
@proceedings{LeWe09_243,
  editor     = {Michael Leuschel and Heike Wehrheim},
  title      = {Integrated Formal Methods: Proceedings {iFM} 2009},
  publisher  = {Springer-Verlag},
  series     = {Lecture Notes in Computer Science},
  volume     = {5423},
  isbn       = {978-3-642-00254-0},
  year       = {2009},
}
@inproceedings{BoCuFiRi09_246,
  author     = {Carl Friedrich Bolz and Antonio Cuni and Maciej Fijalkowski and Armin
                Rigo},
  title      = {Tracing the Meta-Level: PyPy's Tracing JIT Compiler},
  booktitle  = {ICOOOLPS 2009},
  abstract   = {We attempt to apply the technique of Tracing JIT Compilers
    in the context
    of the PyPy project, i.e. to programs that are interpreters for some
    dynamic languages, including Python.  Tracing JIT compilers can
    greatly
    speed up programs that spend most of their time in loops in which they
    take similar code paths.  However, applying an unmodified tracing JIT
    to a program that is itself a bytecode interpreter results in very
    limited or no speedup.
    In this paper we show how to guide tracing JIT compilers to greatly
    improve the speed of bytecode interpreters.  One crucial point is to
    unroll the bytecode dispatch loop, based on two hints provided by the
    implementer of the bytecode interpreter.  We evaluate our technique by
    applying it to two PyPy interpreters: one is a small example, and the
    other one is the full Python interpreter.},
  year       = {2009},
  publisher = {{ACM}},
  pages = {18--25},
  stupsfile  = {http://www.stups.uni-duesseldorf.de/publications/bolz-tracing-jit.pdf},

}
@inproceedings{SaLe09_247,
  author     = {Mireille Samia and Michael Leuschel},
  title      = {Pie Tree Visualization},
  booktitle  = {Proceedings SEKE},
  abstract   = {Visualizing graphs with a large number of edges and vertices can be
    cumbersome and ineffective. This is due to the presence of countless
    overlapping arrows, which makes a graph unclear and  hard to
    understand and interpret by a human. The aim of this paper is to try
    to address this problem using a new concept of data visualization,
    namely pie tree visualization. We illustrate this technique on the
    module architecture of a real-life development from the project
    Deploy. We first describe pie tree visualization, and then, present
    its advantages.},
  publisher  = {Knowledge Systems Institute},
  pages      = {400--405},
  isbn       = {1-891706-24-1},
  year       = {2009},
}
@inproceedings{LeFaFrPl09_248,
  author     = {Michael Leuschel and Jérôme Falampin and Fabian Fritz and Daniel
                Plagge},
  title      = {Automated Property Verification for Large Scale {B} Models},
  booktitle  = {Proceedings FM 2009},
  abstract   = {In this paper we describe the successful application of the ProB
    validation tool on an industrial case study. The case study centres on
    the San Juan metro system installed by Siemens. The control software
    was developed and formally proven with B. However, the development
    contains certain assumptions about the actual rail network topology
    which have to be validated separately in order to ensure safe
    operation. For this task, Siemens has developed custom proof rules for
    AtelierB. AtelierB, however, was unable to deal with about 80
    properties of the deployment (running out of memory). These properties
    thus had to be validated by hand at great expense (and they need to be
    revalidated whenever the rail network infrastructure changes).<br/> In this
    paper we show how we were able to use ProB to validate all of the
    about 300 properties of the San Juan deployment, detecting exactly the
    same faults automatically in around 17 minutes that were manually
    uncovered in about one man-month. This achievement required the
    extension of the ProB kernel for large sets as well as an improved
    constraint propagation phase. We also outline some of the effort and
    features that were required in moving from a tool capable of dealing
    with medium-sized examples towards a tool able to deal with actual
    industrial specifications. Notably, a new parser and type checker had
    to be developed. We also touch upon the issue of validating ProB, so
    that it can be integrated into the SIL4 development chain at Siemens},
  publisher  = {Springer-Verlag},
  series     = {Lecture Notes in Computer Science},
  volume     = {5850},
  pages      = {708--723},
  year       = {2009},
  stupsfile  = {http://www.stups.uni-duesseldorf.de/publications/siemens_fm09_final.pdf},
  stupskeywords={prob},
}
@inproceedings{PlLeLoRo09_249,
  author     = {Daniel Plagge and Michael Leuschel and Ilya Lopatkin and Alexander
                Romanovsky},
  title      = {{SAL}, {Kodkod}, and {BDD}s for Validation of {B} Models. Lessons and Outlook},
  booktitle  = {Proceedings AFM 2009},
  abstract   = {ProB is a model checker for high-level B and Event-B models based on
    constraint-solving. In this paper we investigate alternate approaches
    for validating high-level B models using alternative techniques and
    tools based on using BDDs, SAT-solving and SMT-solving. In particular,
    we examine whether PROB can be complemented or even supplanted by
    using one of the tools BDDBDDB, Kodkod or SAL.},
  pages      = {16--22},
  dbslinks   = {Workshop on Automated Formal Methods: [http://fm.csl.sri.com/AFM09/|Website AFM 2009]},
  year       = {2009},
  stupsfile  = {http://www.stups.uni-duesseldorf.de/publications/afm_sal_kodkod_prob.pdf},
  stupskeywords={prob},
}
@inproceedings{BeLe09_253,
  booktitle = {Proceedings of ICFEM 2009},
  year      = {2009},
  pages     = {504-520},
  ee        = {http://dx.doi.org/10.1007/978-3-642-10373-5_26},
  crossref  = {DBLP:conf/icfem/2009},
  author     = {Jens Bendisposto and Michael Leuschel},
  title      = {Proof Assisted Model Checking for {B}},
  abstract   = {With the aid of the ProB Plugin, the Rodin Platform provides an
    integrated environment for editing, proving, animating and model
    checking Event-B models. This is of considerable benefit to the
    modeler, as it allows him to switch between the various tools to
    validate, debug and improve his or her models. The crucial idea of
    this paper is that the integrated platform also provides benefits to
    the tool developer, i.e., it allows easy access to information from
    other tools. Indeed, there has been considerable interest in combining
    model checking, proving and testing.
    In previous work we have already shown how a model checker can be used
    to complement the Event-B proving environment, by acting as a
    disprover. In this paper we show how the prover can help improve the
    efficiency of the animator and model checker.},
  editor    = {Karin Breitman and  Ana Cavalcanti},
  year       = {2009},
  publisher = {Springer},
  series    = {Lecture Notes in Computer Science},
  volume    = {5885},
  year      = {2009},
  isbn      = {978-3-642-10372-8},
  stupskeywords={prob},
}
@inproceedings{WiKoRoLeBePlSc09_252,
  author     = {Sebastian Wieczorek and Vitaly Kozyura and Andreas Roth and Michael
                Leuschel and Jens Bendisposto and Daniel Plagge and Ina Schieferdecker},
  title      = {Applying Model Checking to Generate Model-based Integration Tests from
                Choreography Models},
  booktitle  = {Proceedings TESTCOM/FATES 2009},
  abstract   = {Choreography models describe the communication protocols between
    services. Testing of service choreographies is an important task for
    the quality assurance of service-based systems as used e.g. in the
    context of service-oriented architectures (SOA). The formal modeling
    of service choreographies enables a model-based integration testing
    (MBIT) approach. We present MBIT methods for our service choreography
    modeling approach called Message Choreography Models (MCM). For the
    model-based testing of service choreographies, MCMs are translated
    into Event-B models and used as input for our test generator which
    uses the model checker ProB.},
  publisher  = {Springer-Verlag},
  series     = {Lecture Notes in Computer Science},
  volume     = {5826},
  pages      = {179--194},
  year       = {2009},
  stupsfile  = {http://www.stups.uni-duesseldorf.de/publications/testcom_camera_ready.pdf},
  stupskeywords={prob},
}
@inproceedings{LaBeLe09_258,
author    = {Lukas Ladenberger and
               Jens Bendisposto and
               Michael Leuschel},
  title     = {Visualising Event-B Models with B-Motion Studio},
  booktitle = {Proceedings of FMICS 2009},
  year      = {2009},
  pages     = {202-204},
  editor    = {Mar\'{\i}a Alpuente and
               Byron Cook and
               Christophe Joubert},
  publisher = {Springer},
  series    = {Lecture Notes in Computer Science},
  volume    = {5825},
  year      = {2009},
  isbn      = {978-3-642-04569-1},
  stupskeywords={prob},

  abstract   = {B-MotionStudio provides a way to quickly generate domain specific
    visualisations for a formal model,
    enabling domain experts and managers to understand and validate the
    model.
    We also believe that our tool will be of use when teaching formal
    methods, both during lectures as a way to motivate
    students to write their own formal models.},
   stupsfile  = {http://www.stups.uni-duesseldorf.de/publications/BMotionStudio.pdf},
}
@article{AbBuHaHoMeVo09_272,
  author     = {Jean-Raymond Abrial and Michael Butler and Stefan Hallerstede and Thai
                Son Hoang and Farhad Mehta and Laurent Voisin},
  title      = {{Rodin}: An Open Toolset for Modelling and Reasoning in {Event-B}},
  journal    = {Software Tools for Technology Transfer},
  abstract   = {Event-B is a formal method for system-level modelling and
    analysis.  Key features of Event-B are the use of
    set theory as a modelling notation, the use of refinement to
    represent systems at different abstraction levels and the use of
    mathematical proof to verify consistency between refinement
    levels.   In this article we present the Rodin modelling tool that
    seamlessly integrates modelling and proving.
    We outline how the Event-B language was designed to facilitate proof
    and how the tool has been designed to support changes to models
    while minimising the impact of changes on existing proofs.
    We outline the important features of the prover architecture and
    explain how well-definedness is treated.
    The tool is extensible and configurable so that it can
    be adapted more easily to different application domains and
    development methods.},
  year       = {2009},
  dbslinks = {[http://eprints.ecs.soton.ac.uk/21058/|PDF]},
}
@article{Ha09_271,
  author     = {Stefan Hallerstede},
  title      = {On the Purpose of {Event-B} Proof Obligations},
  journal    = {Formal Aspects of Computing},
  abstract   = {Event-B is a formal modelling method which is claimed to be suitable
    for diverse modelling domains, such as reactive systems and sequential
    program development. This claim hinges on the fact that any particular
    model has an appropriate semantics. In Event-B this semantics is
    provided implicitly by proof obligations associated with a model.
    There is no fixed semantics though. In this article we argue that this
    approach is beneficial to modelling because we can use similar proof
    obligations across a variety of modelling domains. By way of two
    examples we show how similar proof obligations are linked to different
    semantics.  A small set of proof obligations is thus suitable for a
    whole range of modelling problems in diverse modelling domains.},
  publisher  = {Springer-Verlag},
  year       = {2009},
}
@inproceedings{HaLe09_277,
  author     = {Stefan Hallerstede and Michael Leuschel},
  title      = {How to explain mistakes},
  booktitle  = {TFM 2009},
  abstract   = {Usually we teach formal methods relying for a large part on one kind
    of reasoning technique about a formal model. For instance, we either
    use formal proof or we use model-checking. It would appear that it is
    already hard enough to learn one technique and having to cope with two
    puts just another burden on the students. This is not our experience.
    Especially model-checking is easily used to complement formal proof.
    It only relies on an intuitive operational understanding of a formal
    model.

    In this article we show how using model-checking, animation, and
    formal proof together can be used to improve understanding of formal
    models. We demonstrate how animation can help finding an explanation
    for a failing proof. We also demonstrate where animation or
    model-checking may not help and where proving may not help. For most
    part use of another tool pays off. Proof obligations present
    intentionally a static view of a system so that we focus on abstract
    properties of a model and not on its behaviour. By contrast
    model-checking provides a more dynamic view based on an operational
    interpretation. Both views are valuable aids to reasoning about a
    model.},
  publisher  = {Springer-Verlag},
  series     = {Lecture Notes in Computer Science},
  pages      = {105--124},
  year       = {2009},
}
@inproceedings{Ha09_280,
  author     = {Stefan Hallerstede},
  title      = {How to make mistakes},
  booktitle  = {TFM-B 2009},
  abstract   = {When teaching Event-B to beginners, we usually start with models that
    are already good enough, demonstrating occasionally some standard
    techniques like ``invariant strengthening''. We show that we got it
    essentially right but need to make improvements here and there.
    However, this is not how we really create formal models. To a
    beginner, getting shown only nearly perfect models is overwhelming. So
    we should start earlier and show how we usually get models wrong
    initially. This provides ample opportunity to demonstrate the
    strengths of formal reasoning (and the weaknesses). The principal
    strength of formal reasoning lies in its capacity to locate mistakes
    in a model and to suggest corrections. A beginner should learn how to
    profit from his mistakes by improving his understanding of the model.
    A weakness of formal reasoning is that we only find mistakes that we
    expect, for example, invariant violation or non-termination. Mistakes
    that do not fall into one of these categories may slip through.

    In this article we present how a formal model is created by refinement
    and alteration. The approach employs mathematical methodology for
    problem solving and a software tool. Both aspects are important.
    Mathematical methodology provides ways to turn mistakes into
    improvements. The software tool is necessary to ease the impact of
    changes on a model and to obtain rapid feed back. We begin with a set
    of assumptions and requirements, the problem, and set out to solve it,
    giving a more vivid picture of how formal methods work.},
  publisher  = {University of Nantes},
  pages      = {93--108},
  year       = {2009},
}
@inproceedings{Ha09_290,
  author     = {Stefan Hallerstede},
  title      = {Proving {Quicksort} correct in {Event-B}},
  booktitle    = {Refine 2009},
  journal      = {ENTCS},
  abstract   = {The Event-B method can be used to model all sorts of discrete event
    systems, among them sequential programs. We have made the experience
    that the minimalist nature of Event-B is of advantage when it comes to
    tool support and to using proof as a means to analyse a model. The
    downside of the minimalism is that when models get more complex the
    lack of structure in the models can make them cluttered with auxiliary
    variables. System decomposition will not solve this problem. This can
    not be reasonably applied to a sequential program.

    In this article we describe our experiences with using Event-B by way
    of an example. We show how we verified iterative Quicksort in Event-B
    and intersperse our observations and criticisms. We use them to
    formulate some suggestions of how we believe Event-B should evolve in
    future. Some of the minimalism may have to be abandoned in favour of
    more clarity of the produced formal models.},
  series     = {ENTCS},
  year       = {2009},
}
@inproceedings{Ha09_291,
  author     = {Stefan Hallerstede},
  title      = {A (Small) Improvement of {Event-B}?},
  booktitle  = {Proceedings of Dagstuhl Seminar on Refinement Based Methods for the
                Construction of Dependable Systems (09381)},
  abstract   = {Event-B and the Rodin tool use a number of simple techniques that make
    the modelling method around them effective in practical applications.
    We present two of these techniques, anticipation and witnesses. It is
    interesting how a couple of very simple techniques are so important
    for the method to work. Finally we propose a small enhancement of
    Event-B that would extend the use of witnesses.},
  year       = {2009},
}
@inproceedings{SaWiBeLe09_307,
  author     = {Mireille Samia and Harald Wiegard and Jens Bendisposto and Michael
                Leuschel},
  title      = {High-Level versus Low-Level Specifications: Comparing {B} with {Promela}
                and {ProB} with {Spin}},
  booktitle  = {Proceedings TFM-B 2009},
  abstract   = {During previous teaching and research experience, we have accumulated
    anecdotal evidence that using
    a high-level formalism such as B can be much more productive than
    using a low-level formalism such as Promela.
    Furthermore, quite surprisingly, it turned out that the use of a
    high-level model checker such as prob, was much more
    effective in practice than using a very efficient model checker such
    as spin on the corresponding low-level model.

    In this paper, we try to put this anecdotal evidence on a more firm
    empirical footing, by systematically comparing
    the development and validation of B models with the development and
    validation corresponding Promela models.
    These experiments have confirmed our previous experience, and
    show the merits of using a high-level specification language such as
    B, both in a teaching and in a research environment.},
  editor     = {Attiogbe and Mery },
  publisher  = {APCB},
  month      = {June},
  ISBN       = {2951246102},
  year       = {2009},
  stupsfile  = {http://www.stups.uni-duesseldorf.de/publications/nantes09.pdf},
}
@misc{pdmc09,
author={Jens Bendisposto and Michael Leuschel},
title={Parallel Model Checking of Event-B Specification with ProB},
year       = {2009},
howpublished = {Work in Progress Report at PDMC 2009},
note = {http://www.pdmc.cz/PDMC09/accepted-papers.shtml},
}

@inproceedings{LeuschelTamaritVidal_WFLP09,
  author = {Michael Leuschel and Salvador Tamarit and Germ\'an Vidal},
  title = {Fast and Accurate Strong Termination Analysis with an Application to Partial Evaluation},
  year = 2010,
   BOOKTITLE = {Proceedings WFLP'2009},
  PUBLISHER = {Springer-Verlag},
   series = {LNCS 5979},
   pages = {111--127},
   editor = {Santiago Escobar},
}




@inproceedings{abz-HaLePl2010,
  author = {Stefan Hallerstede and Michael Leuschel and Daniel Plagge},
  title = {Refinement-Animation for {Event-B} - Towards a Method of Validation},
  booktitle = {Proceedings ABZ'2010},
  abstract = {We provide a detailed description of refinement in Event-B, both as a contribution in itself and as a foundation for the approach to simultaneous animation of multiple levels of refinement that we propose.
     We present an algorithm for simultaneous multi-level animation of refinement, and show how it can be used to detect a variety of errors that occur frequently when using refinement.
    The algorithm has been implemented in ProB and we applied it to several case studies, showing that multi-level animation is tractable also on larger models.},
  publisher = {Springer-Verlag},
  series = {Lecture Notes in Computer Science},
  volume = {5977},
  pages  = {287--301},
  year   = {2010},
  dbslinks  = {[http://dx.doi.org/10.1007/978-3-642-11811-1_22|Online Version]},
  stupskeywords={prob},
}
@inproceedings{TuBuLe2010,
  author    = {Edd Turner and Michael Butler and Michael Leuschel},
  title     = {A Refinement-Based Correctness Proof of Symmetry Reduced Model Checking},
  booktitle = {Proceedings ABZ'2010},
  abstract  = {Symmetry reduction is a model checking technique that can help alleviate the problem of state space explosion, by preventing redundant state space exploration. In previous work, we have developed three effective approaches to symmetry reduction for B that have been implemented into the ProB model checker, and we have proved the soundness of our state symmetries. However, it is also important to show our techniques are sound with respect to standard model checking, at the algorithmic level. In this paper, we present a retrospective B development that addresses this issue through a series of B refinements. This work also demonstrates the valuable insights into a system that can be gained through formal modelling.},
  publisher = {Springer-Verlag},
  series    = {Lecture Notes in Computer Science},
  volume    = {5977},
  isbn      = {978-3-642-11810-4},
  pages     = {231--244},
  year      = {2010},
  dbslinks  = {[http://dx.doi.org/10.1007/978-3-642-11811-1_18|Online Version]},
  stupskeywords={prob},
}
@inproceedings{abz-Ha2010,
  author = {Stefan Hallerstede},
  title = {Structured {Event-B} Models and Proofs},
  booktitle = {ABZ 2010},
  abstract = {Event-B does not provide specific support for the modelling of problems that require some structuring, such as, local variables or sequential ordering of events. All variables need to be declared globally and sequential ordering of events can only be achieved by abstract program counters. This has two unfortunate consequences: such models become less comprehensible - we have to infer sequential ordering from the use of program counters; proof obligation generation does not consider ordering - generating too many proof obligations (although these are usually trivially discharged).
    In this article we propose a method for specifying structured models avoiding, in particular, the use of abstract program counters. It uses a notation that mainly serves to drive proof obligation generation. However, the notation also describes the structure of a model explicitly. A corresponding graphical notation is introduced that visualises the structure of a model.},
  publisher = {Springer-Verlag},
  series = {Lecture Notes in Computer Science},
  year = {2010},
}
@article{PlLe2010,
  author = {Daniel Plagge and Michael Leuschel},
  title = {Seven at one stroke: {LTL} model checking for High-level Specifications in {B}, {Z}, {CSP}, and more},
  journal = {Software Tools for Technology Transfer (STTT)},
  volume = {12},
  number = {1},
  abstract = {The size of formal models is steadily increasing and there is a demand from industrial users to be able to use expressive temporal query languages for validating and exploring high-level formal specifications. We present an extension of LTL, which is well adapted for validating B, Z and CSP specifications. We present a generic, flexible LTL model checker, implemented inside the ProB tool, that can be applied to a multitude of formalisms such as B, Z, CSP, B CSP, as well as Object Petri nets, compensating CSP, and dSL. Our algorithm can deal with deadlock states, partially explored state spaces, past operators, and can be combined with existing symmetry reduction techniques of ProB. We establish correctness of our algorithm in general, as well as combined with symmetry reduction. Finally, we present various applications and empirical results of our tool, showing that it can be applied successfully in practice.},
  publisher = {Springer-Verlag},
  month = {Feb},
  ISSN = {1433-2779},
  pages = {9--21},
  year = {2010},
  dbslinks  = {[http://dx.doi.org/10.1007/s10009-009-0132-3|Online Version]},
  stupskeywords={prob},
}
@article{LeMa2010,
  author   = {Michael Leuschel and Thierry Massart},
  title    = {Efficient Approximate Verification of {B} via Symmetry Markers},
  journal  = {Annals of Mathematics and Artificial Intelligence},
  volume   = {59},
  number   = {1},
  abstract = {We present a new approximate verification technique for
   falsifying the invariants of B models. The technique employs symmetry of B
   models induced by the use of deferred sets. The basic idea is to efficiently
   compute markers for states, so that symmetric states are guaranteed to have
   the same marker (but not the other way around).<br/>
    The falsification algorithm then assumes that two states with the same
   marker can be considered symmetric. We describe how symmetry markers can be
   efficiently computed and empirically evaluate an implementation, showing
   both very good performance results and a high degree of precision (i.e.,
   very few non-symmetric states receive the same marker).<br/>
    We also identify a class of B models for which the technique is precise
   and therefore provides an efficient and complete verification method.
   Finally, we show that the technique can be applied to Z models as well.},
  pages    = {81--106},
  year     = {2010},
  dbslinks  = {[http://dx.doi.org/10.1007/s10472-010-9208-8|Online Version]},
  stupskeywords={prob},
 }
@inproceedings{BoLeSch2010,
  author = {Carl Friedrich Bolz and Michael Leuschel and David Schneider},
  title = {Towards a Jitting {VM} for Prolog Execution},
  booktitle = {PPDP '10 - Proceedings of the 12th international ACM SIGPLAN symposium on Principles and practice of declarative programming},
  abstract = {Most Prolog implementations are implemented in low-level languages such as C and are based on a variation of the WAM instruction set, which enhances their performance but makes them hard to write. We present a high-level continuation-based Prolog interpreter written in RPython, a restricted subset of Python. This interpreter is annotated with hints, so that it can be fed through the PyPy tracing JIT generator, which incorporates partial evaluation techniques.  The resulting Prolog implementation is surprisingly efficient: it clearly outperforms existing implementations of Prolog in high-level languages such as Java. Moreover, on some benchmarks, our system outperforms state-of-the-art WAM-based Prolog implementations. Our paper tries to show that PyPy can indeed form the basis for implementing programming languages other than Python. Furthermore, we believe that our results showcase the great potential of the tracing JIT approach for declarative programming languages},
  year = {2010},
  publisher = {ACM},
  address = {Hagenberg, Austria},
  dbslinks  = {[http://doi.acm.org/10.1145/1836089.1836102|Online Version]},
}
@inproceedings{SchBoLe2010,
  author = {David Schneider and Carl Friedrich Bolz and Michael Leuschel},
  title = {Jitting Prolog for Fun and Profit},
  booktitle = {DYLA 2010 - 4th Workshop on Dynamic Languages and Applications},
  year = {2010},
  address = {Málaga, Spain},
}
@inproceedings{LeBe2010,
  author   = {Michael Leuschel and Jens Bendisposto},
  title    = {Directed Model Checking for {B}: An Evaluation and New Techniques},
  abstract = {ProB is a model checker for high-level formalisms such as B, Event-B, CSP and Z. ProB uses a mixed depth-first/breadth-first search strategy, and in previous work we have argued that this can perform better in practice than  pure depth-first or breadth-first search, as employed by low-level model checkers.
    In this paper we present a thorough empirical evaluation of this technique, which confirms our conjecture. The experiments were conducted on a wide variety of B and Event-B models, including several industrial case studies.
    Furthermore, we have extended ProB to be able to perform directed model checking, where each state is associated with a priority computed by a heuristic function. We evaluate various heuristic functions, on a series of problems, and find some interesting candidates for detecting deadlocks and finding specific target states.},
  booktitle = {SBMF'2010},
  series    = {Lecture Notes in Computer Science},
  volume    = {6527},
  editor    = {Jim Davies and Leila Silva and Adenilso da Silva Sim{\~a}o},
  publisher = {Springer},
  pages     = {1--16},
  year      = {2010},
  dbslinks  = {[http://www.stups.uni-duesseldorf.de/models/sbmf2010|Models]},
  stupskeywords={prob},
}
@article{JastramProR2010,
  author = {Michael Jastram},
  title = {{ProR}, an Open Source Platform for Requirements Engineering based on {RIF}},
  journal = {SEISCONF},
  abstract = {Proper tool support in requirements engineering is important. A number of proprietary solutions are available in the market place, but few open solutions,  and none that are widespread at this time.<br>
    In this paper, we introduce ProR, an open platform for requirements engineering. The project was initiated by the EU FP7 Project ``Deploy'', which has the goal to make major advances in engineering methods for dependable systems through the deployment of formal  engineering methods.  Rather than building a project-specific solution, we decided to develop an extensible, general purpose platform.<br>
    We based the tool's data model on the Requirements Interchange Format (RIF / ReqIF), a standard driven by the automotive industry. This gives us interoperability with a number of existing tools.  The tool is based on the Eclipse Platform and uses the Eclipse Modeling Framework (EMF).  We managed to establish a cooperation with the ITEA-Project ``Verde'', which supplied the
    implementation of the RIF data model.<br>
    In this paper, we will introduce the tool, describe its architecture, and present a small case study.  ProR is still under development, and we welcome contributors and are very interested in potential users to validate our approach.  Please visit www.pror.org for more information, and to download the current development version.},
  year = {2010},
  dbslinks = {[http://www.seisconf.org|SEISCONF Website], [http://pror.org|ProR Website]},
}
@proceedings{avocs2010,
  editor    = {Jens Bendisposto and Michael Leuschel and Markus Roggenbach and
               Stefan Hallerstede and  Michael Butler and  Laurent Voisin},
  title     = {Proceedings of {AVoCS} 2010 and {Rodin} 2010},
  year      = {2010},
  dbslinks  = {[http://www.formal-methods.de/avocs10|AVoCS 2010 Website]},
}
@techreport{gepavas1,
  author    = {Jens Bendisposto and Michael Leuschel and Markus Borgermans},
  title     = {{GEPAVAS} Gerichtete und parallele Validierung von abstrakten Spezifikationen - Projektreport},
  year      = {2010},
institution = {University of D\"usseldorf},
}





@article{LeFaFrPl2011,
  author = {Michael Leuschel and Jérôme Falampin and Fabian Fritz and Daniel Plagge},
  title = {Automated Property Verification for Large Scale {B} Models with {ProB}},
  journal = {Formal Aspects of Computing},
  abstract = {In this paper we describe the successful application of the ProB
    validation tool for several industrial applications. The initial case study
    centred on the San Juan metro system installed by Siemens. The control
    software was developed and formally proven with B. However, the development
    contains certain assumptions about the actual rail network topology which
    have to be validated separately in order to ensure safe operation. For this
    task, Siemens has developed custom proof rules for Atelier B. Atelier B,
    however, was unable to deal with about 80 properties of the deployment
    (running out of memory). These properties thus had to be validated by hand
    at great expense (and they need to be revalidated whenever the rail network
    infrastructure changes).<br/>

    In this paper we show how we were able to use ProB to validate all of the
    about 300 properties of the San Juan deployment, detecting exactly the same
    faults automatically in a few minutes that were manually uncovered in about
    one man-month. We have repeated this task for three ongoing projects at
    Siemens, notably the ongoing automatisation of the line 1 of the Paris
    Metro. Here again, about a man month of effort has been replaced by a few
    minutes of computation.<br/>

    This achievement required the extension of the ProB kernel for large sets
    as well as an improved constraint propagation phase. We also outline some
    of the effort and features that were required in moving from a tool capable
    of dealing with medium-sized examples towards a tool able to deal with
    actual industrial specifications. We also describe the issue of validating
    ProB, so that it can be integrated into the SIL4 development chain at
    Siemens.},
  volume    = {23},
  number    = {6},
  year      = {2011},
  pages     = {683--709},
  dbslinks = {[http://www.springerlink.com/content/n8ju823630685r15/?MUD=MP|Online Open Access Version]},
  stupskeywords = {prob},
}
@article{SPE1016,
  author = {Bendisposto, Jens and Fritz, Fabian and Jastram, Michael and Leuschel, Michael and Weigelt, Ingo},
  title = {Developing {Camille}, a text editor for {Rodin}},
  journal = {Software: Practice and Experience},
  volume = {41},
  number = {2},
  publisher = {John Wiley & Sons, Ltd.},
  issn = {1097-024X},
  url = {http://dx.doi.org/10.1002/spe.1016},
  doi = {10.1002/spe.1016},
  pages = {189--198},
  dbslinks = {[http://onlinelibrary.wiley.com/doi/10.1002/spe.1016/abstract|Online Version]},
  keywords = {formal methods, Event-B, tools, Rodin},
  year = {2011},
  abstract = {Initially, the Rodin platform for Event-B did away with a textual representation for models. In this paper, we explain why a textual representation was required after all and we present the semantic-aware text editor Camille for Rodin. We explain the design choices of Camille, such as splitting the syntax into two-levels for machine and formula syntax. We also describe the challenges, such as synchronizing the textual representation with the Rodin database, and how they were overcome using an EMF abstraction layer.},
}
@techreport{tr-JaGr2011,
  author = {Michael Jastram and Andreas Graf},
  title = {Requirements, Traceability and {DSLs} in {Eclipse} with the Requirements Interchange Format ({RIF/ReqIF})},
  institution = {Dagstuhl-Workshop MBEES 2011: Modellbasierte Entwicklung eingebetteter Systeme},
  abstract = {Requirements engineering (RE) is a crucial aspect in systems development and is the area of ongoing research and process improvement. However, unlike in modelling, there has been no established standard that activities could converge on.<br>
   In recent years, the emerging Requirements Interchange Format (RIF/ReqIF) gained more and more visibility in industry, and research projects start to investigate these standards. To avoid redundant efforts in implementing the standard, the VERDE and Deploy projects cooperate to provide a stable common basis for RIF/ReqIF that could be leveraged by other research projects too.  In this paper, we present an Eclipse-based extensible implementation of a RIF/ReqIF-based requirements editing platform.<br>
   In addition, we are concerned with two related aspects of RE that take advantage of the common platform.  First, how can the quality of requirements be improved by replacing or complementing natural language requirements with formal approaches such as domain specific languages or models.  Second, how can we establish robust traceability that links  requirements and model constructs and other artefacts of the development process.  We present two approaches to traceability and two approaches to modelling.<br>
   We believe that our research represents a significant contribution to the existing tooling landscape, as it is the first clean-room implementation of the RIF/ReqIF standard.  We believe that it will help reduce gaps in often heterogeneous tool chains and inspire new conceptual work and new tools.},
  year = {2011},
}
@article{topcase-JaGr2011,
  author = {Michael Jastram and Andreas Graf},
  title = {Requirement Traceability in {Topcased} with the Requirements Interchange Format ({RIF}/{ReqIF})},
  journal = {First Topcased Days Toulouse},
  abstract = {One important step of the systems engineering process is requirements engineering. Parallel to the development of Topcased, which includes tooling for requirements engineering, a new standard for requirements exchange is emerging at the OMG under the name “ReqIF” (formally called RIF). In our talk we introduce the activities of two research projects and their tool developments, VERDE (Yakindu Requirements) and Deploy (ProR) and discuss possible synergies with Topcased.},
  year = {2011},
  dbslinks = {[http://www.topcased.org/index.php/content/view/53|Topcased Days], [http://pror.org|ProR Website]},
}
@inproceedings{flow2011,
  author = {Jens Bendisposto and Michael Leuschel},
  title = {Automatic Flow Analysis for {Event-B}},
  booktitle = {Proceedings of Fundamental Approaches to Software Engineering (FASE) 2011},
  abstract = {In Event-B a system is developed using refinement. The language is based on a relatively small core; in particular there is only a very small number of substitutions. This results in much simpler proof obligations, that can be handled by automatic tools. However, the downside is that, in case of software development, structural information is not explicitly available but hidden in the chain of refinements. This paper discusses a method to uncover these implicit algorithmic structures and use them in a model checker. Other applications are code generation, model comprehension, and testcase generation.},
  editor = {Dimitra Giannakopoulou and Fernando Orejas},
  publisher = {Springer},
  series = {Lecture Notes in Computer Science},
  volume = {6603},
  ISBN = {3642198104},
  pages = {50--64},
  year = {2011},
  stupskeywords = {prob},

}
@article{HaLe2011,
  author    = {Stefan Hallerstede and Michael Leuschel},
  title     = {Constraint-Based Deadlock Checking of High-Level Specifications},
  booktitle = {Proceedings ICLP'2011},
  abstract  = {Establishing the absence of deadlocks is important in many
    applications of formal methods. The use of model checking for finding
    deadlocks in formal models is limited because in many industrial
    applications the state space is either infinite or much too large to be
    explored exhaustively.<br/>
    In this paper we propose a constraint-based approach to finding deadlocks
    employing  the ProB constraint solver to find values for the constants
    and variables of formal models that describe a deadlocking state. We
    present the general technique, as well as various improvements that had to
    be performed on ProB's Prolog kernel, such as reification of membership and
    arithmetic constraints.<br/>
    ProB typically finds counter examples to deadlock-freedom constraints,
    a formula of about 900 partly nested conjunctions and disjunction
    among them 80 arithmetic and 150 set-theoretic predicates
    (in total a formula of 30 pages), in under two seconds.<br/>
    We also present other successful applications of this new technique,
    in particular to BPEL processes. Experiments using SAT and SMT solvers
    on these constraints were thus far unsuccessful.},
  publisher = {Cambridge University Press},
  year      = {2011},
  stupsfile = {http://www.stups.uni-duesseldorf.de/publications/cbc_deadlock_bosch.pdf},
  journal = {Theory and Practice of Logic Programming},
  volume = {11},
  number = {4--5},
  pages = {767--782},
  dbslinks = {[http://dx.doi.org/10.1017/S1471068411000299|Online Version]},
  stupskeywords = {prob},

}

@inproceedings{HaLeBW2011,
  author = {Stefan Hallerstede and Michael Leuschel},
  title = {Finding Deadlocks of Event-B Models by Constraint Solving},
  booktitle = {B2011 Workshop (short paper)},
  abstract = {Establishing the absence of deadlocks is important in many applications of formal methods.
The use of model checking for finding deadlocks in formal models is limited
because in many industrial applications the state space is either infinite or much too large to be explored exhaustively.
In this paper we propose a constraint-based approach to finding deadlocks employing
the ProB constraint solver to find values for the constants and variables of formal models that
describe a deadlocking state.
We discuss the principles of the technique implemented in ProB's Prolog kernel
and present some results of a larger case study to which we have applied the approach.},
  year      = {2011},
  stupskeywords = {prob},
}

@inproceedings{JaHaLeRu2010,
  author    = {Michael Jastram and Stefan Hallerstede and Michael Leuschel and Aryldo G Russo Jr},
  title     = {An Approach of Requirements Tracing in Formal Refinement},
  booktitle = {VSTTE},
  pages     = {97-111},
  ee        = {http://dx.doi.org/10.1007/978-3-642-15057-9_7},
  abstract = {Formal modeling of computing systems yields models that are intended to be correct with respect to the requirements that have been formalized. The complexity of typical computing systems can be addressed by formal refinement introducing all the necessary details piecemeal. We report on preliminary results that we have obtained for tracing informal natural-language requirements into formal models across refinement levels. The approach uses the WRSPM reference model for requirements modeling, and Event-B for formal modeling and formal refinement. The combined use of WRSPM and Event-B is facilitated by the rudimentary refinement notion of WRSPM, which provides the foundation for tracing requirements to formal refinements.<br>
    We assume that requirements are evolving, meaning that we have to cope with frequent changes of the requirements model and the formal model. Our approach is capable of dealing with frequent changes, making use of corresponding techniques already built into the Event-B method.},
  publisher = {Springer},
  year      = {2010},
  series    = {Lecture Notes in Computer Science},
  volume    = {6217},
  isbn      = {978-3-642-15056-2},
}
@article{HaLePl2011refanim,
  title    = {Validation of Formal Models by Refinement Animation},
  journal  = {Science of Computer Programming},
  volume   = {78},
  number   = {3},
  pages    = {272--292},
  year     = {2013},
  issn     = {0167-6423},
  doi      = {DOI: 10.1016/j.scico.2011.03.005},
  dbslinks = {[http://www.sciencedirect.com/science/article/pii/S0167642311000918|Article at Science Direct]},
  author = {Stefan Hallerstede and Michael Leuschel and Daniel Plagge},
  abstract = {We provide a detailed description of refinement in Event-B,
    both as a contribution in itself and as a foundation for the approach to
    simultaneous animation of multiple levels of refinement that we propose.
    We present an algorithm for simultaneous multi-level animation of
    refinement, and show how it can be used to detect a variety of errors that
    occur frequently when using refinement. The algorithm has been implemented
    in ProB and we applied it to several case studies, showing that multi-level
    animation is tractable also on larger models. We present empirical results
    and discuss how the algorithm can be combined with symmetry reduction.},
  stupsnote = {Check},
  stupskeywords = {prob},
}

@inproceedings{BoCuFiLePeRi2011,
	address = {Austin, Texas, {USA}},
	title = {Allocation removal by partial evaluation in a tracing {JIT}},
	abstract = {The performance of many dynamic language implementations suffers from high allocation rates and runtime type checks. This makes dynamic languages less applicable to purely algorithmic problems, despite their growing popularity. In this paper we present a simple compiler optimization based on online partial evaluation to remove object allocations and runtime type checks in the context of a tracing {JIT.} We evaluate the optimization using a Python {VM} and find that it gives good results for all our (real-life) benchmarks.},
	booktitle = {{PEPM}},
	author = {Carl Friedrich Bolz and Antonio Cuni and Maciej Fijałkowski and Michael Leuschel and Samuele Pedroni and Armin Rigo},
	year = {2011},
	keywords = {code generation, experimentation, interpreters, languages, optimization, partial evaluation, performance, run-time environments, tracing jit},
},
@article{Jas11,
  author = {Michael Jastram},
  title = {ProR - Eine Softwareplattform für Requirements Engineering},
  journal = {Softwaretechnik-Trends},
  volume = {31},
  number = {1},
  publisher = {Gesellschaft für Informatik (GI)},
  issn = {0720-8928},
  url = {http://pi.informatik.uni-siegen.de/stt/31_1/index.html},
  year = {2011},
  abstract = {Gute Werkzeugunterstützung ist ein wichtiger Aspekt im Requirements Engineering.  Es gibt zwar ein breites kommerzielles Angebot, aber wenige offene Lösungen.  ProR ist eine OpenSource Software zum Arbeiten mit natürlichsprachigen Anforderungen.  Es basiert auf dem Requirements Interchange Format (RIF), womit wir die Interoperabilität mit anderen Werkzeugen gewährleisten. Wir legen großen Wert auf die Erweiterbarkeit der Plattform, was wir mit einem Integrations-Plugin für die formale Event-B-Methode belegen.},
},

@inproceedings{GmehlichGHLLP11,
  author    = {Rainer Gmehlich and
               Katrin Grau and
               Stefan Hallerstede and
               Michael Leuschel and
               Felix L{\"o}sch and
               Daniel Plagge},
  title     = {On Fitting a Formal Method into Practice},
  booktitle = {Proceedings ICFEM'2011},
  editor    = {Shengchao Qin and
               Zongyan Qiu},
  publisher = {Springer},
  series    = {Lecture Notes in Computer Science},
  volume    = {6991},
  year      = {2011},
  isbn      = {978-3-642-24558-9},
  pages     = {195--210},
  abstract  = {The development of the Event-B formal method and the supporting tools
     Rodin and ProB was guided by practical experiences with the B-Method,
     the Z specification notation, VDM and similar practical formal methods.
     The case study discussed in this article -- a cruise control system -- is a
     serious test of industrial use. We report on where Event-B and its tools have
     succeeded, where they have not. We also report on advances that were inspired
     by the case study. Interestingly, the case study was not a pure formal methods
     problem. In addition to Event-B, it used Problem Frames for capturing requirements.
     The interaction between the two proved to be crucial for the success of the case study.
     The heart of the problem was tracing informal requirements from Problem Frames
     descriptions to formal Event-B models. To a large degree, this issue dictated the
     approach that had to be used for formal modelling. A dedicated record theory
     and dedicated tool support were required. The size of the formal models rather
     than complex individual formulas was the main challenge for tool support.},
  stupskeywords={deploy,prob},
}

@inproceedings{BoCuFiLePeRi11,
  author     = {Carl Friedrich Bolz and Antonio Cuni and Maciej Fijałkowski and Michael Leuschel and Samuele Pedroni and Armin Rigo},
  title      = {Runtime Feedback in a Meta-Tracing {JIT} for Efficient Dynamic Languages},
  booktitle = {Proceedings of the 6th workshop on the Implementation, Compilation, Optimization of Object-Oriented Languages and Programming Systems},
  series  = {ICOOOLPS '11},
  abstract   = {Meta-tracing JIT compilers can be applied to a variety of differ- ent languages without explicitly encoding language semantics into the compiler. So far, they lacked a way to give the language im- plementor control over runtime feedback. This restricted their per- formance. In this paper we describe the mechanisms in PyPy’s meta-tracing JIT that can be used to control runtime feedback in language-specific ways. These mechanisms are flexible enough to express classical VM techniques such as maps and runtime type feedback.},
  year       = {2011},
}

@inproceedings{JasHalLad2011,
  author     = {Michael Jastram and Stefan Hallerstede and Lukas Ladenberger},
  title      = {Mixing Formal and Informal Model Elements for Tracing Requirements},
  series  = {AVOCS 2011},
  abstract   = {Tracing between informal requirements and formal models is challenging.
A method for such tracing should permit to deal efficiently with changes to both the requirements and the model.
A particular challenge is posed by the persisting interplay of formal and informal elements. <br>
In this paper, we describe an incremental approach to requirements validation and systems modelling.
Formal modelling facilitates a high degree of automation: it serves for validation and traceability.<br>
The foundation for our approach are requirements that are structured according to the WRSPM reference model.
We provide a system for traceability with a state-based formal method that supports refinement.
We do not require all specification elements to be modelled formally
and support incremental incorporation of new specification elements into the formal model.
Refinement is used to deal with larger amounts of requirements in a structured way.<br>
We provide a small example using Problem Frames and Event-B to demonstrate our approach.
},
  year       = {2011},
  stupskeywords={deploy},
}





@article{abs-1210-6815,
  author    = {Thierry Lecomte and
               Lilian Burdy and
               Michael Leuschel},
  title     = {Formally Checking Large Data Sets in the Railways},
  journal   = {CoRR},
  volume    = {abs/1210.6815},
  booktitle = {Proceedings DS-EventB'2012},
  year      = {2012},
  ee        = {http://arxiv.org/abs/1210.6815},
  stupskeywords={prob},
}

@inproceedings{HansenLeuschelTLA2012,
  author = {Dominik Hansen and Michael Leuschel},
  title = {Translating {TLA+} to {B} for Validation with {ProB}},
  booktitle = {Proceedings iFM'2012},
  series    = {LNCS 7321},
  publisher = {Springer},
  year = 2012,
  pages = {24--38},
  month = June,
  abstract   = {TLA+ and B share the common base of predicate logic, arithmetic and set theory.
However, there are still considerable differences, such as very different approaches to typing and modularization. There is also considerable difference in the available tool support.
In this paper, we present a translation of the non-temporal part of TLA+ to B, which makes it possible to feed TLA+ specifications into existing tools for B.
Part of this translation must include a type inference algorithm, in order to produce typed B specifications. There are many other tricky aspects, such as translating modules as well as let and if-then-else expressions. We also present an integration of our translation into ProB.
ProB thus provides a complementary tool to the explicit state model checker TLC, with convenient animation and constraint solving for TLA+.
We also present a series of case studies, highlighting the complementarity to TLC. In particular, we highlight the sometimes dramatic difference in performance when it comes to solving complicated constraints in TLA+.},
  stupskeywords={advance,prob},
}
@inproceedings{PlaggeLeuschel_Kodkod2012,
  author = {Daniel Plagge and Michael Leuschel},
  title = {Validating {B}, {Z} and {TLA+} using {ProB} and {Kodkod}},
  year = 2012,
  month = August,
  booktitle = {Proceedings FM'2012},
  editor = {Dimitra Giannakopoulou and Dominique M\'{e}ry},
  series    = {LNCS 7436},
  publisher = {Springer},
  year = 2012,
  pages = {372--386},
  abstract   = {We present the integration of the Kodkod high-level interface to SAT-solvers into the kernel of ProB.
As such, predicates from B, Event-B, Z and TLA+ can be solved using a mixture of SAT-solving and ProB's own constraint-solving capabilities developed using constraint logic programming: the first-order parts which can be dealt with by Kodkod and the remaining parts solved by the existing ProB kernel.
We also present an extensive empirical evaluation and analyze the respective merits of SAT-solving and classical constraint solving.
We also compare to using SMT solvers via recently available translators for Event-B.},
  stupskeywords={advance,prob},
}
@unpublished{LadenbergerJastram_iFMABZ2012,
  author = {Lukas Ladenberger and Michael Jastram},
  title = {Requirements Traceability between Textual Requirements and Formal Models Using ProR},
  note = {Accepted for iFM'2012},
  year = 2012,
  month = June,
  abstract   = {<p>Traceability within a system description is a challenging problem of requirements engineering. In particular, formal models of the system are often based on informal requirements, but creating and maintaining the traceability between the two can be challenging. Previously, we presented an incremental approach for producing a system description from an initial set of requirements. The foundation of the approach is a classification of requirements into artefacts W (domain properties), R (requirements) and S (specification). In addition, the approach uses designated phenomena as the vocabulary employed by the artefacts. The central idea is that adequacy of the system description must be justified, meaning that W /\ S => R. The approach establishes a traceability, and the resulting system description may consist of formal and informal artefacts.</p><p>We created tool support for this approach by integrating Rodin and ProR ...</p>},
}
@techreport{Weigelt2012,
  author = {Ingo Weigelt},
  title = {Architectures for an Extensible Text Editor for Rodin},
  year = 2012,
  month = April,
  institution = {University of Düsseldorf},
  stupskeywords={advance},
  abstract   = {<p>Rodin is a platform for Event-B modelling.  Its native editor is a structural editor that allows the modification of a tree-like model.</p>

<p>Especially for large models, some users found the default editor inadequate and preferred a text-based editor.  Such an editor, called Camille, was created by Fabian Fritz in 2009 and was a huge success.</p>

<p>Nevertheless, Camille does not directly support extensions for Rodin.  As more and more extensions are being created, this became a larger issue over the years.</p>

<p>This report analyses how Camille extensibility can be achieved.  It analyses a number of different architectures and compares their mutual advantages and disadvantages.</p>

<p>This paper discusses four different approaches.  Out of these, we find two particularly promising.  The first option would be the implementation of a block parser  that provides a useful default implementation for plug-in developers and a pleasing syntax to editor users.  The second option is the use of an existing syntax like YAML.  This solution could be extended all the way to the persistence layer of Rodin, thereby simplifying the back end significantly.  But such an effort would require additional resources.  Nevertheless, the result would simplify maintenance of the platform significantly in the long run.</p>},
}
@techreport{tr-JaGr2012,
  author     = {Michael Jastram and Andreas Graf},
  title      = {ReqIF – the new Requirements Standard and its Open Source implementation Eclipse RMF},
  institution = {Commercial Vehicle Technology Symposium},
  year       = {2012},
}

@inproceedings{schneider_efficient_2012,
	title = {The Efficient Handling of Guards in the Design of {RPython’s} Tracing {JIT}},
	booktitle = {VMIL, accepted for publication},
	author = {Schneider, David and Bolz, Carl Friedrich},
	year = {2012},
        abstract = {Tracing just-in-time (JIT) compilers record linear control flow paths, inserting operations called guards at points of possible divergence. These operations occur frequently in generated traces and therefore it is important to design and implement them carefully to find the right trade-off between deoptimization, memory overhead, and (partly) execution speed. In this paper, we perform an empirical analysis of runtime properties of guards. This is used to guide the design of guards in the RPython tracing JIT.},
}


@book{jastram-thesis-2012,
  author     = {Michael Jastram},
  title      = {The ProR Approach: Traceability of Requirements and System Descriptions},
  publisher = {CreateSpace},
  institution = {Heinrich-Heine University Dusseldorf},
  year       = {2012},
  series = {Inaugural-Dissertation},
  stupskeywords={advance},
  abstract = {
<p>Creating a system description of high quality is still a challenging problem in the field of requirements engineering.  Creating a formal system description addresses some issues. However, the relationship of the formal model to the user requirements is rarely clear, or documented satisfactorily.</p>

<p>This work presents the ProR approach, an approach for the creation of a consistent system description from an initial set of requirements. The resulting system description is a mixture of formal and informal artefacts.  Formal and informal reasoning is employed to aid in the process.    To achieve this, the artefacts must be connected by traces to support formal and informal reasoning, so that conclusions about the system description can be drawn.</p>

<p>The ProR approach enables the incremental creation of the system description, alternating between modelling (both formal and informal) and validation.  During this process, the necessary traceability for reasoning about the system description is established.  The formal model employs refinement for further structuring of large and complex system descriptions.  The development of the ProR approach is the first contribution of this work.</p>

<p>This work also presents ProR, a tool platform for requirements engineering, that supports the ProR approach. ProR has been integrated with Rodin, a tool for Event-B modelling, to provide a number of features that allow the ProR approach to scale.</p>

<p>The core features of ProR are independent from the ProR approach.  The data model of ProR builds on the international ReqIF standard, which provides interoperability with industrial tools for requirements engineering.  The development of ProR created enough interest to justify the creation of the Requirements Modeling Framework (RMF), a new Eclipse Foundation project, which is the open source host for ProR.  RMF attracted an active community, and ProR development continues.  The development of ProR is the second contribution of this work.</p>

<p>This work is accompanied by a case study of a traffic light system, which demonstrates the application of both the ProR approach and ProR.</p>
},
}

@inproceedings{ebert_jastram_reqif_2012,
	title = {{ReqIF: Seamless Requirements Interchange Format between Business Partners}},
	booktitle = {{IEEE Software}},
	author = {Christof Ebert, Michael Jastram},
	month = oct,
	year = {2012},
        pages = {82--87},
        abstract = {
The primary sources of project risks and product problems are poor,
missing, or changing requirements. Often, the underlying root cause
is insufficient collaboration between business partners. This article
provides insight into how to effectively collaborate in requirements
engineering. We describe the Requirements Interchange Format
(ReqIF) standard and technologies for seamless requirements
development and management. We look forward to hearing from
both readers and prospective column authors about this and the
technologies and tools you want to know more about.}
}

@inproceedings{ardo_loop-aware_2012,
	title = {Loop-Aware Optimizations in {PyPy’s} Tracing {JIT}},
	booktitle = {{DLS}},
	author = {Ardö, Håkan and Bolz, Carl Friedrich and Fijałkowski, Maciej},
	month = oct,
	year = {2012},
	note = {Accepted for publication},
        abstract = {
<p>One of the nice properties of a tracing just-in-time compiler (JIT) is that many of its optimizations are simple, requiring one forward pass only. This is not true for loop-invariant code motion which is a very important optimization for code with tight kernels. Especially for dynamic languages that typically perform quite a lot of loop invariant type checking, boxed value unwrapping and virtual method lookups.</p>

<p>In this paper we explain a scheme pioneered within the context of the LuaJIT project for making basic optimizations loop-aware by using a simple pre-processing step on the trace without changing the optimizations themselves.</p>

<p>We have implemented the scheme in RPython's tracing JIT compiler. PyPy's Python JIT executing simple numerical kernels can become up to two times faster, bringing the performance into the ballpark of static language compilers.</p>}
}

@inproceedings{jastram_forms_2012,
	title = {{A Systems Engineering Tool Chain Based on Eclipse and Rodin}},
	booktitle = {{Forms/Format}},
	author = {Michael Jastram},
	month = Nov,
	year = {2012},
        abstract = {
<p>Formal methods are experiencing a renaissance, especially in the development of safety-critical systems.  An indicator for this is the fact that more and more standards either recommend or prescribe the use of formal methods.
</p><p>
Using formal methods on an industrial scale requires their integration into the system engineering process.  This paper is exploring how an integrated tool chain that supports formal methods may look like.  It thereby focusses on our experience with tool chains that are based on the open source Eclipse platform in general, and the Rodin formal modeling environment in particular.
</p><p>
Open Source allows organisations to remedy the risk of being dependent on one single vendor.  This includes the risk of the feature set provided: users can add missing features themselves or commission their inclusion to any competent party, rather than having to rely on the vendor to implement it.  It further includes the risk of maintenance and long-term support.
</p><p>
We see industrial interest in open source for systems engineering in general, and Eclipse in particular.  Eclipse is attractive, because its license is business-friendly.  Further, its modular architecture makes it easy to seamlessly integrate the various Eclipse-based tools for systems engineering.
</p><p>
This paper focuses on an ecosystem that is accumulated around two Eclipse-based platforms,  First, the Rodin platform is an open source modeling environment for the Event-B formalism.  Second, the Requirements Modeling Framework (RMF) is a platform for working with natural language requirements, supporting the international ReqIF standard.</p>
}
}





@inproceedings{RodinWorkshop2013Tutorial,
  author = {Jens Bendisposto and Joy Clark and Ivaylo Dobrikov and Philipp Körner and Sebastian Krings and Lukas Ladenberger and Michael Leuschel and Daniel Plagge},
  title = {ProB 2.0 Tutorial},
  booktitle = {Proceedings of the 4th Rodin User and Developer Workshop},
  series    = {TUCS Lecture Notes},
  publisher = {TUCS},
  year = 2013,
  abstract   = {We believe that any proof centric formal method must be complemented by animation and visualization to be useful because there are always properties of a model that cannot be covered by proof. In particular a proof can guarantee that a model is internally consistent but it cannot guarantee that this model is actually what its designer had in mind. Animation and visualization can help to review models. ProB is a mature toolset1 that supports a whole range of different formalisms such as classical B, Event-B, CSP and Z.},
  stupskeywords={advance,prob},
  url = {  http://stups.hhu.de/ProB/index.php5/Tutorial13},
}

@inproceedings{RodinWorkshop2013Parallel,
  author = {Jens Bendisposto and Philipp Körner and Michael Leuschel},
  title = {Parallel Model Checking of B Specifications},
  booktitle = {Proceedings of the 4th Rodin User and Developer Workshop},
  series    = {TUCS Lecture Notes},
  publisher = {TUCS},
  year = 2013,
  abstract   = {Model checking of a specification using ProB can easily become a task with a long running time. However, the task can very easily be parallelized. If we had a transition system (the state space) and an invariant we could partition the vertices of the state space into k partitions of equal size and then check the invariant on k processors in parallel. However, in reality we cannot afford to precompute the state space in advance. We need to explore the state space itself in parallel. This imposes some challenges that the implementation has to address. Firstly, we have to avoid duplicated invariant checking or at least make sure that duplicate invariant checking does not happen too often in practice. Also in contrast to an offline algorithm, the online version cannot split up the workload fairly. This reduces the scalability of the approach. In particular, the scalability depends on the model. For example, let us consider a counter specification that has an integer variable x ranging from zero to a billion. The variable is initialized with the value zero, and the model has a single event that increments x by one. Assuming that we have k processors, the offline version can easily partition the state space and ensure that every processor gets the same amount of work. For instance, it can decide to use x mod k to determine the processor for a state. The online algorithm has only a limited sight. It processes only one state at a time because each state has a single successor state.},
  stupskeywords={advance,prob},
}

@inproceedings{RodinWorkshop2013CBC,
  author = {Sebastian Krings and Jens Bendisposto and Ivaylo Dobrikov and Michael Leuschel},
  title = {B constrained},
  booktitle = {Proceedings of the 4th Rodin User and Developer Workshop},
  series    = {TUCS Lecture Notes},
  publisher = {TUCS},
  year = 2013,
  abstract   = {In a previous work, we applied constraint solving techniques to problems like invariant preservation and deadlock freedom checking [2]. The idea behind constraint based deadlock checking is that we set up a logical formula encoding a state where the invariant holds, but all guards are false. We then use the built-in constraint solver to check if the formula has a model. If we can find such a model, we know that the system cannot be proven to be deadlock free. The invariant preservation checking is similar. We encode a state where the invariant holds and a successor state (for some event) where the invariant is false. If this formula has a model, we know that the system cannot be proven correctly. Note that in both cases we do not require that the states are reachable. The system might behave correctly, but the invariant is too weak to prove its correctness.},
  stupskeywords={advance,prob},
}

@inproceedings{KringsLeuschelUnits,
  author = {Sebastian Krings and Michael Leuschel},
  title = {Inferring Physical Units in {B} Models},
  booktitle = {Proceedings SEFM'2013},
  series    = {LNCS 8137},
  pages  ={137--151},
  publisher = {Springer},
  year = 2013,
  abstract   = {Most state-based formal methods, like B, Event-B or Z, provide support for static typing.
However, these methods and the associated tools lack support for annotating variables with (physical) units of measurement.
There is thus no obvious way to reason about correct or incorrect usage of such units.
In this paper we present a technique that analyses the usage of physical units throughout a B machine, infers missing units and notifies the user of incorrectly handled units.
The technique combines abstract interpretation with classical animation and model checking and
 has been integrated into the ProB validation tool, both for classical B and for Event-B. It provides source-level feedback about errors detected in the models.
The plugin uses a combination of abstract interpretation and constraint solving techniques.
We provide an empirical evaluation of our technique, and demonstrate that it scales up to real-life industrial models.
},
  stupskeywords={advance,prob},
}

@inproceedings{RMF_Mark_Book_Jastram_2013,
   booktitle = {{Managing Requirements Knowledge}},
   title = {{The Eclipse Requirements Modeling Framework}},
   author = {Michael Jastram},
   editor = {Maalej, Walid and Thurimella, Anil},
   publisher = {Springer},
   year = {2013},
   month = {March},
   abstract = {
<p>This chapter presents the the Requirements Modeling Framework (RMF), an Eclipse-based open source platform for requirements engineering.  The core of RMF is based on the emerging Requirements Interchange Format (ReqIF), which is an OMG standard.  The project uses ReqIF as the central data model.  At the time of this writing, RMF was the only open source implementation of the ReqIF data model.</p><p>
By being based on an open standard that is currently gaining industry support, RMF can act as an interface to existing requirements management tools.  Further, by based on the Eclipse platform, integration with existing Eclipse-based offerings is possible.</p><p>
In this chapter, we will describe the architecture of the RMF project, as well as the underlying ReqIF standard.  Further, we give an overview of the GUI, which is called ProR.  A key strength of RMF and ProR is the extensibility, and we present the integration ProR with Rodin, which allows traceability between natural language requirements and Event-B formal models.</p>},
}

@unpublished{Hallerstede2013nopub1,
  title      = {On Sequentiality and Concurrency,},
  institution    = {Aarhus University},
  note     = {Technical Note},
  year       = {2013},
  author     = {Stefan Hallerstede},
  abstract   = {Based on methods for program verification by refinement such as the B-Method or VDM
we propose an approach for verifying programs composed of sequential and concurrent parts.
Similar to the approach to modelling and proving taken in Event-B we focus on the
support for incremental development and ease of proof.
We achieve this by following the style of proof obligations used in Event-B.
Mixing sequentiality and concurrency requires some structuring in the modelling notation.
The main challenge of our approach is permitting such structuring while keeping proof as easy as possible.
To achieve this we pragmatic with respect to the proof techniques employed
borrowing from Hoare-style program verification and rely-guarantee reasoning.
The approach is suitable for reasoning about abstract models of programs where
refinement is used for structuring a complex proof.
It does not describe a development method by step-wise refinement but an approach to fill in gaps in a complex proof.
Refinement is used to produce proofs comparable to those obtained by Hoare-style verification
but with flexibility obtained by refinement techniques.},
  month      = {March},
}

@unpublished{HalJasLad2013,
  author = {Stefan Hallerstede and Michael Jastram and Lukas Ladenberger},
  title = {A Method and Tool for Tracing Requirements into Specifications},
  note = {Science of Computer Programming},
  year = 2013,
  pages = {36 p},
  abstract   = {
<p>The creation of a consistent system description is a challenging problem of requirements engineering.
Formal and informal reasoning can greatly contribute to meet this challenge.
However, this demands that formal and informal reasoning and the system description are
connected in such way that the reasoning permits drawing conclusions about the system description.</p>

<p>We describe an incremental approach to requirements modelling and validation
that incorporates formal and informal reasoning.
Our main contribution is an approach to requirements tracing that delivers the necessary connection
that links the reasoning to the system description.
Formal refinement is used in order to deal with large and complex system descriptions.</p>

<p>We discuss tool support for our approach of requirements tracing that combines informal requirements modelling
with formal modelling and verification while tracing requirements among each other and into the formal model.</p>
},
  stupskeywords={advance},
}
@inproceedings{BoDiTr13_246,
  author     = {Carl Friedrich Bolz and Lukas Diekmann and Laurence Tratt},
  title      = {Storage strategies for collections in dynamically typed languages},
  booktitle  = {Proc. OOPSLA, to appear},
  abstract   = {Dynamically typed language implementations often use more memory and execute slower than their statically typed cousins, in part because operations on collections of elements are unoptimised. This paper describes storage strategies, which dynamically optimise collections whose elements are instances of the same primitive type. We implement storage strategies in the PyPy virtual machine, giving a performance increase of 18% on wide-ranging benchmarks of real Python programs. We show that storage strategies are simple to implement, needing only 1500LoC in PyPy, and have applicability to a wide range of virtual machines.

The experiments of this paper were accepted by OOPSLA's artefact evaluation committee.},
  year       = {2013},
  publisher = {{ACM}},
}


@incollection{FalampinLeuschelDeployBook,
  author = {Jerome Falampin and Hung Le-Dang and Michael Leuschel and Mikael Mokrani and Daniel Plagge},
  title = {Improving Railway Data Validation with {ProB}},
  booktitle = {Industrial Deployment of System Engineering Methods},
  publisher = {Springer},
  pages = {27--44},
  year = 2013,
  note = {to appear},
  url = {http://www.springer.com/computer/swe/book/978-3-642-33169-5},
  isbn = {978-3-642-33170-1},
}


@techreport{HansenLeuschel_TLC4B_techreport,
  author     = {Dominik Hansen and Michael Leuschel},
  title      = {Translating {B} to {TLA+} for Validation with {TLC}},
  number     = {STUPS/2013/xx},
  institution= {Institut für Informatik, Heinrich-Heine-Universität Düsseldorf},
  year       = {2013},
  url = {http://www.stups.uni-duesseldorf.de/w/Special:Publication/HansenLeuschel_TLC4B_techreport},
  abstract   = {This technical report is an extension to the conference
    submission with the same name. It contains translation tables and examples that were omitted
    in the conference paper.},
}



@article{LeuschelVidal-IC14,
  author = {Michael Leuschel and Germ\'an Vidal},
  title = {Fast offline partial evaluation of logic programs},
  year = 2014,
  journal = {Information and Computation},
  volume = 235,
   pages = {70--97},
 url = {http://www.sciencedirect.com/science/article/pii/S0890540114000066},
 abstract = {One of the most important challenges in partial evaluation is the
    design of automatic methods for ensuring the termination of the
    process.In this work, we introduce sufficient conditions for the strong
    (i.e., independent of a computation rule) termination and
    quasi-termination of logic programs which rely on the construction
    of so called size-change graphs.We then present a fast binding-time analysis that takes the output
    of the termination analysis and annotates logic programs so that
    partial evaluation terminates. In contrast to previous approaches,
    the new binding-time analysis is conceptually simpler and
    considerably faster, scaling to medium-sized or even large
    examples.Link: <a href="http://www.sciencedirect.com/science/article/pii/S0890540114000066">http://www.sciencedirect.com/science/article/pii/S0890540114000066</a>}
}


@inproceedings{hofm2014cspvis,
  author = {Lukas Ladenberger and Ivaylo Dobrikov and Michael Leuschel},
  title = {An Approach for Creating Domain Specific Visualisations of CSP Models},
  editor      = {Dimitra Giannakopoulou and Gwen Salaün},
  booktitle = {HOFM 2014},
  series    = {LNCS},
  year      = {2014},
  abstract   = {A domain specific visualisation can greatly contribute to better understanding of formal models. In this work we propose an approach that supports the user in creating domain specific visualisations of CSP models. CSP (Communicating Sequential Processes) is a formal language that is mainly used for specifying concurrent and distributed systems.We have successfully created various visualisations of CSP models in order to demonstrate our approach. The visualisations of two case studies are presented in this paper: the bully algorithm and a level crossing gate.In addition, we discuss possible applications of our approach.},
  stupskeywords={prob},
}

@inproceedings{sefm14por,
  author = {Ivaylo Dobrikov and Michael Leuschel},
  title = {Optimising the ProB Model Checker for {B} using Partial Order Reduction},
  editor      = {Dimitra Giannakopoulou and Gwen Salaün},
  booktitle = {SEFM 2014},
  doi = {http://dx.doi.org/10.1007/978-3-319-10431-7_16},
  series    = {LNCS 8702},
  year      = {2014},
  pages     = {220--234},
  address = {Grenoble},
  abstract   = {Partial order reduction has been very successful at combatting the state explosion problem for lower-level formalisms, but has thus far made hardly any impact for model checking higher-level formalisms such as B, Z or TLA+. This paper attempts to remedy this issue in the context of the increasing importance of Event-B, with its much more fine-grained events and thus increased potential for event-independence and partial order reduction. This paper provides a detailed description of a partial order reduction in ProB. The technique is evaluated on a variety of models. Additionally, the implementation of the method is discussed, which contains new constraint-based analyses.},
  stupskeywords={prob},
}

@incollection{2014formal,
  author      = {Michael Leuschel and Jens Bendisposto and Ivaylo Dobrikov and Sebastian Krings and Daniel Plagge},
  title       = {From Animation to Data Validation: The ProB Constraint Solver 10 Years On},
 pages = {427--446},
 chapter = {Chapter 14},
  editor      = {Jean-Louis Boulanger},
  booktitle   = {Formal Methods Applied to Complex Systems: Implementation of the B Method},
  publisher   = {Wiley ISTE},
  address     = {Hoboken, NJ},
  year        = {2014},
  url = {http://eu.wiley.com/WileyCDA/WileyTitle/productCd-1848216327.html},
  stupskeywords={advance,prob},
  abstract = {We present our ten year experience in developing and applying the ProB validation tool.
Initially, the tool provided animation and model checking capabilities for the B-method.
Over the years it has been extended to other formal specification languages and provides
 various constraint-based validation techniques.
The tool itself was developed in SICStus Prolog, makes use of the finite domain library together
 with newly developed constraint solvers for booleans, sets, relations and sequences.
 The various solvers are linked via reification and Prolog co-routines.
The overall challenge of ProB is to solve constraints in full predicate logic with arithmetic, set theory and higher-order
 relations and functions for safety critical applications.
In addition to the tool development, we also provide details about various industrial applications of the tool
 as well as about our efforts in qualifying the tool for usage in safety critical contexts.
Finally, we also describe our experiences in applying alternate approaches, such as SAT or SMT.
Link: <a href="http://onlinelibrary.wiley.com/doi/10.1002/9781119002727.ch14/summary">http://onlinelibrary.wiley.com/doi/10.1002/9781119002727.ch14/summary</a>}
}
@techreport{DobrikovLeuschelPORtechreport,
  author     = {Ivaylo Dobrikov and Michael Leuschel},
  title      = {Optimising the ProB Model Checker for {B} using Partial Order Reduction},
  number     = {STUPS/2014/xx},
  institution= {Institut für Informatik, Heinrich-Heine-Universität Düsseldorf},
  year       = {2014},
  stupskeywords={advance,prob},
  abstract   = {This technical report is an extension to the conference
    submission with the same name. It contains proofs and comments that were omitted
    in the conference paper.},
}
@inproceedings{sets14,
  author = {Sebastian Krings and Jens Bendisposto and Michael Leuschel},
  title = {Turning Failure into Proof: Evaluating the ProB Disprover},
  booktitle = {Proceedings of the 1st International Workshop about Sets and Tools},
  year = 2014,
  abstract   = {The ProB disprover uses constraint solving to try and find counter examples to proof obligations. As the ProB kernel is now capable of determining whether a search was exhaustive, one can also use the disprover as a prover. In this paper, we compare the ProB Prover with the standard automatic provers for B and Event-B, such as ml, pp and the Rodin SMT plug-in. We demonstrate that ProB is able to deal with classes of proof obligations that are not easily discharged by other provers.
As benchmarks we use medium sized specifications such as solutions to the ABZ 2014 case study, a CAN bus specification and a railway system.},
  stupskeywords={advance,prob},
}
@inproceedings{fide14pyb,
  author = {John Witulski and Michael Leuschel},
  title = {Checking Computations of Formal Method Tools - A Secondary Toolchain for ProB},
  booktitle = {Proceedings of the 1st Workshop on Formal-IDE},
  series    = {EPTCS 149, 2014},
  publisher = {Electronic Proceedings in Theoretical Computer Science},
  year = 2014,
  abstract   = {We present the implementation of PyB, a predicate- and expression-checker for the B language.
The tool is to be used for a secondary tool chain for data validation and data generation, with ProB being used in the primary tool chain.
Indeed, PyB is an independent cleanroom-implementation which
 is used to double-check solutions generated by ProB, an animator and model-checker for B specifications.
One of the major goals is to use ProB together with PyB to generate reliable outputs for high-integrity safety critical applications.
Although PyB is still work in progress, the ProB/pyB toolchain has already been successfully tested on various industrial B machines and data validation tasks.},
  stupskeywords={advance,prob,pyb},
}
@inproceedings{fide14toolchain,
  author = {Jens Bendisposto and Sebastian Krings and Michael Leuschel},
  title = {Who watches the watchers: Validating the ProB Validation Tool},
  booktitle = {Proceedings of the 1st Workshop on Formal-IDE},
  series    = {EPTCS 149, 2014},
  publisher = {Electronic Proceedings in Theoretical Computer Science},
  year = 2014,
  abstract   = {Over the years, ProB has moved from a tool that complemented proving,
 to a development environment that is now sometimes used instead of proving for applications, such as exhaustive model checking or data validation.
This has led to much more stringent requirements on the integrity of ProB.
In this paper we present a summary of our validation efforts for ProB, in particular within the context of the norm EN 50128 and safety critical applications in the railway domain.},
  stupskeywords={advance,prob},
}
@inproceedings{abz14casestudy,
  author = {Dominik Hansen and Lukas Ladenberger and Harald Wiegard and Jens Bendisposto and Michael Leuschel},
  title = {Validation of the ABZ Landing Gear System using ProB},
  booktitle={ABZ 2014: The Landing Gear Case Study},
  year = 2014,
  abstract   = {In this paper we present our formalisation of the ABZ landing gear case study in Event-B. The development was carried out using
the Rodin platform and mainly used superposition refinement to struc-
ture the specification. To validate the model we complemented proof with
animation and model checking. For the latter we used the ProB anima-
tor and model checker. Graphical representation of the model turned out
to be crucial in the development and validation of the model; this was
achieved using a new version of BMotion Studio integrated into ProB
2.0.},
  stupskeywords={prob},
}

@inproceedings{tla_abz14,
  author = {Dominik Hansen and Jens Bendisposto and Michael Leuschel},
  title = {Integrating ProB into the TLA Toolbox},
  booktitle = {TLA Workshop},
  year = 2014,
address = {Toulouse},
  abstract   = {The TLA2B translator enables the validation of TLA+ specifications with the model checker, animator and constraint-based checker ProB. In order to provide a convenient way to use ProB as new validation tool for TLA+, we integrated ProB into the TLA toolbox.},
  stupskeywords={advance,prob,tla},
}

@inproceedings{HansenLeuschel_ABZ14,
  author    = {Dominik Hansen and
               Michael Leuschel},
  title     = {Translating B to TLA + for Validation with TLC},
  booktitle = {Proceedings ABZ'14},
  series    = {LNCS 8477},
  year      = {2014},
  pages     = {40--55},
  ee        = {http://dx.doi.org/10.1007/978-3-662-43652-3_4},
  bibsource = {DBLP, http://dblp.uni-trier.de},
  abstract = {The state-based formal methods B and TLA+ share the common base of predicate logic, arithmetic and set theory.
However, there are still considerable differences, such as the way to specify state transitions, the different approaches to typing,
 and the available tool support.
In this paper, we present a translation from B to TLA+ to validate B specifications using the model checker TLC.
We provide translation rules for almost all constructs of B, in particular for those which are not built-in in TLA+.
The translation also includes many adaptations and optimizations to allow efficient checking by TLC.
Moreover, we present a way to validate liveness properties for B specifications under fairness conditions.
Our implemented translator, TLC4B, automatically translates a B specification to TLA+, invokes the model checker TLC, and translates the  results back to B. We use ProB to double check the counter examples produced by TLC and replay them in the ProB animator.
We also present a series of case studies and benchmark tests comparing TLC4B and ProB.},
  stupskeywords={advance,prob,tla},
}

@incollection{LeuschelSchneider_ABZ14,
year={2014},
isbn={978-3-662-43651-6},
booktitle={Abstract State Machines, Alloy, B, TLA, VDM, and Z},
volume={8477},
series={Lecture Notes in Computer Science},
editor={Ait Ameur, Yamine and Schewe, Klaus-Dieter},
doi={10.1007/978-3-662-43652-3_8},
title={Towards B as a High-Level Constraint Modelling Language},
url={http://dx.doi.org/10.1007/978-3-662-43652-3_8},
publisher={Springer Berlin Heidelberg},
keywords={B-method; constraint programming; logic programming; Alloy; Kodkod; optimization},
author={Leuschel, Michael and Schneider, David},
pages={101-116},
abstract={We argue that B is a good language to conveniently express a wide range of constraint satisfaction problems. We also show that some problems can be solved quite effectively by the ProB tool. We illustrate our claim on several examples, such as the jobs puzzle - for which we solve the challenge set out by Shapiro. Here we show that the B formalization is both very close to the natural language specification and can still be solved efficiently by ProB. Our approach is particularly interesting when a high assurance of correctness is required. Indeed, compared to other existing approaches and tools, validation and double checking of solutions is available for ProB and formal proof can be applied to establish important properties or provide an unambiguous semantics to the problem specification.},
  stupskeywords={prob},
}

@inproceedings{EasyChair:390,
  author    = {Michael Leuschel},
  title     = {Towards Constraint-Solving over Higher-Order Unbounded Datatypes using Formal Methods Tools},
  booktitle = {VPT 2014},
  editor    = {Alexei Lisitsa and Andrei Nemytykh},
  series    = {EPiC Series},
  volume    = {28},
  pages     = {1-1},
  year      = {2014},
  publisher = {EasyChair},
  bibsource = {EasyChair, http://www.easychair.org},
  issn      = {2040-557X},
  stupskeywords={advance,prob},
  url = {http://easychair.org/publications/?page=1018594602},
 abstract = {We argue that formal methods such as B can be used to conveniently express a wide range of constraint satisfaction problems. We also show that some problems can be solved quite eectively by existing formal methods tools such as Alloy or ProB. We illustrate our claim on several examples. Our approach is particularly interesting when a high assurance of correctness is required. Indeed, validation and double checking of solutions is available for certain formal methods tools and formal proof can be applied to establish important properties or provide unambiguous semantics to problem specications. The experiments also provide interesting insights about the eectiveness of existing formal method tools, and highlight interesting avenues for future improvement.},
}




@article{abz14casestudyjournal,
year={2015},
issn={1433-2779},
journal={International Journal on Software Tools for Technology Transfer},
doi={10.1007/s10009-015-0395-9},
title={Validation of the ABZ landing gear system using ProB},
url={http://dx.doi.org/10.1007/s10009-015-0395-9},
publisher={Springer Berlin Heidelberg},
keywords={Formal methods; B-method; Validation; Toolchain; Visualization},
author={Ladenberger, Lukas and Hansen, Dominik and Wiegard, Harald and Bendisposto, Jens and Leuschel, Michael},
pages={1-17},
abstract={In this article, we present our formalization of the ABZ landing gear case study in Event-B. The development was carried out using the Rodin platform and mainly used superposition refinement to structure the specification. To validate the model, we complemented proof with animation and model checking. For the latter, we used the ProB animator and model checker. Graphical representation of the model turned out to be crucial in the development and validation of the model; this was achieved using the visualization features provided by ProB and BMotion Studio. In addition, we discuss the positive and negative aspects of the Event-B language and tools which we encountered while working on the ABZ case study.},
language={English},
stupskeywords = {prob},
}
@inproceedings{timetable_validation,
  author     = {David Schneider and Michael Leuschel and Tobias Witt},
  title      = {{Model-Based Problem Solving for University Timetable Validation and Improvement}},
  booktitle  = {FM 2015: Formal Methods: 20th International Symposium},
  series     = {Lecture Notes in Computer Science (Book 9109)},
  publisher  = {Springer},
  year       = {2015},
  pages= {487-495},
  abstract   = {Constraint satisfaction problems can be expressed very elegantly in state-based formal methods such as B. However, can such specifications be directly used for solving real-life problems? We will try and answer this question in the present paper with regard to the university timetabling problem. We report on an ongoing project to build a formal model-based curriculum timetable validation tool where we use a formal specification as the basis to validate timetables from a student’s perspective and to support incremental modification of timetables. In this article we focus on expressing the problem domain, the formalization in B and our approach to execute the formal model in a production system using ProB.},
stupskeywords = {prob},
}
@inproceedings{disprover_eval,
  author     = {Sebastian Krings and Jens Bendisposto and Michael Leuschel},
  title      = {{From Failure to Proof: The ProB Disprover for B and Event-B}},
  booktitle  = {Proceedings SEFM'2015},
  series     = {LNCS 9276},
  publisher  = {Springer},
  year       = {2015},
  abstract   = {The ProB disprover uses constraint solving to find counter examples for B proof obligations. As the ProB kernel is now capable of determining whether a search was exhaustive, one can also use the disprover as a prover. In this paper, we explain how ProB has been embedded as a prover into Rodin and Atelier B. Furthermore, we compare ProB with the standard automatic provers and SMT solvers used in Rodin. We demonstrate that constraint solving in general and ProB in particular are able to deal with classes of proof obligations that are not easily discharged by other provers and solvers. As benchmarks we use medium sized specifications such as landing gear systems, a CAN bus specification and a railway system. We also present a new method to check proof obligations for inconsistencies, which has helped uncover various issues in existing (sometimes fully proven) models.},
stupskeywords = {prob},
}

@article{KringsLeuschelUnitsJournal,
year = {2015},
issn = {1619-1366},
journal = {Software & Systems Modeling},
doi = {10.1007/s10270-015-0458-0},
title = {Inferring Physical Units in Formal Models},
publisher = {Springer Berlin Heidelberg},
keywords = {B-Method; Event-B; Physical Units; Model Checking; Abstract Interpretation},
author = {Krings, Sebastian and Leuschel, Michael},
pages = {1-23},
language = {English},
abstract = {Most state-based formal methods, like B, Event-B or Z, provide support for static typing.
However, these methods and the associated tools lack support for annotating variables with (physical) units of measurement.
There is thus no obvious way to reason about correct or incorrect usage of such units.
We present a technique that analyses the usage of physical units throughout B and Event-B machines, infers missing units and notifies the user of incorrectly handled units.
The technique combines abstract interpretation with classical animation, constraint solving and model checking and
 has been integrated into the ProB validation tool, both for classical B and for Event-B.
 It provides source-level feedback about errors detected in the models.
We also describe how to extend our approach to TLA+, an untyped formal language.
We provide an in-depth empirical evaluation and demonstrate that our technique scales up to real-life industrial models.},
stupskeywords = {prob},
}

@techreport{HansenLeuschel_TLC4B_Journal,
  author     = {Dominik Hansen and Michael Leuschel},
  title      = {Translating {B} to {TLA+} for Validation with {TLC}},
  institution= {Institut für Informatik, Heinrich-Heine-Universität Düsseldorf},
  year       = {2015},
  number = {STUPS/2015/Feb},
  url = {http://www.stups.uni-duesseldorf.de/w/Special:Publication/HansenLeuschel_TLC4B_Journal},
  abstract = {This technical report is an extension to the ABZ'2014 conference
      submission with the same name. It is submitted to Science of Computer Programming.},
}

@techreport{LadenbergerLeuschel_ProjectDiagram,
  author     = {Lukas Ladenberger and Michael Leuschel},
  title      = {Mastering the Visualization of Larger State Spaces with Projection Diagrams},
  institution= {Institut für Informatik, Heinrich-Heine-Universität Düsseldorf},
  year       = {2015},
  number = {STUPS/2015/May},
  url = {http://www.stups.uni-duesseldorf.de/w/Special:Publication/LadenbergerLeuschel_ProjectDiagram},
  abstract = {This technical report is an extension to the ICFEM'15 conference paper with the same name. It contains more diagram examples that were omitted in the conference paper.},
}
@inproceedings{LadenbergerLeuschel_ICFEM15,
 author = {Lukas Ladenberger and Michael Leuschel},
 title = {Mastering the Visualization of Larger State Spaces with Projection Diagrams},
 booktitle = {Proceedings ICFEM'2015},
 publisher = {Springer-Verlag},
 series = {LNCS 9407},
pages = {153--169},
 year = {2015},
abstract = {State space visualization is a popular technique for supporting the analysis of formal models.
It often allows users to get a global view of the system and to identify structural similarities, symmetries, and unanticipated properties (only to name a few).
However, state spaces typically become very large, so human inspection of the visualization becomes difficult.
To overcome this challenge, we present an approach which can considerably reduce the size of the state space by creating projection diagrams.
Moreover, we present an approach to link a projection diagram with a domain specific visualization.
The projection diagram construction can be initiated directly from user-selected graphical elements, without the user having to write formulas or having to know the variables or internal structure of the model.
This makes the projection diagram inspection and construction accessible to non-formal method experts.
These techniques have been implemented within the ProB toolset, and we demonstrate their benefits and usefulness on several examples.}
}
